
#include <dlfcn.h>
#include <stdio.h>
#include <sys/time.h>
#include <time.h>
#include <iostream>
#include <sstream>
#include <cxxabi.h>
#include <iostream>
#include <cstdlib>
#include <cassert>
#include <map>
#include <vector>
#include <chrono>
#include <string>

#include <cuda_runtime.h>
#include <cuda_runtime_api.h>
#include <cuda.h>
#include <cudnn.h>
#include <cublas_v2.h>
#include <nvrtc.h>
#include <cublasLt.h>
#include <cuda_profiler_api.h>
#include <cudaProfiler.h>
#include <nccl.h>
#include <curand.h>

// g++ -I/usr/local/cuda/include -fPIC -shared -o preload.so preload.cpp

typedef std::chrono::time_point<std::chrono::system_clock> time_point_t;

class PreloadTracer {

public:
    bool profile_start = false;
    bool print_trace;
    void *cudnn_handle;
    std::vector<const void *> _kernel_seq;
    std::vector<float> _kernel_time;
    std::vector<std::pair<time_point_t, time_point_t>> _cpu_timestamps;
    std::map<const void *, std::string> _kernel_map;

    PreloadTracer(bool print_trace=true) :
        print_trace(print_trace)
    {
        cudnn_handle = dlopen("/usr/local/cuda/lib64/libcudnn.so", RTLD_LAZY);
        assert(cudnn_handle);
    }

    ~PreloadTracer() {
        std::cout << "preload_post_process" << std::endl;
        if (_kernel_time.size() > 0) {
            assert(_kernel_time.size() == _kernel_seq.size());
        }
        if (_cpu_timestamps.size() > 0) {
            assert(_cpu_timestamps.size() == _kernel_seq.size());
        }
        for (size_t i = 0; i < _kernel_seq.size(); i++) {
            auto _kernel = _kernel_seq[i];
            if (_kernel_map.find(_kernel) != _kernel_map.end()) {

                std::ostringstream stream;

                stream << _kernel_map[_kernel];

                if (_kernel_time.size() > 0) {
                    stream << " Kernel Time: " << _kernel_time[i];
                }

                if (_cpu_timestamps.size() > 0) {
                    stream << " Start: " <<
						std::chrono::duration_cast<std::chrono::nanoseconds>(
                   			_cpu_timestamps[i].first.time_since_epoch()).count();
                    stream << " End: " <<
						std::chrono::duration_cast<std::chrono::nanoseconds>(
                   			_cpu_timestamps[i].second.time_since_epoch()).count();
                }

                if (print_trace) {
                    std::cout << stream.str() << std::endl;
                }
            } else {
                std::cerr << "Cannot find _kernel in _kernel_map" << std::endl;
            }
        }
    }
};

std::string demangleFunc(std::string mangledName)
{
    int status;
    char *demangled_name = abi::__cxa_demangle(mangledName.c_str(), nullptr, nullptr, &status);
    
    if (status == 0) {
        std::string demangled_name_str(demangled_name);
        free(demangled_name);
        return demangled_name_str;
    } else {
        return mangledName;
    }
}


PreloadTracer tracer(true);

    

extern "C" { 

CUresult cuGetErrorString(CUresult  error, const char ** pStr)
{
	static CUresult (*lcuGetErrorString) (CUresult , const char **);
	if (!lcuGetErrorString) {
		lcuGetErrorString = (CUresult (*) (CUresult , const char **)) dlsym(RTLD_NEXT, "cuGetErrorString");
		tracer._kernel_map[(void *) lcuGetErrorString] = std::string("cuGetErrorString");
	}
	assert(lcuGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGetErrorString(error, pStr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGetErrorString);
	}
	return res;
}

CUresult cuGetErrorName(CUresult  error, const char ** pStr)
{
	static CUresult (*lcuGetErrorName) (CUresult , const char **);
	if (!lcuGetErrorName) {
		lcuGetErrorName = (CUresult (*) (CUresult , const char **)) dlsym(RTLD_NEXT, "cuGetErrorName");
		tracer._kernel_map[(void *) lcuGetErrorName] = std::string("cuGetErrorName");
	}
	assert(lcuGetErrorName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGetErrorName(error, pStr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGetErrorName);
	}
	return res;
}

CUresult cuInit(unsigned int  Flags)
{
	static CUresult (*lcuInit) (unsigned int );
	if (!lcuInit) {
		lcuInit = (CUresult (*) (unsigned int )) dlsym(RTLD_NEXT, "cuInit");
		tracer._kernel_map[(void *) lcuInit] = std::string("cuInit");
	}
	assert(lcuInit);
	CUresult res = 
		lcuInit(Flags);
	return res;
}

CUresult cuDriverGetVersion(int * driverVersion)
{
	static CUresult (*lcuDriverGetVersion) (int *);
	if (!lcuDriverGetVersion) {
		lcuDriverGetVersion = (CUresult (*) (int *)) dlsym(RTLD_NEXT, "cuDriverGetVersion");
		tracer._kernel_map[(void *) lcuDriverGetVersion] = std::string("cuDriverGetVersion");
	}
	assert(lcuDriverGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDriverGetVersion(driverVersion);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDriverGetVersion);
	}
	return res;
}

CUresult cuDeviceGet(CUdevice * device, int  ordinal)
{
	static CUresult (*lcuDeviceGet) (CUdevice *, int );
	if (!lcuDeviceGet) {
		lcuDeviceGet = (CUresult (*) (CUdevice *, int )) dlsym(RTLD_NEXT, "cuDeviceGet");
		tracer._kernel_map[(void *) lcuDeviceGet] = std::string("cuDeviceGet");
	}
	assert(lcuDeviceGet);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGet(device, ordinal);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGet);
	}
	return res;
}

CUresult cuDeviceGetCount(int * count)
{
	static CUresult (*lcuDeviceGetCount) (int *);
	if (!lcuDeviceGetCount) {
		lcuDeviceGetCount = (CUresult (*) (int *)) dlsym(RTLD_NEXT, "cuDeviceGetCount");
		tracer._kernel_map[(void *) lcuDeviceGetCount] = std::string("cuDeviceGetCount");
	}
	assert(lcuDeviceGetCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetCount(count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetCount);
	}
	return res;
}

CUresult cuDeviceGetName(char * name, int  len, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetName) (char *, int , CUdevice );
	if (!lcuDeviceGetName) {
		lcuDeviceGetName = (CUresult (*) (char *, int , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetName");
		tracer._kernel_map[(void *) lcuDeviceGetName] = std::string("cuDeviceGetName");
	}
	assert(lcuDeviceGetName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetName(name, len, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetName);
	}
	return res;
}

CUresult cuDeviceGetUuid(CUuuid * uuid, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetUuid) (CUuuid *, CUdevice );
	if (!lcuDeviceGetUuid) {
		lcuDeviceGetUuid = (CUresult (*) (CUuuid *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetUuid");
		tracer._kernel_map[(void *) lcuDeviceGetUuid] = std::string("cuDeviceGetUuid");
	}
	assert(lcuDeviceGetUuid);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetUuid(uuid, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetUuid);
	}
	return res;
}

CUresult cuDeviceGetUuid_v2(CUuuid * uuid, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetUuid_v2) (CUuuid *, CUdevice );
	if (!lcuDeviceGetUuid_v2) {
		lcuDeviceGetUuid_v2 = (CUresult (*) (CUuuid *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetUuid_v2");
		tracer._kernel_map[(void *) lcuDeviceGetUuid_v2] = std::string("cuDeviceGetUuid_v2");
	}
	assert(lcuDeviceGetUuid_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetUuid_v2(uuid, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetUuid_v2);
	}
	return res;
}

CUresult cuDeviceGetLuid(char * luid, unsigned int * deviceNodeMask, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetLuid) (char *, unsigned int *, CUdevice );
	if (!lcuDeviceGetLuid) {
		lcuDeviceGetLuid = (CUresult (*) (char *, unsigned int *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetLuid");
		tracer._kernel_map[(void *) lcuDeviceGetLuid] = std::string("cuDeviceGetLuid");
	}
	assert(lcuDeviceGetLuid);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetLuid(luid, deviceNodeMask, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetLuid);
	}
	return res;
}

CUresult cuDeviceTotalMem_v2(size_t * bytes, CUdevice  dev)
{
	static CUresult (*lcuDeviceTotalMem_v2) (size_t *, CUdevice );
	if (!lcuDeviceTotalMem_v2) {
		lcuDeviceTotalMem_v2 = (CUresult (*) (size_t *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceTotalMem_v2");
		tracer._kernel_map[(void *) lcuDeviceTotalMem_v2] = std::string("cuDeviceTotalMem_v2");
	}
	assert(lcuDeviceTotalMem_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceTotalMem_v2(bytes, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceTotalMem_v2);
	}
	return res;
}

CUresult cuDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, CUarray_format  format, unsigned  numChannels, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetTexture1DLinearMaxWidth) (size_t *, CUarray_format , unsigned , CUdevice );
	if (!lcuDeviceGetTexture1DLinearMaxWidth) {
		lcuDeviceGetTexture1DLinearMaxWidth = (CUresult (*) (size_t *, CUarray_format , unsigned , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetTexture1DLinearMaxWidth");
		tracer._kernel_map[(void *) lcuDeviceGetTexture1DLinearMaxWidth] = std::string("cuDeviceGetTexture1DLinearMaxWidth");
	}
	assert(lcuDeviceGetTexture1DLinearMaxWidth);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetTexture1DLinearMaxWidth(maxWidthInElements, format, numChannels, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetTexture1DLinearMaxWidth);
	}
	return res;
}

CUresult cuDeviceGetAttribute(int * pi, CUdevice_attribute  attrib, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetAttribute) (int *, CUdevice_attribute , CUdevice );
	if (!lcuDeviceGetAttribute) {
		lcuDeviceGetAttribute = (CUresult (*) (int *, CUdevice_attribute , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetAttribute");
		tracer._kernel_map[(void *) lcuDeviceGetAttribute] = std::string("cuDeviceGetAttribute");
	}
	assert(lcuDeviceGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetAttribute(pi, attrib, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetAttribute);
	}
	return res;
}

CUresult cuDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, CUdevice  dev, int  flags)
{
	static CUresult (*lcuDeviceGetNvSciSyncAttributes) (void *, CUdevice , int );
	if (!lcuDeviceGetNvSciSyncAttributes) {
		lcuDeviceGetNvSciSyncAttributes = (CUresult (*) (void *, CUdevice , int )) dlsym(RTLD_NEXT, "cuDeviceGetNvSciSyncAttributes");
		tracer._kernel_map[(void *) lcuDeviceGetNvSciSyncAttributes] = std::string("cuDeviceGetNvSciSyncAttributes");
	}
	assert(lcuDeviceGetNvSciSyncAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, dev, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetNvSciSyncAttributes);
	}
	return res;
}

CUresult cuDeviceSetMemPool(CUdevice  dev, CUmemoryPool  pool)
{
	static CUresult (*lcuDeviceSetMemPool) (CUdevice , CUmemoryPool );
	if (!lcuDeviceSetMemPool) {
		lcuDeviceSetMemPool = (CUresult (*) (CUdevice , CUmemoryPool )) dlsym(RTLD_NEXT, "cuDeviceSetMemPool");
		tracer._kernel_map[(void *) lcuDeviceSetMemPool] = std::string("cuDeviceSetMemPool");
	}
	assert(lcuDeviceSetMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceSetMemPool(dev, pool);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceSetMemPool);
	}
	return res;
}

CUresult cuDeviceGetMemPool(CUmemoryPool * pool, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetMemPool) (CUmemoryPool *, CUdevice );
	if (!lcuDeviceGetMemPool) {
		lcuDeviceGetMemPool = (CUresult (*) (CUmemoryPool *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetMemPool");
		tracer._kernel_map[(void *) lcuDeviceGetMemPool] = std::string("cuDeviceGetMemPool");
	}
	assert(lcuDeviceGetMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetMemPool(pool, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetMemPool);
	}
	return res;
}

CUresult cuDeviceGetDefaultMemPool(CUmemoryPool * pool_out, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetDefaultMemPool) (CUmemoryPool *, CUdevice );
	if (!lcuDeviceGetDefaultMemPool) {
		lcuDeviceGetDefaultMemPool = (CUresult (*) (CUmemoryPool *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetDefaultMemPool");
		tracer._kernel_map[(void *) lcuDeviceGetDefaultMemPool] = std::string("cuDeviceGetDefaultMemPool");
	}
	assert(lcuDeviceGetDefaultMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetDefaultMemPool(pool_out, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetDefaultMemPool);
	}
	return res;
}

CUresult cuDeviceGetExecAffinitySupport(int * pi, CUexecAffinityType  type, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetExecAffinitySupport) (int *, CUexecAffinityType , CUdevice );
	if (!lcuDeviceGetExecAffinitySupport) {
		lcuDeviceGetExecAffinitySupport = (CUresult (*) (int *, CUexecAffinityType , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetExecAffinitySupport");
		tracer._kernel_map[(void *) lcuDeviceGetExecAffinitySupport] = std::string("cuDeviceGetExecAffinitySupport");
	}
	assert(lcuDeviceGetExecAffinitySupport);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetExecAffinitySupport(pi, type, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetExecAffinitySupport);
	}
	return res;
}

CUresult cuFlushGPUDirectRDMAWrites(CUflushGPUDirectRDMAWritesTarget  target, CUflushGPUDirectRDMAWritesScope  scope)
{
	static CUresult (*lcuFlushGPUDirectRDMAWrites) (CUflushGPUDirectRDMAWritesTarget , CUflushGPUDirectRDMAWritesScope );
	if (!lcuFlushGPUDirectRDMAWrites) {
		lcuFlushGPUDirectRDMAWrites = (CUresult (*) (CUflushGPUDirectRDMAWritesTarget , CUflushGPUDirectRDMAWritesScope )) dlsym(RTLD_NEXT, "cuFlushGPUDirectRDMAWrites");
		tracer._kernel_map[(void *) lcuFlushGPUDirectRDMAWrites] = std::string("cuFlushGPUDirectRDMAWrites");
	}
	assert(lcuFlushGPUDirectRDMAWrites);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFlushGPUDirectRDMAWrites(target, scope);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFlushGPUDirectRDMAWrites);
	}
	return res;
}

CUresult cuDeviceGetProperties(CUdevprop * prop, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetProperties) (CUdevprop *, CUdevice );
	if (!lcuDeviceGetProperties) {
		lcuDeviceGetProperties = (CUresult (*) (CUdevprop *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetProperties");
		tracer._kernel_map[(void *) lcuDeviceGetProperties] = std::string("cuDeviceGetProperties");
	}
	assert(lcuDeviceGetProperties);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetProperties(prop, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetProperties);
	}
	return res;
}

CUresult cuDeviceComputeCapability(int * major, int * minor, CUdevice  dev)
{
	static CUresult (*lcuDeviceComputeCapability) (int *, int *, CUdevice );
	if (!lcuDeviceComputeCapability) {
		lcuDeviceComputeCapability = (CUresult (*) (int *, int *, CUdevice )) dlsym(RTLD_NEXT, "cuDeviceComputeCapability");
		tracer._kernel_map[(void *) lcuDeviceComputeCapability] = std::string("cuDeviceComputeCapability");
	}
	assert(lcuDeviceComputeCapability);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceComputeCapability(major, minor, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceComputeCapability);
	}
	return res;
}

CUresult cuDevicePrimaryCtxRetain(CUcontext * pctx, CUdevice  dev)
{
	static CUresult (*lcuDevicePrimaryCtxRetain) (CUcontext *, CUdevice );
	if (!lcuDevicePrimaryCtxRetain) {
		lcuDevicePrimaryCtxRetain = (CUresult (*) (CUcontext *, CUdevice )) dlsym(RTLD_NEXT, "cuDevicePrimaryCtxRetain");
		tracer._kernel_map[(void *) lcuDevicePrimaryCtxRetain] = std::string("cuDevicePrimaryCtxRetain");
	}
	assert(lcuDevicePrimaryCtxRetain);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDevicePrimaryCtxRetain(pctx, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDevicePrimaryCtxRetain);
	}
	return res;
}

CUresult cuDevicePrimaryCtxRelease_v2(CUdevice  dev)
{
	static CUresult (*lcuDevicePrimaryCtxRelease_v2) (CUdevice );
	if (!lcuDevicePrimaryCtxRelease_v2) {
		lcuDevicePrimaryCtxRelease_v2 = (CUresult (*) (CUdevice )) dlsym(RTLD_NEXT, "cuDevicePrimaryCtxRelease_v2");
		tracer._kernel_map[(void *) lcuDevicePrimaryCtxRelease_v2] = std::string("cuDevicePrimaryCtxRelease_v2");
	}
	assert(lcuDevicePrimaryCtxRelease_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDevicePrimaryCtxRelease_v2(dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDevicePrimaryCtxRelease_v2);
	}
	return res;
}

CUresult cuDevicePrimaryCtxSetFlags_v2(CUdevice  dev, unsigned int  flags)
{
	static CUresult (*lcuDevicePrimaryCtxSetFlags_v2) (CUdevice , unsigned int );
	if (!lcuDevicePrimaryCtxSetFlags_v2) {
		lcuDevicePrimaryCtxSetFlags_v2 = (CUresult (*) (CUdevice , unsigned int )) dlsym(RTLD_NEXT, "cuDevicePrimaryCtxSetFlags_v2");
		tracer._kernel_map[(void *) lcuDevicePrimaryCtxSetFlags_v2] = std::string("cuDevicePrimaryCtxSetFlags_v2");
	}
	assert(lcuDevicePrimaryCtxSetFlags_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDevicePrimaryCtxSetFlags_v2(dev, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDevicePrimaryCtxSetFlags_v2);
	}
	return res;
}

CUresult cuDevicePrimaryCtxGetState(CUdevice  dev, unsigned int * flags, int * active)
{
	static CUresult (*lcuDevicePrimaryCtxGetState) (CUdevice , unsigned int *, int *);
	if (!lcuDevicePrimaryCtxGetState) {
		lcuDevicePrimaryCtxGetState = (CUresult (*) (CUdevice , unsigned int *, int *)) dlsym(RTLD_NEXT, "cuDevicePrimaryCtxGetState");
		tracer._kernel_map[(void *) lcuDevicePrimaryCtxGetState] = std::string("cuDevicePrimaryCtxGetState");
	}
	assert(lcuDevicePrimaryCtxGetState);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDevicePrimaryCtxGetState(dev, flags, active);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDevicePrimaryCtxGetState);
	}
	return res;
}

CUresult cuDevicePrimaryCtxReset_v2(CUdevice  dev)
{
	static CUresult (*lcuDevicePrimaryCtxReset_v2) (CUdevice );
	if (!lcuDevicePrimaryCtxReset_v2) {
		lcuDevicePrimaryCtxReset_v2 = (CUresult (*) (CUdevice )) dlsym(RTLD_NEXT, "cuDevicePrimaryCtxReset_v2");
		tracer._kernel_map[(void *) lcuDevicePrimaryCtxReset_v2] = std::string("cuDevicePrimaryCtxReset_v2");
	}
	assert(lcuDevicePrimaryCtxReset_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDevicePrimaryCtxReset_v2(dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDevicePrimaryCtxReset_v2);
	}
	return res;
}

CUresult cuCtxCreate_v2(CUcontext * pctx, unsigned int  flags, CUdevice  dev)
{
	static CUresult (*lcuCtxCreate_v2) (CUcontext *, unsigned int , CUdevice );
	if (!lcuCtxCreate_v2) {
		lcuCtxCreate_v2 = (CUresult (*) (CUcontext *, unsigned int , CUdevice )) dlsym(RTLD_NEXT, "cuCtxCreate_v2");
		tracer._kernel_map[(void *) lcuCtxCreate_v2] = std::string("cuCtxCreate_v2");
	}
	assert(lcuCtxCreate_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxCreate_v2(pctx, flags, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxCreate_v2);
	}
	return res;
}

CUresult cuCtxCreate_v3(CUcontext * pctx, CUexecAffinityParam * paramsArray, int  numParams, unsigned int  flags, CUdevice  dev)
{
	static CUresult (*lcuCtxCreate_v3) (CUcontext *, CUexecAffinityParam *, int , unsigned int , CUdevice );
	if (!lcuCtxCreate_v3) {
		lcuCtxCreate_v3 = (CUresult (*) (CUcontext *, CUexecAffinityParam *, int , unsigned int , CUdevice )) dlsym(RTLD_NEXT, "cuCtxCreate_v3");
		tracer._kernel_map[(void *) lcuCtxCreate_v3] = std::string("cuCtxCreate_v3");
	}
	assert(lcuCtxCreate_v3);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxCreate_v3(pctx, paramsArray, numParams, flags, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxCreate_v3);
	}
	return res;
}

CUresult cuCtxDestroy_v2(CUcontext  ctx)
{
	static CUresult (*lcuCtxDestroy_v2) (CUcontext );
	if (!lcuCtxDestroy_v2) {
		lcuCtxDestroy_v2 = (CUresult (*) (CUcontext )) dlsym(RTLD_NEXT, "cuCtxDestroy_v2");
		tracer._kernel_map[(void *) lcuCtxDestroy_v2] = std::string("cuCtxDestroy_v2");
	}
	assert(lcuCtxDestroy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxDestroy_v2(ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxDestroy_v2);
	}
	return res;
}

CUresult cuCtxPushCurrent_v2(CUcontext  ctx)
{
	static CUresult (*lcuCtxPushCurrent_v2) (CUcontext );
	if (!lcuCtxPushCurrent_v2) {
		lcuCtxPushCurrent_v2 = (CUresult (*) (CUcontext )) dlsym(RTLD_NEXT, "cuCtxPushCurrent_v2");
		tracer._kernel_map[(void *) lcuCtxPushCurrent_v2] = std::string("cuCtxPushCurrent_v2");
	}
	assert(lcuCtxPushCurrent_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxPushCurrent_v2(ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxPushCurrent_v2);
	}
	return res;
}

CUresult cuCtxPopCurrent_v2(CUcontext * pctx)
{
	static CUresult (*lcuCtxPopCurrent_v2) (CUcontext *);
	if (!lcuCtxPopCurrent_v2) {
		lcuCtxPopCurrent_v2 = (CUresult (*) (CUcontext *)) dlsym(RTLD_NEXT, "cuCtxPopCurrent_v2");
		tracer._kernel_map[(void *) lcuCtxPopCurrent_v2] = std::string("cuCtxPopCurrent_v2");
	}
	assert(lcuCtxPopCurrent_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxPopCurrent_v2(pctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxPopCurrent_v2);
	}
	return res;
}

CUresult cuCtxSetCurrent(CUcontext  ctx)
{
	static CUresult (*lcuCtxSetCurrent) (CUcontext );
	if (!lcuCtxSetCurrent) {
		lcuCtxSetCurrent = (CUresult (*) (CUcontext )) dlsym(RTLD_NEXT, "cuCtxSetCurrent");
		tracer._kernel_map[(void *) lcuCtxSetCurrent] = std::string("cuCtxSetCurrent");
	}
	assert(lcuCtxSetCurrent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSetCurrent(ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSetCurrent);
	}
	return res;
}

CUresult cuCtxGetCurrent(CUcontext * pctx)
{
	static CUresult (*lcuCtxGetCurrent) (CUcontext *);
	if (!lcuCtxGetCurrent) {
		lcuCtxGetCurrent = (CUresult (*) (CUcontext *)) dlsym(RTLD_NEXT, "cuCtxGetCurrent");
		tracer._kernel_map[(void *) lcuCtxGetCurrent] = std::string("cuCtxGetCurrent");
	}
	assert(lcuCtxGetCurrent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetCurrent(pctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetCurrent);
	}
	return res;
}

CUresult cuCtxGetDevice(CUdevice * device)
{
	static CUresult (*lcuCtxGetDevice) (CUdevice *);
	if (!lcuCtxGetDevice) {
		lcuCtxGetDevice = (CUresult (*) (CUdevice *)) dlsym(RTLD_NEXT, "cuCtxGetDevice");
		tracer._kernel_map[(void *) lcuCtxGetDevice] = std::string("cuCtxGetDevice");
	}
	assert(lcuCtxGetDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetDevice(device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetDevice);
	}
	return res;
}

CUresult cuCtxGetFlags(unsigned int * flags)
{
	static CUresult (*lcuCtxGetFlags) (unsigned int *);
	if (!lcuCtxGetFlags) {
		lcuCtxGetFlags = (CUresult (*) (unsigned int *)) dlsym(RTLD_NEXT, "cuCtxGetFlags");
		tracer._kernel_map[(void *) lcuCtxGetFlags] = std::string("cuCtxGetFlags");
	}
	assert(lcuCtxGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetFlags(flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetFlags);
	}
	return res;
}

CUresult cuCtxSetFlags(unsigned int  flags)
{
	static CUresult (*lcuCtxSetFlags) (unsigned int );
	if (!lcuCtxSetFlags) {
		lcuCtxSetFlags = (CUresult (*) (unsigned int )) dlsym(RTLD_NEXT, "cuCtxSetFlags");
		tracer._kernel_map[(void *) lcuCtxSetFlags] = std::string("cuCtxSetFlags");
	}
	assert(lcuCtxSetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSetFlags(flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSetFlags);
	}
	return res;
}

CUresult cuCtxGetId(CUcontext  ctx, unsigned long long * ctxId)
{
	static CUresult (*lcuCtxGetId) (CUcontext , unsigned long long *);
	if (!lcuCtxGetId) {
		lcuCtxGetId = (CUresult (*) (CUcontext , unsigned long long *)) dlsym(RTLD_NEXT, "cuCtxGetId");
		tracer._kernel_map[(void *) lcuCtxGetId] = std::string("cuCtxGetId");
	}
	assert(lcuCtxGetId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetId(ctx, ctxId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetId);
	}
	return res;
}

CUresult cuCtxSynchronize()
{
	static CUresult (*lcuCtxSynchronize) ();
	if (!lcuCtxSynchronize) {
		lcuCtxSynchronize = (CUresult (*) ()) dlsym(RTLD_NEXT, "cuCtxSynchronize");
		tracer._kernel_map[(void *) lcuCtxSynchronize] = std::string("cuCtxSynchronize");
	}
	assert(lcuCtxSynchronize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSynchronize();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSynchronize);
	}
	return res;
}

CUresult cuCtxSetLimit(CUlimit  limit, size_t  value)
{
	static CUresult (*lcuCtxSetLimit) (CUlimit , size_t );
	if (!lcuCtxSetLimit) {
		lcuCtxSetLimit = (CUresult (*) (CUlimit , size_t )) dlsym(RTLD_NEXT, "cuCtxSetLimit");
		tracer._kernel_map[(void *) lcuCtxSetLimit] = std::string("cuCtxSetLimit");
	}
	assert(lcuCtxSetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSetLimit(limit, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSetLimit);
	}
	return res;
}

CUresult cuCtxGetLimit(size_t * pvalue, CUlimit  limit)
{
	static CUresult (*lcuCtxGetLimit) (size_t *, CUlimit );
	if (!lcuCtxGetLimit) {
		lcuCtxGetLimit = (CUresult (*) (size_t *, CUlimit )) dlsym(RTLD_NEXT, "cuCtxGetLimit");
		tracer._kernel_map[(void *) lcuCtxGetLimit] = std::string("cuCtxGetLimit");
	}
	assert(lcuCtxGetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetLimit(pvalue, limit);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetLimit);
	}
	return res;
}

CUresult cuCtxGetCacheConfig(CUfunc_cache * pconfig)
{
	static CUresult (*lcuCtxGetCacheConfig) (CUfunc_cache *);
	if (!lcuCtxGetCacheConfig) {
		lcuCtxGetCacheConfig = (CUresult (*) (CUfunc_cache *)) dlsym(RTLD_NEXT, "cuCtxGetCacheConfig");
		tracer._kernel_map[(void *) lcuCtxGetCacheConfig] = std::string("cuCtxGetCacheConfig");
	}
	assert(lcuCtxGetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetCacheConfig(pconfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetCacheConfig);
	}
	return res;
}

CUresult cuCtxSetCacheConfig(CUfunc_cache  config)
{
	static CUresult (*lcuCtxSetCacheConfig) (CUfunc_cache );
	if (!lcuCtxSetCacheConfig) {
		lcuCtxSetCacheConfig = (CUresult (*) (CUfunc_cache )) dlsym(RTLD_NEXT, "cuCtxSetCacheConfig");
		tracer._kernel_map[(void *) lcuCtxSetCacheConfig] = std::string("cuCtxSetCacheConfig");
	}
	assert(lcuCtxSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSetCacheConfig(config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSetCacheConfig);
	}
	return res;
}

CUresult cuCtxGetSharedMemConfig(CUsharedconfig * pConfig)
{
	static CUresult (*lcuCtxGetSharedMemConfig) (CUsharedconfig *);
	if (!lcuCtxGetSharedMemConfig) {
		lcuCtxGetSharedMemConfig = (CUresult (*) (CUsharedconfig *)) dlsym(RTLD_NEXT, "cuCtxGetSharedMemConfig");
		tracer._kernel_map[(void *) lcuCtxGetSharedMemConfig] = std::string("cuCtxGetSharedMemConfig");
	}
	assert(lcuCtxGetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetSharedMemConfig(pConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetSharedMemConfig);
	}
	return res;
}

CUresult cuCtxSetSharedMemConfig(CUsharedconfig  config)
{
	static CUresult (*lcuCtxSetSharedMemConfig) (CUsharedconfig );
	if (!lcuCtxSetSharedMemConfig) {
		lcuCtxSetSharedMemConfig = (CUresult (*) (CUsharedconfig )) dlsym(RTLD_NEXT, "cuCtxSetSharedMemConfig");
		tracer._kernel_map[(void *) lcuCtxSetSharedMemConfig] = std::string("cuCtxSetSharedMemConfig");
	}
	assert(lcuCtxSetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxSetSharedMemConfig(config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxSetSharedMemConfig);
	}
	return res;
}

CUresult cuCtxGetApiVersion(CUcontext  ctx, unsigned int * version)
{
	static CUresult (*lcuCtxGetApiVersion) (CUcontext , unsigned int *);
	if (!lcuCtxGetApiVersion) {
		lcuCtxGetApiVersion = (CUresult (*) (CUcontext , unsigned int *)) dlsym(RTLD_NEXT, "cuCtxGetApiVersion");
		tracer._kernel_map[(void *) lcuCtxGetApiVersion] = std::string("cuCtxGetApiVersion");
	}
	assert(lcuCtxGetApiVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetApiVersion(ctx, version);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetApiVersion);
	}
	return res;
}

CUresult cuCtxGetStreamPriorityRange(int * leastPriority, int * greatestPriority)
{
	static CUresult (*lcuCtxGetStreamPriorityRange) (int *, int *);
	if (!lcuCtxGetStreamPriorityRange) {
		lcuCtxGetStreamPriorityRange = (CUresult (*) (int *, int *)) dlsym(RTLD_NEXT, "cuCtxGetStreamPriorityRange");
		tracer._kernel_map[(void *) lcuCtxGetStreamPriorityRange] = std::string("cuCtxGetStreamPriorityRange");
	}
	assert(lcuCtxGetStreamPriorityRange);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetStreamPriorityRange(leastPriority, greatestPriority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetStreamPriorityRange);
	}
	return res;
}

CUresult cuCtxResetPersistingL2Cache()
{
	static CUresult (*lcuCtxResetPersistingL2Cache) ();
	if (!lcuCtxResetPersistingL2Cache) {
		lcuCtxResetPersistingL2Cache = (CUresult (*) ()) dlsym(RTLD_NEXT, "cuCtxResetPersistingL2Cache");
		tracer._kernel_map[(void *) lcuCtxResetPersistingL2Cache] = std::string("cuCtxResetPersistingL2Cache");
	}
	assert(lcuCtxResetPersistingL2Cache);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxResetPersistingL2Cache();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxResetPersistingL2Cache);
	}
	return res;
}

CUresult cuCtxGetExecAffinity(CUexecAffinityParam * pExecAffinity, CUexecAffinityType  type)
{
	static CUresult (*lcuCtxGetExecAffinity) (CUexecAffinityParam *, CUexecAffinityType );
	if (!lcuCtxGetExecAffinity) {
		lcuCtxGetExecAffinity = (CUresult (*) (CUexecAffinityParam *, CUexecAffinityType )) dlsym(RTLD_NEXT, "cuCtxGetExecAffinity");
		tracer._kernel_map[(void *) lcuCtxGetExecAffinity] = std::string("cuCtxGetExecAffinity");
	}
	assert(lcuCtxGetExecAffinity);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxGetExecAffinity(pExecAffinity, type);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxGetExecAffinity);
	}
	return res;
}

CUresult cuCtxAttach(CUcontext * pctx, unsigned int  flags)
{
	static CUresult (*lcuCtxAttach) (CUcontext *, unsigned int );
	if (!lcuCtxAttach) {
		lcuCtxAttach = (CUresult (*) (CUcontext *, unsigned int )) dlsym(RTLD_NEXT, "cuCtxAttach");
		tracer._kernel_map[(void *) lcuCtxAttach] = std::string("cuCtxAttach");
	}
	assert(lcuCtxAttach);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxAttach(pctx, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxAttach);
	}
	return res;
}

CUresult cuCtxDetach(CUcontext  ctx)
{
	static CUresult (*lcuCtxDetach) (CUcontext );
	if (!lcuCtxDetach) {
		lcuCtxDetach = (CUresult (*) (CUcontext )) dlsym(RTLD_NEXT, "cuCtxDetach");
		tracer._kernel_map[(void *) lcuCtxDetach] = std::string("cuCtxDetach");
	}
	assert(lcuCtxDetach);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxDetach(ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxDetach);
	}
	return res;
}

CUresult cuModuleLoad(CUmodule * module, const char * fname)
{
	static CUresult (*lcuModuleLoad) (CUmodule *, const char *);
	if (!lcuModuleLoad) {
		lcuModuleLoad = (CUresult (*) (CUmodule *, const char *)) dlsym(RTLD_NEXT, "cuModuleLoad");
		tracer._kernel_map[(void *) lcuModuleLoad] = std::string("cuModuleLoad");
	}
	assert(lcuModuleLoad);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleLoad(module, fname);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleLoad);
	}
	return res;
}

CUresult cuModuleLoadData(CUmodule * module, const void * image)
{
	static CUresult (*lcuModuleLoadData) (CUmodule *, const void *);
	if (!lcuModuleLoadData) {
		lcuModuleLoadData = (CUresult (*) (CUmodule *, const void *)) dlsym(RTLD_NEXT, "cuModuleLoadData");
		tracer._kernel_map[(void *) lcuModuleLoadData] = std::string("cuModuleLoadData");
	}
	assert(lcuModuleLoadData);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleLoadData(module, image);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleLoadData);
	}
	return res;
}

CUresult cuModuleLoadDataEx(CUmodule * module, const void * image, unsigned int  numOptions, CUjit_option * options, void ** optionValues)
{
	static CUresult (*lcuModuleLoadDataEx) (CUmodule *, const void *, unsigned int , CUjit_option *, void **);
	if (!lcuModuleLoadDataEx) {
		lcuModuleLoadDataEx = (CUresult (*) (CUmodule *, const void *, unsigned int , CUjit_option *, void **)) dlsym(RTLD_NEXT, "cuModuleLoadDataEx");
		tracer._kernel_map[(void *) lcuModuleLoadDataEx] = std::string("cuModuleLoadDataEx");
	}
	assert(lcuModuleLoadDataEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleLoadDataEx(module, image, numOptions, options, optionValues);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleLoadDataEx);
	}
	return res;
}

CUresult cuModuleLoadFatBinary(CUmodule * module, const void * fatCubin)
{
	static CUresult (*lcuModuleLoadFatBinary) (CUmodule *, const void *);
	if (!lcuModuleLoadFatBinary) {
		lcuModuleLoadFatBinary = (CUresult (*) (CUmodule *, const void *)) dlsym(RTLD_NEXT, "cuModuleLoadFatBinary");
		tracer._kernel_map[(void *) lcuModuleLoadFatBinary] = std::string("cuModuleLoadFatBinary");
	}
	assert(lcuModuleLoadFatBinary);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleLoadFatBinary(module, fatCubin);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleLoadFatBinary);
	}
	return res;
}

CUresult cuModuleUnload(CUmodule  hmod)
{
	static CUresult (*lcuModuleUnload) (CUmodule );
	if (!lcuModuleUnload) {
		lcuModuleUnload = (CUresult (*) (CUmodule )) dlsym(RTLD_NEXT, "cuModuleUnload");
		tracer._kernel_map[(void *) lcuModuleUnload] = std::string("cuModuleUnload");
	}
	assert(lcuModuleUnload);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleUnload(hmod);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleUnload);
	}
	return res;
}

CUresult cuModuleGetLoadingMode(CUmoduleLoadingMode * mode)
{
	static CUresult (*lcuModuleGetLoadingMode) (CUmoduleLoadingMode *);
	if (!lcuModuleGetLoadingMode) {
		lcuModuleGetLoadingMode = (CUresult (*) (CUmoduleLoadingMode *)) dlsym(RTLD_NEXT, "cuModuleGetLoadingMode");
		tracer._kernel_map[(void *) lcuModuleGetLoadingMode] = std::string("cuModuleGetLoadingMode");
	}
	assert(lcuModuleGetLoadingMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleGetLoadingMode(mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleGetLoadingMode);
	}
	return res;
}

CUresult cuModuleGetFunction(CUfunction * hfunc, CUmodule  hmod, const char * name)
{
	static CUresult (*lcuModuleGetFunction) (CUfunction *, CUmodule , const char *);
	if (!lcuModuleGetFunction) {
		lcuModuleGetFunction = (CUresult (*) (CUfunction *, CUmodule , const char *)) dlsym(RTLD_NEXT, "cuModuleGetFunction");
		tracer._kernel_map[(void *) lcuModuleGetFunction] = std::string("cuModuleGetFunction");
	}
	assert(lcuModuleGetFunction);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleGetFunction(hfunc, hmod, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleGetFunction);
	}
	return res;
}

CUresult cuModuleGetGlobal_v2(CUdeviceptr * dptr, size_t * bytes, CUmodule  hmod, const char * name)
{
	static CUresult (*lcuModuleGetGlobal_v2) (CUdeviceptr *, size_t *, CUmodule , const char *);
	if (!lcuModuleGetGlobal_v2) {
		lcuModuleGetGlobal_v2 = (CUresult (*) (CUdeviceptr *, size_t *, CUmodule , const char *)) dlsym(RTLD_NEXT, "cuModuleGetGlobal_v2");
		tracer._kernel_map[(void *) lcuModuleGetGlobal_v2] = std::string("cuModuleGetGlobal_v2");
	}
	assert(lcuModuleGetGlobal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleGetGlobal_v2(dptr, bytes, hmod, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleGetGlobal_v2);
	}
	return res;
}

CUresult cuLinkCreate_v2(unsigned int  numOptions, CUjit_option * options, void ** optionValues, CUlinkState * stateOut)
{
	static CUresult (*lcuLinkCreate_v2) (unsigned int , CUjit_option *, void **, CUlinkState *);
	if (!lcuLinkCreate_v2) {
		lcuLinkCreate_v2 = (CUresult (*) (unsigned int , CUjit_option *, void **, CUlinkState *)) dlsym(RTLD_NEXT, "cuLinkCreate_v2");
		tracer._kernel_map[(void *) lcuLinkCreate_v2] = std::string("cuLinkCreate_v2");
	}
	assert(lcuLinkCreate_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLinkCreate_v2(numOptions, options, optionValues, stateOut);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLinkCreate_v2);
	}
	return res;
}

CUresult cuLinkAddData_v2(CUlinkState  state, CUjitInputType  type, void * data, size_t  size, const char * name, unsigned int  numOptions, CUjit_option * options, void ** optionValues)
{
	static CUresult (*lcuLinkAddData_v2) (CUlinkState , CUjitInputType , void *, size_t , const char *, unsigned int , CUjit_option *, void **);
	if (!lcuLinkAddData_v2) {
		lcuLinkAddData_v2 = (CUresult (*) (CUlinkState , CUjitInputType , void *, size_t , const char *, unsigned int , CUjit_option *, void **)) dlsym(RTLD_NEXT, "cuLinkAddData_v2");
		tracer._kernel_map[(void *) lcuLinkAddData_v2] = std::string("cuLinkAddData_v2");
	}
	assert(lcuLinkAddData_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLinkAddData_v2(state, type, data, size, name, numOptions, options, optionValues);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLinkAddData_v2);
	}
	return res;
}

CUresult cuLinkAddFile_v2(CUlinkState  state, CUjitInputType  type, const char * path, unsigned int  numOptions, CUjit_option * options, void ** optionValues)
{
	static CUresult (*lcuLinkAddFile_v2) (CUlinkState , CUjitInputType , const char *, unsigned int , CUjit_option *, void **);
	if (!lcuLinkAddFile_v2) {
		lcuLinkAddFile_v2 = (CUresult (*) (CUlinkState , CUjitInputType , const char *, unsigned int , CUjit_option *, void **)) dlsym(RTLD_NEXT, "cuLinkAddFile_v2");
		tracer._kernel_map[(void *) lcuLinkAddFile_v2] = std::string("cuLinkAddFile_v2");
	}
	assert(lcuLinkAddFile_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLinkAddFile_v2(state, type, path, numOptions, options, optionValues);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLinkAddFile_v2);
	}
	return res;
}

CUresult cuLinkComplete(CUlinkState  state, void ** cubinOut, size_t * sizeOut)
{
	static CUresult (*lcuLinkComplete) (CUlinkState , void **, size_t *);
	if (!lcuLinkComplete) {
		lcuLinkComplete = (CUresult (*) (CUlinkState , void **, size_t *)) dlsym(RTLD_NEXT, "cuLinkComplete");
		tracer._kernel_map[(void *) lcuLinkComplete] = std::string("cuLinkComplete");
	}
	assert(lcuLinkComplete);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLinkComplete(state, cubinOut, sizeOut);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLinkComplete);
	}
	return res;
}

CUresult cuLinkDestroy(CUlinkState  state)
{
	static CUresult (*lcuLinkDestroy) (CUlinkState );
	if (!lcuLinkDestroy) {
		lcuLinkDestroy = (CUresult (*) (CUlinkState )) dlsym(RTLD_NEXT, "cuLinkDestroy");
		tracer._kernel_map[(void *) lcuLinkDestroy] = std::string("cuLinkDestroy");
	}
	assert(lcuLinkDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLinkDestroy(state);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLinkDestroy);
	}
	return res;
}

CUresult cuModuleGetTexRef(CUtexref * pTexRef, CUmodule  hmod, const char * name)
{
	static CUresult (*lcuModuleGetTexRef) (CUtexref *, CUmodule , const char *);
	if (!lcuModuleGetTexRef) {
		lcuModuleGetTexRef = (CUresult (*) (CUtexref *, CUmodule , const char *)) dlsym(RTLD_NEXT, "cuModuleGetTexRef");
		tracer._kernel_map[(void *) lcuModuleGetTexRef] = std::string("cuModuleGetTexRef");
	}
	assert(lcuModuleGetTexRef);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleGetTexRef(pTexRef, hmod, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleGetTexRef);
	}
	return res;
}

CUresult cuModuleGetSurfRef(CUsurfref * pSurfRef, CUmodule  hmod, const char * name)
{
	static CUresult (*lcuModuleGetSurfRef) (CUsurfref *, CUmodule , const char *);
	if (!lcuModuleGetSurfRef) {
		lcuModuleGetSurfRef = (CUresult (*) (CUsurfref *, CUmodule , const char *)) dlsym(RTLD_NEXT, "cuModuleGetSurfRef");
		tracer._kernel_map[(void *) lcuModuleGetSurfRef] = std::string("cuModuleGetSurfRef");
	}
	assert(lcuModuleGetSurfRef);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuModuleGetSurfRef(pSurfRef, hmod, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuModuleGetSurfRef);
	}
	return res;
}

CUresult cuLibraryLoadData(CUlibrary * library, const void * code, CUjit_option * jitOptions, void ** jitOptionsValues, unsigned int  numJitOptions, CUlibraryOption * libraryOptions, void**  libraryOptionValues, unsigned int  numLibraryOptions)
{
	static CUresult (*lcuLibraryLoadData) (CUlibrary *, const void *, CUjit_option *, void **, unsigned int , CUlibraryOption *, void** , unsigned int );
	if (!lcuLibraryLoadData) {
		lcuLibraryLoadData = (CUresult (*) (CUlibrary *, const void *, CUjit_option *, void **, unsigned int , CUlibraryOption *, void** , unsigned int )) dlsym(RTLD_NEXT, "cuLibraryLoadData");
		tracer._kernel_map[(void *) lcuLibraryLoadData] = std::string("cuLibraryLoadData");
	}
	assert(lcuLibraryLoadData);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryLoadData(library, code, jitOptions, jitOptionsValues, numJitOptions, libraryOptions, libraryOptionValues, numLibraryOptions);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryLoadData);
	}
	return res;
}

CUresult cuLibraryLoadFromFile(CUlibrary * library, const char * fileName, CUjit_option * jitOptions, void ** jitOptionsValues, unsigned int  numJitOptions, CUlibraryOption * libraryOptions, void ** libraryOptionValues, unsigned int  numLibraryOptions)
{
	static CUresult (*lcuLibraryLoadFromFile) (CUlibrary *, const char *, CUjit_option *, void **, unsigned int , CUlibraryOption *, void **, unsigned int );
	if (!lcuLibraryLoadFromFile) {
		lcuLibraryLoadFromFile = (CUresult (*) (CUlibrary *, const char *, CUjit_option *, void **, unsigned int , CUlibraryOption *, void **, unsigned int )) dlsym(RTLD_NEXT, "cuLibraryLoadFromFile");
		tracer._kernel_map[(void *) lcuLibraryLoadFromFile] = std::string("cuLibraryLoadFromFile");
	}
	assert(lcuLibraryLoadFromFile);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryLoadFromFile(library, fileName, jitOptions, jitOptionsValues, numJitOptions, libraryOptions, libraryOptionValues, numLibraryOptions);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryLoadFromFile);
	}
	return res;
}

CUresult cuLibraryUnload(CUlibrary  library)
{
	static CUresult (*lcuLibraryUnload) (CUlibrary );
	if (!lcuLibraryUnload) {
		lcuLibraryUnload = (CUresult (*) (CUlibrary )) dlsym(RTLD_NEXT, "cuLibraryUnload");
		tracer._kernel_map[(void *) lcuLibraryUnload] = std::string("cuLibraryUnload");
	}
	assert(lcuLibraryUnload);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryUnload(library);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryUnload);
	}
	return res;
}

CUresult cuLibraryGetKernel(CUkernel * pKernel, CUlibrary  library, const char * name)
{
	static CUresult (*lcuLibraryGetKernel) (CUkernel *, CUlibrary , const char *);
	if (!lcuLibraryGetKernel) {
		lcuLibraryGetKernel = (CUresult (*) (CUkernel *, CUlibrary , const char *)) dlsym(RTLD_NEXT, "cuLibraryGetKernel");
		tracer._kernel_map[(void *) lcuLibraryGetKernel] = std::string("cuLibraryGetKernel");
	}
	assert(lcuLibraryGetKernel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryGetKernel(pKernel, library, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryGetKernel);
	}
	return res;
}

CUresult cuLibraryGetModule(CUmodule * pMod, CUlibrary  library)
{
	static CUresult (*lcuLibraryGetModule) (CUmodule *, CUlibrary );
	if (!lcuLibraryGetModule) {
		lcuLibraryGetModule = (CUresult (*) (CUmodule *, CUlibrary )) dlsym(RTLD_NEXT, "cuLibraryGetModule");
		tracer._kernel_map[(void *) lcuLibraryGetModule] = std::string("cuLibraryGetModule");
	}
	assert(lcuLibraryGetModule);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryGetModule(pMod, library);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryGetModule);
	}
	return res;
}

CUresult cuKernelGetFunction(CUfunction * pFunc, CUkernel  kernel)
{
	static CUresult (*lcuKernelGetFunction) (CUfunction *, CUkernel );
	if (!lcuKernelGetFunction) {
		lcuKernelGetFunction = (CUresult (*) (CUfunction *, CUkernel )) dlsym(RTLD_NEXT, "cuKernelGetFunction");
		tracer._kernel_map[(void *) lcuKernelGetFunction] = std::string("cuKernelGetFunction");
	}
	assert(lcuKernelGetFunction);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuKernelGetFunction(pFunc, kernel);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuKernelGetFunction);
	}
	return res;
}

CUresult cuLibraryGetGlobal(CUdeviceptr * dptr, size_t * bytes, CUlibrary  library, const char * name)
{
	static CUresult (*lcuLibraryGetGlobal) (CUdeviceptr *, size_t *, CUlibrary , const char *);
	if (!lcuLibraryGetGlobal) {
		lcuLibraryGetGlobal = (CUresult (*) (CUdeviceptr *, size_t *, CUlibrary , const char *)) dlsym(RTLD_NEXT, "cuLibraryGetGlobal");
		tracer._kernel_map[(void *) lcuLibraryGetGlobal] = std::string("cuLibraryGetGlobal");
	}
	assert(lcuLibraryGetGlobal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryGetGlobal(dptr, bytes, library, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryGetGlobal);
	}
	return res;
}

CUresult cuLibraryGetManaged(CUdeviceptr * dptr, size_t * bytes, CUlibrary  library, const char * name)
{
	static CUresult (*lcuLibraryGetManaged) (CUdeviceptr *, size_t *, CUlibrary , const char *);
	if (!lcuLibraryGetManaged) {
		lcuLibraryGetManaged = (CUresult (*) (CUdeviceptr *, size_t *, CUlibrary , const char *)) dlsym(RTLD_NEXT, "cuLibraryGetManaged");
		tracer._kernel_map[(void *) lcuLibraryGetManaged] = std::string("cuLibraryGetManaged");
	}
	assert(lcuLibraryGetManaged);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryGetManaged(dptr, bytes, library, name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryGetManaged);
	}
	return res;
}

CUresult cuLibraryGetUnifiedFunction(void ** fptr, CUlibrary  library, const char * symbol)
{
	static CUresult (*lcuLibraryGetUnifiedFunction) (void **, CUlibrary , const char *);
	if (!lcuLibraryGetUnifiedFunction) {
		lcuLibraryGetUnifiedFunction = (CUresult (*) (void **, CUlibrary , const char *)) dlsym(RTLD_NEXT, "cuLibraryGetUnifiedFunction");
		tracer._kernel_map[(void *) lcuLibraryGetUnifiedFunction] = std::string("cuLibraryGetUnifiedFunction");
	}
	assert(lcuLibraryGetUnifiedFunction);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLibraryGetUnifiedFunction(fptr, library, symbol);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLibraryGetUnifiedFunction);
	}
	return res;
}

CUresult cuKernelGetAttribute(int * pi, CUfunction_attribute  attrib, CUkernel  kernel, CUdevice  dev)
{
	static CUresult (*lcuKernelGetAttribute) (int *, CUfunction_attribute , CUkernel , CUdevice );
	if (!lcuKernelGetAttribute) {
		lcuKernelGetAttribute = (CUresult (*) (int *, CUfunction_attribute , CUkernel , CUdevice )) dlsym(RTLD_NEXT, "cuKernelGetAttribute");
		tracer._kernel_map[(void *) lcuKernelGetAttribute] = std::string("cuKernelGetAttribute");
	}
	assert(lcuKernelGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuKernelGetAttribute(pi, attrib, kernel, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuKernelGetAttribute);
	}
	return res;
}

CUresult cuKernelSetAttribute(CUfunction_attribute  attrib, int  val, CUkernel  kernel, CUdevice  dev)
{
	static CUresult (*lcuKernelSetAttribute) (CUfunction_attribute , int , CUkernel , CUdevice );
	if (!lcuKernelSetAttribute) {
		lcuKernelSetAttribute = (CUresult (*) (CUfunction_attribute , int , CUkernel , CUdevice )) dlsym(RTLD_NEXT, "cuKernelSetAttribute");
		tracer._kernel_map[(void *) lcuKernelSetAttribute] = std::string("cuKernelSetAttribute");
	}
	assert(lcuKernelSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuKernelSetAttribute(attrib, val, kernel, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuKernelSetAttribute);
	}
	return res;
}

CUresult cuKernelSetCacheConfig(CUkernel  kernel, CUfunc_cache  config, CUdevice  dev)
{
	static CUresult (*lcuKernelSetCacheConfig) (CUkernel , CUfunc_cache , CUdevice );
	if (!lcuKernelSetCacheConfig) {
		lcuKernelSetCacheConfig = (CUresult (*) (CUkernel , CUfunc_cache , CUdevice )) dlsym(RTLD_NEXT, "cuKernelSetCacheConfig");
		tracer._kernel_map[(void *) lcuKernelSetCacheConfig] = std::string("cuKernelSetCacheConfig");
	}
	assert(lcuKernelSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuKernelSetCacheConfig(kernel, config, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuKernelSetCacheConfig);
	}
	return res;
}

CUresult cuMemGetInfo_v2(size_t * free, size_t * total)
{
	static CUresult (*lcuMemGetInfo_v2) (size_t *, size_t *);
	if (!lcuMemGetInfo_v2) {
		lcuMemGetInfo_v2 = (CUresult (*) (size_t *, size_t *)) dlsym(RTLD_NEXT, "cuMemGetInfo_v2");
		tracer._kernel_map[(void *) lcuMemGetInfo_v2] = std::string("cuMemGetInfo_v2");
	}
	assert(lcuMemGetInfo_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetInfo_v2(free, total);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetInfo_v2);
	}
	return res;
}

CUresult cuMemAlloc_v2(CUdeviceptr * dptr, size_t  bytesize)
{
	static CUresult (*lcuMemAlloc_v2) (CUdeviceptr *, size_t );
	if (!lcuMemAlloc_v2) {
		lcuMemAlloc_v2 = (CUresult (*) (CUdeviceptr *, size_t )) dlsym(RTLD_NEXT, "cuMemAlloc_v2");
		tracer._kernel_map[(void *) lcuMemAlloc_v2] = std::string("cuMemAlloc_v2");
	}
	assert(lcuMemAlloc_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAlloc_v2(dptr, bytesize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAlloc_v2);
	}
	return res;
}

CUresult cuMemAllocPitch_v2(CUdeviceptr * dptr, size_t * pPitch, size_t  WidthInBytes, size_t  Height, unsigned int  ElementSizeBytes)
{
	static CUresult (*lcuMemAllocPitch_v2) (CUdeviceptr *, size_t *, size_t , size_t , unsigned int );
	if (!lcuMemAllocPitch_v2) {
		lcuMemAllocPitch_v2 = (CUresult (*) (CUdeviceptr *, size_t *, size_t , size_t , unsigned int )) dlsym(RTLD_NEXT, "cuMemAllocPitch_v2");
		tracer._kernel_map[(void *) lcuMemAllocPitch_v2] = std::string("cuMemAllocPitch_v2");
	}
	assert(lcuMemAllocPitch_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAllocPitch_v2(dptr, pPitch, WidthInBytes, Height, ElementSizeBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAllocPitch_v2);
	}
	return res;
}

CUresult cuMemFree_v2(CUdeviceptr  dptr)
{
	static CUresult (*lcuMemFree_v2) (CUdeviceptr );
	if (!lcuMemFree_v2) {
		lcuMemFree_v2 = (CUresult (*) (CUdeviceptr )) dlsym(RTLD_NEXT, "cuMemFree_v2");
		tracer._kernel_map[(void *) lcuMemFree_v2] = std::string("cuMemFree_v2");
	}
	assert(lcuMemFree_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemFree_v2(dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemFree_v2);
	}
	return res;
}

CUresult cuMemGetAddressRange_v2(CUdeviceptr * pbase, size_t * psize, CUdeviceptr  dptr)
{
	static CUresult (*lcuMemGetAddressRange_v2) (CUdeviceptr *, size_t *, CUdeviceptr );
	if (!lcuMemGetAddressRange_v2) {
		lcuMemGetAddressRange_v2 = (CUresult (*) (CUdeviceptr *, size_t *, CUdeviceptr )) dlsym(RTLD_NEXT, "cuMemGetAddressRange_v2");
		tracer._kernel_map[(void *) lcuMemGetAddressRange_v2] = std::string("cuMemGetAddressRange_v2");
	}
	assert(lcuMemGetAddressRange_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetAddressRange_v2(pbase, psize, dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetAddressRange_v2);
	}
	return res;
}

CUresult cuMemAllocHost_v2(void ** pp, size_t  bytesize)
{
	static CUresult (*lcuMemAllocHost_v2) (void **, size_t );
	if (!lcuMemAllocHost_v2) {
		lcuMemAllocHost_v2 = (CUresult (*) (void **, size_t )) dlsym(RTLD_NEXT, "cuMemAllocHost_v2");
		tracer._kernel_map[(void *) lcuMemAllocHost_v2] = std::string("cuMemAllocHost_v2");
	}
	assert(lcuMemAllocHost_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAllocHost_v2(pp, bytesize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAllocHost_v2);
	}
	return res;
}

CUresult cuMemFreeHost(void * p)
{
	static CUresult (*lcuMemFreeHost) (void *);
	if (!lcuMemFreeHost) {
		lcuMemFreeHost = (CUresult (*) (void *)) dlsym(RTLD_NEXT, "cuMemFreeHost");
		tracer._kernel_map[(void *) lcuMemFreeHost] = std::string("cuMemFreeHost");
	}
	assert(lcuMemFreeHost);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemFreeHost(p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemFreeHost);
	}
	return res;
}

CUresult cuMemHostAlloc(void ** pp, size_t  bytesize, unsigned int  Flags)
{
	static CUresult (*lcuMemHostAlloc) (void **, size_t , unsigned int );
	if (!lcuMemHostAlloc) {
		lcuMemHostAlloc = (CUresult (*) (void **, size_t , unsigned int )) dlsym(RTLD_NEXT, "cuMemHostAlloc");
		tracer._kernel_map[(void *) lcuMemHostAlloc] = std::string("cuMemHostAlloc");
	}
	assert(lcuMemHostAlloc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemHostAlloc(pp, bytesize, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemHostAlloc);
	}
	return res;
}

CUresult cuMemHostGetDevicePointer_v2(CUdeviceptr * pdptr, void * p, unsigned int  Flags)
{
	static CUresult (*lcuMemHostGetDevicePointer_v2) (CUdeviceptr *, void *, unsigned int );
	if (!lcuMemHostGetDevicePointer_v2) {
		lcuMemHostGetDevicePointer_v2 = (CUresult (*) (CUdeviceptr *, void *, unsigned int )) dlsym(RTLD_NEXT, "cuMemHostGetDevicePointer_v2");
		tracer._kernel_map[(void *) lcuMemHostGetDevicePointer_v2] = std::string("cuMemHostGetDevicePointer_v2");
	}
	assert(lcuMemHostGetDevicePointer_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemHostGetDevicePointer_v2(pdptr, p, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemHostGetDevicePointer_v2);
	}
	return res;
}

CUresult cuMemHostGetFlags(unsigned int * pFlags, void * p)
{
	static CUresult (*lcuMemHostGetFlags) (unsigned int *, void *);
	if (!lcuMemHostGetFlags) {
		lcuMemHostGetFlags = (CUresult (*) (unsigned int *, void *)) dlsym(RTLD_NEXT, "cuMemHostGetFlags");
		tracer._kernel_map[(void *) lcuMemHostGetFlags] = std::string("cuMemHostGetFlags");
	}
	assert(lcuMemHostGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemHostGetFlags(pFlags, p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemHostGetFlags);
	}
	return res;
}

CUresult cuMemAllocManaged(CUdeviceptr * dptr, size_t  bytesize, unsigned int  flags)
{
	static CUresult (*lcuMemAllocManaged) (CUdeviceptr *, size_t , unsigned int );
	if (!lcuMemAllocManaged) {
		lcuMemAllocManaged = (CUresult (*) (CUdeviceptr *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cuMemAllocManaged");
		tracer._kernel_map[(void *) lcuMemAllocManaged] = std::string("cuMemAllocManaged");
	}
	assert(lcuMemAllocManaged);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAllocManaged(dptr, bytesize, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAllocManaged);
	}
	return res;
}

CUresult cuDeviceGetByPCIBusId(CUdevice * dev, const char * pciBusId)
{
	static CUresult (*lcuDeviceGetByPCIBusId) (CUdevice *, const char *);
	if (!lcuDeviceGetByPCIBusId) {
		lcuDeviceGetByPCIBusId = (CUresult (*) (CUdevice *, const char *)) dlsym(RTLD_NEXT, "cuDeviceGetByPCIBusId");
		tracer._kernel_map[(void *) lcuDeviceGetByPCIBusId] = std::string("cuDeviceGetByPCIBusId");
	}
	assert(lcuDeviceGetByPCIBusId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetByPCIBusId(dev, pciBusId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetByPCIBusId);
	}
	return res;
}

CUresult cuDeviceGetPCIBusId(char * pciBusId, int  len, CUdevice  dev)
{
	static CUresult (*lcuDeviceGetPCIBusId) (char *, int , CUdevice );
	if (!lcuDeviceGetPCIBusId) {
		lcuDeviceGetPCIBusId = (CUresult (*) (char *, int , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetPCIBusId");
		tracer._kernel_map[(void *) lcuDeviceGetPCIBusId] = std::string("cuDeviceGetPCIBusId");
	}
	assert(lcuDeviceGetPCIBusId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetPCIBusId(pciBusId, len, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetPCIBusId);
	}
	return res;
}

CUresult cuIpcGetEventHandle(CUipcEventHandle * pHandle, CUevent  event)
{
	static CUresult (*lcuIpcGetEventHandle) (CUipcEventHandle *, CUevent );
	if (!lcuIpcGetEventHandle) {
		lcuIpcGetEventHandle = (CUresult (*) (CUipcEventHandle *, CUevent )) dlsym(RTLD_NEXT, "cuIpcGetEventHandle");
		tracer._kernel_map[(void *) lcuIpcGetEventHandle] = std::string("cuIpcGetEventHandle");
	}
	assert(lcuIpcGetEventHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuIpcGetEventHandle(pHandle, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuIpcGetEventHandle);
	}
	return res;
}

CUresult cuIpcOpenEventHandle(CUevent * phEvent, CUipcEventHandle  handle)
{
	static CUresult (*lcuIpcOpenEventHandle) (CUevent *, CUipcEventHandle );
	if (!lcuIpcOpenEventHandle) {
		lcuIpcOpenEventHandle = (CUresult (*) (CUevent *, CUipcEventHandle )) dlsym(RTLD_NEXT, "cuIpcOpenEventHandle");
		tracer._kernel_map[(void *) lcuIpcOpenEventHandle] = std::string("cuIpcOpenEventHandle");
	}
	assert(lcuIpcOpenEventHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuIpcOpenEventHandle(phEvent, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuIpcOpenEventHandle);
	}
	return res;
}

CUresult cuIpcGetMemHandle(CUipcMemHandle * pHandle, CUdeviceptr  dptr)
{
	static CUresult (*lcuIpcGetMemHandle) (CUipcMemHandle *, CUdeviceptr );
	if (!lcuIpcGetMemHandle) {
		lcuIpcGetMemHandle = (CUresult (*) (CUipcMemHandle *, CUdeviceptr )) dlsym(RTLD_NEXT, "cuIpcGetMemHandle");
		tracer._kernel_map[(void *) lcuIpcGetMemHandle] = std::string("cuIpcGetMemHandle");
	}
	assert(lcuIpcGetMemHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuIpcGetMemHandle(pHandle, dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuIpcGetMemHandle);
	}
	return res;
}

CUresult cuIpcOpenMemHandle_v2(CUdeviceptr * pdptr, CUipcMemHandle  handle, unsigned int  Flags)
{
	static CUresult (*lcuIpcOpenMemHandle_v2) (CUdeviceptr *, CUipcMemHandle , unsigned int );
	if (!lcuIpcOpenMemHandle_v2) {
		lcuIpcOpenMemHandle_v2 = (CUresult (*) (CUdeviceptr *, CUipcMemHandle , unsigned int )) dlsym(RTLD_NEXT, "cuIpcOpenMemHandle_v2");
		tracer._kernel_map[(void *) lcuIpcOpenMemHandle_v2] = std::string("cuIpcOpenMemHandle_v2");
	}
	assert(lcuIpcOpenMemHandle_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuIpcOpenMemHandle_v2(pdptr, handle, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuIpcOpenMemHandle_v2);
	}
	return res;
}

CUresult cuIpcCloseMemHandle(CUdeviceptr  dptr)
{
	static CUresult (*lcuIpcCloseMemHandle) (CUdeviceptr );
	if (!lcuIpcCloseMemHandle) {
		lcuIpcCloseMemHandle = (CUresult (*) (CUdeviceptr )) dlsym(RTLD_NEXT, "cuIpcCloseMemHandle");
		tracer._kernel_map[(void *) lcuIpcCloseMemHandle] = std::string("cuIpcCloseMemHandle");
	}
	assert(lcuIpcCloseMemHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuIpcCloseMemHandle(dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuIpcCloseMemHandle);
	}
	return res;
}

CUresult cuMemHostRegister_v2(void * p, size_t  bytesize, unsigned int  Flags)
{
	static CUresult (*lcuMemHostRegister_v2) (void *, size_t , unsigned int );
	if (!lcuMemHostRegister_v2) {
		lcuMemHostRegister_v2 = (CUresult (*) (void *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cuMemHostRegister_v2");
		tracer._kernel_map[(void *) lcuMemHostRegister_v2] = std::string("cuMemHostRegister_v2");
	}
	assert(lcuMemHostRegister_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemHostRegister_v2(p, bytesize, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemHostRegister_v2);
	}
	return res;
}

CUresult cuMemHostUnregister(void * p)
{
	static CUresult (*lcuMemHostUnregister) (void *);
	if (!lcuMemHostUnregister) {
		lcuMemHostUnregister = (CUresult (*) (void *)) dlsym(RTLD_NEXT, "cuMemHostUnregister");
		tracer._kernel_map[(void *) lcuMemHostUnregister] = std::string("cuMemHostUnregister");
	}
	assert(lcuMemHostUnregister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemHostUnregister(p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemHostUnregister);
	}
	return res;
}

CUresult cuMemcpy(CUdeviceptr  dst, CUdeviceptr  src, size_t  ByteCount)
{
	static CUresult (*lcuMemcpy) (CUdeviceptr , CUdeviceptr , size_t );
	if (!lcuMemcpy) {
		lcuMemcpy = (CUresult (*) (CUdeviceptr , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemcpy");
		tracer._kernel_map[(void *) lcuMemcpy] = std::string("cuMemcpy");
	}
	assert(lcuMemcpy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy(dst, src, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy);
	}
	return res;
}

CUresult cuMemcpyPeer(CUdeviceptr  dstDevice, CUcontext  dstContext, CUdeviceptr  srcDevice, CUcontext  srcContext, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyPeer) (CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t );
	if (!lcuMemcpyPeer) {
		lcuMemcpyPeer = (CUresult (*) (CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t )) dlsym(RTLD_NEXT, "cuMemcpyPeer");
		tracer._kernel_map[(void *) lcuMemcpyPeer] = std::string("cuMemcpyPeer");
	}
	assert(lcuMemcpyPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyPeer(dstDevice, dstContext, srcDevice, srcContext, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyPeer);
	}
	return res;
}

CUresult cuMemcpyHtoD_v2(CUdeviceptr  dstDevice, const void * srcHost, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyHtoD_v2) (CUdeviceptr , const void *, size_t );
	if (!lcuMemcpyHtoD_v2) {
		lcuMemcpyHtoD_v2 = (CUresult (*) (CUdeviceptr , const void *, size_t )) dlsym(RTLD_NEXT, "cuMemcpyHtoD_v2");
		tracer._kernel_map[(void *) lcuMemcpyHtoD_v2] = std::string("cuMemcpyHtoD_v2");
	}
	assert(lcuMemcpyHtoD_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyHtoD_v2(dstDevice, srcHost, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyHtoD_v2);
	}
	return res;
}

CUresult cuMemcpyDtoH_v2(void * dstHost, CUdeviceptr  srcDevice, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyDtoH_v2) (void *, CUdeviceptr , size_t );
	if (!lcuMemcpyDtoH_v2) {
		lcuMemcpyDtoH_v2 = (CUresult (*) (void *, CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemcpyDtoH_v2");
		tracer._kernel_map[(void *) lcuMemcpyDtoH_v2] = std::string("cuMemcpyDtoH_v2");
	}
	assert(lcuMemcpyDtoH_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyDtoH_v2(dstHost, srcDevice, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyDtoH_v2);
	}
	return res;
}

CUresult cuMemcpyDtoD_v2(CUdeviceptr  dstDevice, CUdeviceptr  srcDevice, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyDtoD_v2) (CUdeviceptr , CUdeviceptr , size_t );
	if (!lcuMemcpyDtoD_v2) {
		lcuMemcpyDtoD_v2 = (CUresult (*) (CUdeviceptr , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemcpyDtoD_v2");
		tracer._kernel_map[(void *) lcuMemcpyDtoD_v2] = std::string("cuMemcpyDtoD_v2");
	}
	assert(lcuMemcpyDtoD_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyDtoD_v2(dstDevice, srcDevice, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyDtoD_v2);
	}
	return res;
}

CUresult cuMemcpyDtoA_v2(CUarray  dstArray, size_t  dstOffset, CUdeviceptr  srcDevice, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyDtoA_v2) (CUarray , size_t , CUdeviceptr , size_t );
	if (!lcuMemcpyDtoA_v2) {
		lcuMemcpyDtoA_v2 = (CUresult (*) (CUarray , size_t , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemcpyDtoA_v2");
		tracer._kernel_map[(void *) lcuMemcpyDtoA_v2] = std::string("cuMemcpyDtoA_v2");
	}
	assert(lcuMemcpyDtoA_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyDtoA_v2(dstArray, dstOffset, srcDevice, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyDtoA_v2);
	}
	return res;
}

CUresult cuMemcpyAtoD_v2(CUdeviceptr  dstDevice, CUarray  srcArray, size_t  srcOffset, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyAtoD_v2) (CUdeviceptr , CUarray , size_t , size_t );
	if (!lcuMemcpyAtoD_v2) {
		lcuMemcpyAtoD_v2 = (CUresult (*) (CUdeviceptr , CUarray , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemcpyAtoD_v2");
		tracer._kernel_map[(void *) lcuMemcpyAtoD_v2] = std::string("cuMemcpyAtoD_v2");
	}
	assert(lcuMemcpyAtoD_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyAtoD_v2(dstDevice, srcArray, srcOffset, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyAtoD_v2);
	}
	return res;
}

CUresult cuMemcpyHtoA_v2(CUarray  dstArray, size_t  dstOffset, const void * srcHost, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyHtoA_v2) (CUarray , size_t , const void *, size_t );
	if (!lcuMemcpyHtoA_v2) {
		lcuMemcpyHtoA_v2 = (CUresult (*) (CUarray , size_t , const void *, size_t )) dlsym(RTLD_NEXT, "cuMemcpyHtoA_v2");
		tracer._kernel_map[(void *) lcuMemcpyHtoA_v2] = std::string("cuMemcpyHtoA_v2");
	}
	assert(lcuMemcpyHtoA_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyHtoA_v2(dstArray, dstOffset, srcHost, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyHtoA_v2);
	}
	return res;
}

CUresult cuMemcpyAtoH_v2(void * dstHost, CUarray  srcArray, size_t  srcOffset, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyAtoH_v2) (void *, CUarray , size_t , size_t );
	if (!lcuMemcpyAtoH_v2) {
		lcuMemcpyAtoH_v2 = (CUresult (*) (void *, CUarray , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemcpyAtoH_v2");
		tracer._kernel_map[(void *) lcuMemcpyAtoH_v2] = std::string("cuMemcpyAtoH_v2");
	}
	assert(lcuMemcpyAtoH_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyAtoH_v2(dstHost, srcArray, srcOffset, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyAtoH_v2);
	}
	return res;
}

CUresult cuMemcpyAtoA_v2(CUarray  dstArray, size_t  dstOffset, CUarray  srcArray, size_t  srcOffset, size_t  ByteCount)
{
	static CUresult (*lcuMemcpyAtoA_v2) (CUarray , size_t , CUarray , size_t , size_t );
	if (!lcuMemcpyAtoA_v2) {
		lcuMemcpyAtoA_v2 = (CUresult (*) (CUarray , size_t , CUarray , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemcpyAtoA_v2");
		tracer._kernel_map[(void *) lcuMemcpyAtoA_v2] = std::string("cuMemcpyAtoA_v2");
	}
	assert(lcuMemcpyAtoA_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyAtoA_v2(dstArray, dstOffset, srcArray, srcOffset, ByteCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyAtoA_v2);
	}
	return res;
}

CUresult cuMemcpy2D_v2(const CUDA_MEMCPY2D * pCopy)
{
	static CUresult (*lcuMemcpy2D_v2) (const CUDA_MEMCPY2D *);
	if (!lcuMemcpy2D_v2) {
		lcuMemcpy2D_v2 = (CUresult (*) (const CUDA_MEMCPY2D *)) dlsym(RTLD_NEXT, "cuMemcpy2D_v2");
		tracer._kernel_map[(void *) lcuMemcpy2D_v2] = std::string("cuMemcpy2D_v2");
	}
	assert(lcuMemcpy2D_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy2D_v2(pCopy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy2D_v2);
	}
	return res;
}

CUresult cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D * pCopy)
{
	static CUresult (*lcuMemcpy2DUnaligned_v2) (const CUDA_MEMCPY2D *);
	if (!lcuMemcpy2DUnaligned_v2) {
		lcuMemcpy2DUnaligned_v2 = (CUresult (*) (const CUDA_MEMCPY2D *)) dlsym(RTLD_NEXT, "cuMemcpy2DUnaligned_v2");
		tracer._kernel_map[(void *) lcuMemcpy2DUnaligned_v2] = std::string("cuMemcpy2DUnaligned_v2");
	}
	assert(lcuMemcpy2DUnaligned_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy2DUnaligned_v2(pCopy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy2DUnaligned_v2);
	}
	return res;
}

CUresult cuMemcpy3D_v2(const CUDA_MEMCPY3D * pCopy)
{
	static CUresult (*lcuMemcpy3D_v2) (const CUDA_MEMCPY3D *);
	if (!lcuMemcpy3D_v2) {
		lcuMemcpy3D_v2 = (CUresult (*) (const CUDA_MEMCPY3D *)) dlsym(RTLD_NEXT, "cuMemcpy3D_v2");
		tracer._kernel_map[(void *) lcuMemcpy3D_v2] = std::string("cuMemcpy3D_v2");
	}
	assert(lcuMemcpy3D_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy3D_v2(pCopy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy3D_v2);
	}
	return res;
}

CUresult cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER * pCopy)
{
	static CUresult (*lcuMemcpy3DPeer) (const CUDA_MEMCPY3D_PEER *);
	if (!lcuMemcpy3DPeer) {
		lcuMemcpy3DPeer = (CUresult (*) (const CUDA_MEMCPY3D_PEER *)) dlsym(RTLD_NEXT, "cuMemcpy3DPeer");
		tracer._kernel_map[(void *) lcuMemcpy3DPeer] = std::string("cuMemcpy3DPeer");
	}
	assert(lcuMemcpy3DPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy3DPeer(pCopy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy3DPeer);
	}
	return res;
}

CUresult cuMemcpyAsync(CUdeviceptr  dst, CUdeviceptr  src, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyAsync) (CUdeviceptr , CUdeviceptr , size_t , CUstream );
	if (!lcuMemcpyAsync) {
		lcuMemcpyAsync = (CUresult (*) (CUdeviceptr , CUdeviceptr , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyAsync");
		tracer._kernel_map[(void *) lcuMemcpyAsync] = std::string("cuMemcpyAsync");
	}
	assert(lcuMemcpyAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyAsync(dst, src, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyAsync);
	}
	return res;
}

CUresult cuMemcpyPeerAsync(CUdeviceptr  dstDevice, CUcontext  dstContext, CUdeviceptr  srcDevice, CUcontext  srcContext, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyPeerAsync) (CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t , CUstream );
	if (!lcuMemcpyPeerAsync) {
		lcuMemcpyPeerAsync = (CUresult (*) (CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyPeerAsync");
		tracer._kernel_map[(void *) lcuMemcpyPeerAsync] = std::string("cuMemcpyPeerAsync");
	}
	assert(lcuMemcpyPeerAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyPeerAsync(dstDevice, dstContext, srcDevice, srcContext, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyPeerAsync);
	}
	return res;
}

CUresult cuMemcpyHtoDAsync_v2(CUdeviceptr  dstDevice, const void * srcHost, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyHtoDAsync_v2) (CUdeviceptr , const void *, size_t , CUstream );
	if (!lcuMemcpyHtoDAsync_v2) {
		lcuMemcpyHtoDAsync_v2 = (CUresult (*) (CUdeviceptr , const void *, size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyHtoDAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpyHtoDAsync_v2] = std::string("cuMemcpyHtoDAsync_v2");
	}
	assert(lcuMemcpyHtoDAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyHtoDAsync_v2(dstDevice, srcHost, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyHtoDAsync_v2);
	}
	return res;
}

CUresult cuMemcpyDtoHAsync_v2(void * dstHost, CUdeviceptr  srcDevice, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyDtoHAsync_v2) (void *, CUdeviceptr , size_t , CUstream );
	if (!lcuMemcpyDtoHAsync_v2) {
		lcuMemcpyDtoHAsync_v2 = (CUresult (*) (void *, CUdeviceptr , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyDtoHAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpyDtoHAsync_v2] = std::string("cuMemcpyDtoHAsync_v2");
	}
	assert(lcuMemcpyDtoHAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyDtoHAsync_v2(dstHost, srcDevice, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyDtoHAsync_v2);
	}
	return res;
}

CUresult cuMemcpyDtoDAsync_v2(CUdeviceptr  dstDevice, CUdeviceptr  srcDevice, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyDtoDAsync_v2) (CUdeviceptr , CUdeviceptr , size_t , CUstream );
	if (!lcuMemcpyDtoDAsync_v2) {
		lcuMemcpyDtoDAsync_v2 = (CUresult (*) (CUdeviceptr , CUdeviceptr , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyDtoDAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpyDtoDAsync_v2] = std::string("cuMemcpyDtoDAsync_v2");
	}
	assert(lcuMemcpyDtoDAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyDtoDAsync_v2(dstDevice, srcDevice, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyDtoDAsync_v2);
	}
	return res;
}

CUresult cuMemcpyHtoAAsync_v2(CUarray  dstArray, size_t  dstOffset, const void * srcHost, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyHtoAAsync_v2) (CUarray , size_t , const void *, size_t , CUstream );
	if (!lcuMemcpyHtoAAsync_v2) {
		lcuMemcpyHtoAAsync_v2 = (CUresult (*) (CUarray , size_t , const void *, size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyHtoAAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpyHtoAAsync_v2] = std::string("cuMemcpyHtoAAsync_v2");
	}
	assert(lcuMemcpyHtoAAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyHtoAAsync_v2(dstArray, dstOffset, srcHost, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyHtoAAsync_v2);
	}
	return res;
}

CUresult cuMemcpyAtoHAsync_v2(void * dstHost, CUarray  srcArray, size_t  srcOffset, size_t  ByteCount, CUstream  hStream)
{
	static CUresult (*lcuMemcpyAtoHAsync_v2) (void *, CUarray , size_t , size_t , CUstream );
	if (!lcuMemcpyAtoHAsync_v2) {
		lcuMemcpyAtoHAsync_v2 = (CUresult (*) (void *, CUarray , size_t , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemcpyAtoHAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpyAtoHAsync_v2] = std::string("cuMemcpyAtoHAsync_v2");
	}
	assert(lcuMemcpyAtoHAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpyAtoHAsync_v2(dstHost, srcArray, srcOffset, ByteCount, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpyAtoHAsync_v2);
	}
	return res;
}

CUresult cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D * pCopy, CUstream  hStream)
{
	static CUresult (*lcuMemcpy2DAsync_v2) (const CUDA_MEMCPY2D *, CUstream );
	if (!lcuMemcpy2DAsync_v2) {
		lcuMemcpy2DAsync_v2 = (CUresult (*) (const CUDA_MEMCPY2D *, CUstream )) dlsym(RTLD_NEXT, "cuMemcpy2DAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpy2DAsync_v2] = std::string("cuMemcpy2DAsync_v2");
	}
	assert(lcuMemcpy2DAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy2DAsync_v2(pCopy, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy2DAsync_v2);
	}
	return res;
}

CUresult cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D * pCopy, CUstream  hStream)
{
	static CUresult (*lcuMemcpy3DAsync_v2) (const CUDA_MEMCPY3D *, CUstream );
	if (!lcuMemcpy3DAsync_v2) {
		lcuMemcpy3DAsync_v2 = (CUresult (*) (const CUDA_MEMCPY3D *, CUstream )) dlsym(RTLD_NEXT, "cuMemcpy3DAsync_v2");
		tracer._kernel_map[(void *) lcuMemcpy3DAsync_v2] = std::string("cuMemcpy3DAsync_v2");
	}
	assert(lcuMemcpy3DAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy3DAsync_v2(pCopy, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy3DAsync_v2);
	}
	return res;
}

CUresult cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER * pCopy, CUstream  hStream)
{
	static CUresult (*lcuMemcpy3DPeerAsync) (const CUDA_MEMCPY3D_PEER *, CUstream );
	if (!lcuMemcpy3DPeerAsync) {
		lcuMemcpy3DPeerAsync = (CUresult (*) (const CUDA_MEMCPY3D_PEER *, CUstream )) dlsym(RTLD_NEXT, "cuMemcpy3DPeerAsync");
		tracer._kernel_map[(void *) lcuMemcpy3DPeerAsync] = std::string("cuMemcpy3DPeerAsync");
	}
	assert(lcuMemcpy3DPeerAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemcpy3DPeerAsync(pCopy, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemcpy3DPeerAsync);
	}
	return res;
}

CUresult cuMemsetD8_v2(CUdeviceptr  dstDevice, unsigned char  uc, size_t  N)
{
	static CUresult (*lcuMemsetD8_v2) (CUdeviceptr , unsigned char , size_t );
	if (!lcuMemsetD8_v2) {
		lcuMemsetD8_v2 = (CUresult (*) (CUdeviceptr , unsigned char , size_t )) dlsym(RTLD_NEXT, "cuMemsetD8_v2");
		tracer._kernel_map[(void *) lcuMemsetD8_v2] = std::string("cuMemsetD8_v2");
	}
	assert(lcuMemsetD8_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD8_v2(dstDevice, uc, N);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD8_v2);
	}
	return res;
}

CUresult cuMemsetD16_v2(CUdeviceptr  dstDevice, unsigned short  us, size_t  N)
{
	static CUresult (*lcuMemsetD16_v2) (CUdeviceptr , unsigned short , size_t );
	if (!lcuMemsetD16_v2) {
		lcuMemsetD16_v2 = (CUresult (*) (CUdeviceptr , unsigned short , size_t )) dlsym(RTLD_NEXT, "cuMemsetD16_v2");
		tracer._kernel_map[(void *) lcuMemsetD16_v2] = std::string("cuMemsetD16_v2");
	}
	assert(lcuMemsetD16_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD16_v2(dstDevice, us, N);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD16_v2);
	}
	return res;
}

CUresult cuMemsetD32_v2(CUdeviceptr  dstDevice, unsigned int  ui, size_t  N)
{
	static CUresult (*lcuMemsetD32_v2) (CUdeviceptr , unsigned int , size_t );
	if (!lcuMemsetD32_v2) {
		lcuMemsetD32_v2 = (CUresult (*) (CUdeviceptr , unsigned int , size_t )) dlsym(RTLD_NEXT, "cuMemsetD32_v2");
		tracer._kernel_map[(void *) lcuMemsetD32_v2] = std::string("cuMemsetD32_v2");
	}
	assert(lcuMemsetD32_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD32_v2(dstDevice, ui, N);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD32_v2);
	}
	return res;
}

CUresult cuMemsetD2D8_v2(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned char  uc, size_t  Width, size_t  Height)
{
	static CUresult (*lcuMemsetD2D8_v2) (CUdeviceptr , size_t , unsigned char , size_t , size_t );
	if (!lcuMemsetD2D8_v2) {
		lcuMemsetD2D8_v2 = (CUresult (*) (CUdeviceptr , size_t , unsigned char , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemsetD2D8_v2");
		tracer._kernel_map[(void *) lcuMemsetD2D8_v2] = std::string("cuMemsetD2D8_v2");
	}
	assert(lcuMemsetD2D8_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D8_v2(dstDevice, dstPitch, uc, Width, Height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D8_v2);
	}
	return res;
}

CUresult cuMemsetD2D16_v2(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned short  us, size_t  Width, size_t  Height)
{
	static CUresult (*lcuMemsetD2D16_v2) (CUdeviceptr , size_t , unsigned short , size_t , size_t );
	if (!lcuMemsetD2D16_v2) {
		lcuMemsetD2D16_v2 = (CUresult (*) (CUdeviceptr , size_t , unsigned short , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemsetD2D16_v2");
		tracer._kernel_map[(void *) lcuMemsetD2D16_v2] = std::string("cuMemsetD2D16_v2");
	}
	assert(lcuMemsetD2D16_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D16_v2(dstDevice, dstPitch, us, Width, Height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D16_v2);
	}
	return res;
}

CUresult cuMemsetD2D32_v2(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned int  ui, size_t  Width, size_t  Height)
{
	static CUresult (*lcuMemsetD2D32_v2) (CUdeviceptr , size_t , unsigned int , size_t , size_t );
	if (!lcuMemsetD2D32_v2) {
		lcuMemsetD2D32_v2 = (CUresult (*) (CUdeviceptr , size_t , unsigned int , size_t , size_t )) dlsym(RTLD_NEXT, "cuMemsetD2D32_v2");
		tracer._kernel_map[(void *) lcuMemsetD2D32_v2] = std::string("cuMemsetD2D32_v2");
	}
	assert(lcuMemsetD2D32_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D32_v2(dstDevice, dstPitch, ui, Width, Height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D32_v2);
	}
	return res;
}

CUresult cuMemsetD8Async(CUdeviceptr  dstDevice, unsigned char  uc, size_t  N, CUstream  hStream)
{
	static CUresult (*lcuMemsetD8Async) (CUdeviceptr , unsigned char , size_t , CUstream );
	if (!lcuMemsetD8Async) {
		lcuMemsetD8Async = (CUresult (*) (CUdeviceptr , unsigned char , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD8Async");
		tracer._kernel_map[(void *) lcuMemsetD8Async] = std::string("cuMemsetD8Async");
	}
	assert(lcuMemsetD8Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD8Async(dstDevice, uc, N, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD8Async);
	}
	return res;
}

CUresult cuMemsetD16Async(CUdeviceptr  dstDevice, unsigned short  us, size_t  N, CUstream  hStream)
{
	static CUresult (*lcuMemsetD16Async) (CUdeviceptr , unsigned short , size_t , CUstream );
	if (!lcuMemsetD16Async) {
		lcuMemsetD16Async = (CUresult (*) (CUdeviceptr , unsigned short , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD16Async");
		tracer._kernel_map[(void *) lcuMemsetD16Async] = std::string("cuMemsetD16Async");
	}
	assert(lcuMemsetD16Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD16Async(dstDevice, us, N, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD16Async);
	}
	return res;
}

CUresult cuMemsetD32Async(CUdeviceptr  dstDevice, unsigned int  ui, size_t  N, CUstream  hStream)
{
	static CUresult (*lcuMemsetD32Async) (CUdeviceptr , unsigned int , size_t , CUstream );
	if (!lcuMemsetD32Async) {
		lcuMemsetD32Async = (CUresult (*) (CUdeviceptr , unsigned int , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD32Async");
		tracer._kernel_map[(void *) lcuMemsetD32Async] = std::string("cuMemsetD32Async");
	}
	assert(lcuMemsetD32Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD32Async(dstDevice, ui, N, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD32Async);
	}
	return res;
}

CUresult cuMemsetD2D8Async(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned char  uc, size_t  Width, size_t  Height, CUstream  hStream)
{
	static CUresult (*lcuMemsetD2D8Async) (CUdeviceptr , size_t , unsigned char , size_t , size_t , CUstream );
	if (!lcuMemsetD2D8Async) {
		lcuMemsetD2D8Async = (CUresult (*) (CUdeviceptr , size_t , unsigned char , size_t , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD2D8Async");
		tracer._kernel_map[(void *) lcuMemsetD2D8Async] = std::string("cuMemsetD2D8Async");
	}
	assert(lcuMemsetD2D8Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D8Async(dstDevice, dstPitch, uc, Width, Height, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D8Async);
	}
	return res;
}

CUresult cuMemsetD2D16Async(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned short  us, size_t  Width, size_t  Height, CUstream  hStream)
{
	static CUresult (*lcuMemsetD2D16Async) (CUdeviceptr , size_t , unsigned short , size_t , size_t , CUstream );
	if (!lcuMemsetD2D16Async) {
		lcuMemsetD2D16Async = (CUresult (*) (CUdeviceptr , size_t , unsigned short , size_t , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD2D16Async");
		tracer._kernel_map[(void *) lcuMemsetD2D16Async] = std::string("cuMemsetD2D16Async");
	}
	assert(lcuMemsetD2D16Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D16Async(dstDevice, dstPitch, us, Width, Height, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D16Async);
	}
	return res;
}

CUresult cuMemsetD2D32Async(CUdeviceptr  dstDevice, size_t  dstPitch, unsigned int  ui, size_t  Width, size_t  Height, CUstream  hStream)
{
	static CUresult (*lcuMemsetD2D32Async) (CUdeviceptr , size_t , unsigned int , size_t , size_t , CUstream );
	if (!lcuMemsetD2D32Async) {
		lcuMemsetD2D32Async = (CUresult (*) (CUdeviceptr , size_t , unsigned int , size_t , size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemsetD2D32Async");
		tracer._kernel_map[(void *) lcuMemsetD2D32Async] = std::string("cuMemsetD2D32Async");
	}
	assert(lcuMemsetD2D32Async);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemsetD2D32Async(dstDevice, dstPitch, ui, Width, Height, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemsetD2D32Async);
	}
	return res;
}

CUresult cuArrayCreate_v2(CUarray * pHandle, const CUDA_ARRAY_DESCRIPTOR * pAllocateArray)
{
	static CUresult (*lcuArrayCreate_v2) (CUarray *, const CUDA_ARRAY_DESCRIPTOR *);
	if (!lcuArrayCreate_v2) {
		lcuArrayCreate_v2 = (CUresult (*) (CUarray *, const CUDA_ARRAY_DESCRIPTOR *)) dlsym(RTLD_NEXT, "cuArrayCreate_v2");
		tracer._kernel_map[(void *) lcuArrayCreate_v2] = std::string("cuArrayCreate_v2");
	}
	assert(lcuArrayCreate_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayCreate_v2(pHandle, pAllocateArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayCreate_v2);
	}
	return res;
}

CUresult cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * pArrayDescriptor, CUarray  hArray)
{
	static CUresult (*lcuArrayGetDescriptor_v2) (CUDA_ARRAY_DESCRIPTOR *, CUarray );
	if (!lcuArrayGetDescriptor_v2) {
		lcuArrayGetDescriptor_v2 = (CUresult (*) (CUDA_ARRAY_DESCRIPTOR *, CUarray )) dlsym(RTLD_NEXT, "cuArrayGetDescriptor_v2");
		tracer._kernel_map[(void *) lcuArrayGetDescriptor_v2] = std::string("cuArrayGetDescriptor_v2");
	}
	assert(lcuArrayGetDescriptor_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayGetDescriptor_v2(pArrayDescriptor, hArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayGetDescriptor_v2);
	}
	return res;
}

CUresult cuArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES * sparseProperties, CUarray  array)
{
	static CUresult (*lcuArrayGetSparseProperties) (CUDA_ARRAY_SPARSE_PROPERTIES *, CUarray );
	if (!lcuArrayGetSparseProperties) {
		lcuArrayGetSparseProperties = (CUresult (*) (CUDA_ARRAY_SPARSE_PROPERTIES *, CUarray )) dlsym(RTLD_NEXT, "cuArrayGetSparseProperties");
		tracer._kernel_map[(void *) lcuArrayGetSparseProperties] = std::string("cuArrayGetSparseProperties");
	}
	assert(lcuArrayGetSparseProperties);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayGetSparseProperties(sparseProperties, array);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayGetSparseProperties);
	}
	return res;
}

CUresult cuMipmappedArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES * sparseProperties, CUmipmappedArray  mipmap)
{
	static CUresult (*lcuMipmappedArrayGetSparseProperties) (CUDA_ARRAY_SPARSE_PROPERTIES *, CUmipmappedArray );
	if (!lcuMipmappedArrayGetSparseProperties) {
		lcuMipmappedArrayGetSparseProperties = (CUresult (*) (CUDA_ARRAY_SPARSE_PROPERTIES *, CUmipmappedArray )) dlsym(RTLD_NEXT, "cuMipmappedArrayGetSparseProperties");
		tracer._kernel_map[(void *) lcuMipmappedArrayGetSparseProperties] = std::string("cuMipmappedArrayGetSparseProperties");
	}
	assert(lcuMipmappedArrayGetSparseProperties);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMipmappedArrayGetSparseProperties(sparseProperties, mipmap);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMipmappedArrayGetSparseProperties);
	}
	return res;
}

CUresult cuArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS * memoryRequirements, CUarray  array, CUdevice  device)
{
	static CUresult (*lcuArrayGetMemoryRequirements) (CUDA_ARRAY_MEMORY_REQUIREMENTS *, CUarray , CUdevice );
	if (!lcuArrayGetMemoryRequirements) {
		lcuArrayGetMemoryRequirements = (CUresult (*) (CUDA_ARRAY_MEMORY_REQUIREMENTS *, CUarray , CUdevice )) dlsym(RTLD_NEXT, "cuArrayGetMemoryRequirements");
		tracer._kernel_map[(void *) lcuArrayGetMemoryRequirements] = std::string("cuArrayGetMemoryRequirements");
	}
	assert(lcuArrayGetMemoryRequirements);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayGetMemoryRequirements(memoryRequirements, array, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayGetMemoryRequirements);
	}
	return res;
}

CUresult cuMipmappedArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS * memoryRequirements, CUmipmappedArray  mipmap, CUdevice  device)
{
	static CUresult (*lcuMipmappedArrayGetMemoryRequirements) (CUDA_ARRAY_MEMORY_REQUIREMENTS *, CUmipmappedArray , CUdevice );
	if (!lcuMipmappedArrayGetMemoryRequirements) {
		lcuMipmappedArrayGetMemoryRequirements = (CUresult (*) (CUDA_ARRAY_MEMORY_REQUIREMENTS *, CUmipmappedArray , CUdevice )) dlsym(RTLD_NEXT, "cuMipmappedArrayGetMemoryRequirements");
		tracer._kernel_map[(void *) lcuMipmappedArrayGetMemoryRequirements] = std::string("cuMipmappedArrayGetMemoryRequirements");
	}
	assert(lcuMipmappedArrayGetMemoryRequirements);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMipmappedArrayGetMemoryRequirements(memoryRequirements, mipmap, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMipmappedArrayGetMemoryRequirements);
	}
	return res;
}

CUresult cuArrayGetPlane(CUarray * pPlaneArray, CUarray  hArray, unsigned int  planeIdx)
{
	static CUresult (*lcuArrayGetPlane) (CUarray *, CUarray , unsigned int );
	if (!lcuArrayGetPlane) {
		lcuArrayGetPlane = (CUresult (*) (CUarray *, CUarray , unsigned int )) dlsym(RTLD_NEXT, "cuArrayGetPlane");
		tracer._kernel_map[(void *) lcuArrayGetPlane] = std::string("cuArrayGetPlane");
	}
	assert(lcuArrayGetPlane);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayGetPlane(pPlaneArray, hArray, planeIdx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayGetPlane);
	}
	return res;
}

CUresult cuArrayDestroy(CUarray  hArray)
{
	static CUresult (*lcuArrayDestroy) (CUarray );
	if (!lcuArrayDestroy) {
		lcuArrayDestroy = (CUresult (*) (CUarray )) dlsym(RTLD_NEXT, "cuArrayDestroy");
		tracer._kernel_map[(void *) lcuArrayDestroy] = std::string("cuArrayDestroy");
	}
	assert(lcuArrayDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArrayDestroy(hArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArrayDestroy);
	}
	return res;
}

CUresult cuArray3DCreate_v2(CUarray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pAllocateArray)
{
	static CUresult (*lcuArray3DCreate_v2) (CUarray *, const CUDA_ARRAY3D_DESCRIPTOR *);
	if (!lcuArray3DCreate_v2) {
		lcuArray3DCreate_v2 = (CUresult (*) (CUarray *, const CUDA_ARRAY3D_DESCRIPTOR *)) dlsym(RTLD_NEXT, "cuArray3DCreate_v2");
		tracer._kernel_map[(void *) lcuArray3DCreate_v2] = std::string("cuArray3DCreate_v2");
	}
	assert(lcuArray3DCreate_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArray3DCreate_v2(pHandle, pAllocateArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArray3DCreate_v2);
	}
	return res;
}

CUresult cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * pArrayDescriptor, CUarray  hArray)
{
	static CUresult (*lcuArray3DGetDescriptor_v2) (CUDA_ARRAY3D_DESCRIPTOR *, CUarray );
	if (!lcuArray3DGetDescriptor_v2) {
		lcuArray3DGetDescriptor_v2 = (CUresult (*) (CUDA_ARRAY3D_DESCRIPTOR *, CUarray )) dlsym(RTLD_NEXT, "cuArray3DGetDescriptor_v2");
		tracer._kernel_map[(void *) lcuArray3DGetDescriptor_v2] = std::string("cuArray3DGetDescriptor_v2");
	}
	assert(lcuArray3DGetDescriptor_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuArray3DGetDescriptor_v2(pArrayDescriptor, hArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuArray3DGetDescriptor_v2);
	}
	return res;
}

CUresult cuMipmappedArrayCreate(CUmipmappedArray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc, unsigned int  numMipmapLevels)
{
	static CUresult (*lcuMipmappedArrayCreate) (CUmipmappedArray *, const CUDA_ARRAY3D_DESCRIPTOR *, unsigned int );
	if (!lcuMipmappedArrayCreate) {
		lcuMipmappedArrayCreate = (CUresult (*) (CUmipmappedArray *, const CUDA_ARRAY3D_DESCRIPTOR *, unsigned int )) dlsym(RTLD_NEXT, "cuMipmappedArrayCreate");
		tracer._kernel_map[(void *) lcuMipmappedArrayCreate] = std::string("cuMipmappedArrayCreate");
	}
	assert(lcuMipmappedArrayCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMipmappedArrayCreate(pHandle, pMipmappedArrayDesc, numMipmapLevels);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMipmappedArrayCreate);
	}
	return res;
}

CUresult cuMipmappedArrayGetLevel(CUarray * pLevelArray, CUmipmappedArray  hMipmappedArray, unsigned int  level)
{
	static CUresult (*lcuMipmappedArrayGetLevel) (CUarray *, CUmipmappedArray , unsigned int );
	if (!lcuMipmappedArrayGetLevel) {
		lcuMipmappedArrayGetLevel = (CUresult (*) (CUarray *, CUmipmappedArray , unsigned int )) dlsym(RTLD_NEXT, "cuMipmappedArrayGetLevel");
		tracer._kernel_map[(void *) lcuMipmappedArrayGetLevel] = std::string("cuMipmappedArrayGetLevel");
	}
	assert(lcuMipmappedArrayGetLevel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMipmappedArrayGetLevel(pLevelArray, hMipmappedArray, level);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMipmappedArrayGetLevel);
	}
	return res;
}

CUresult cuMipmappedArrayDestroy(CUmipmappedArray  hMipmappedArray)
{
	static CUresult (*lcuMipmappedArrayDestroy) (CUmipmappedArray );
	if (!lcuMipmappedArrayDestroy) {
		lcuMipmappedArrayDestroy = (CUresult (*) (CUmipmappedArray )) dlsym(RTLD_NEXT, "cuMipmappedArrayDestroy");
		tracer._kernel_map[(void *) lcuMipmappedArrayDestroy] = std::string("cuMipmappedArrayDestroy");
	}
	assert(lcuMipmappedArrayDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMipmappedArrayDestroy(hMipmappedArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMipmappedArrayDestroy);
	}
	return res;
}

CUresult cuMemGetHandleForAddressRange(void * handle, CUdeviceptr  dptr, size_t  size, CUmemRangeHandleType  handleType, unsigned long long  flags)
{
	static CUresult (*lcuMemGetHandleForAddressRange) (void *, CUdeviceptr , size_t , CUmemRangeHandleType , unsigned long long );
	if (!lcuMemGetHandleForAddressRange) {
		lcuMemGetHandleForAddressRange = (CUresult (*) (void *, CUdeviceptr , size_t , CUmemRangeHandleType , unsigned long long )) dlsym(RTLD_NEXT, "cuMemGetHandleForAddressRange");
		tracer._kernel_map[(void *) lcuMemGetHandleForAddressRange] = std::string("cuMemGetHandleForAddressRange");
	}
	assert(lcuMemGetHandleForAddressRange);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetHandleForAddressRange(handle, dptr, size, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetHandleForAddressRange);
	}
	return res;
}

CUresult cuMemAddressReserve(CUdeviceptr * ptr, size_t  size, size_t  alignment, CUdeviceptr  addr, unsigned long long  flags)
{
	static CUresult (*lcuMemAddressReserve) (CUdeviceptr *, size_t , size_t , CUdeviceptr , unsigned long long );
	if (!lcuMemAddressReserve) {
		lcuMemAddressReserve = (CUresult (*) (CUdeviceptr *, size_t , size_t , CUdeviceptr , unsigned long long )) dlsym(RTLD_NEXT, "cuMemAddressReserve");
		tracer._kernel_map[(void *) lcuMemAddressReserve] = std::string("cuMemAddressReserve");
	}
	assert(lcuMemAddressReserve);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAddressReserve(ptr, size, alignment, addr, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAddressReserve);
	}
	return res;
}

CUresult cuMemAddressFree(CUdeviceptr  ptr, size_t  size)
{
	static CUresult (*lcuMemAddressFree) (CUdeviceptr , size_t );
	if (!lcuMemAddressFree) {
		lcuMemAddressFree = (CUresult (*) (CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemAddressFree");
		tracer._kernel_map[(void *) lcuMemAddressFree] = std::string("cuMemAddressFree");
	}
	assert(lcuMemAddressFree);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAddressFree(ptr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAddressFree);
	}
	return res;
}

CUresult cuMemCreate(CUmemGenericAllocationHandle * handle, size_t  size, const CUmemAllocationProp * prop, unsigned long long  flags)
{
	static CUresult (*lcuMemCreate) (CUmemGenericAllocationHandle *, size_t , const CUmemAllocationProp *, unsigned long long );
	if (!lcuMemCreate) {
		lcuMemCreate = (CUresult (*) (CUmemGenericAllocationHandle *, size_t , const CUmemAllocationProp *, unsigned long long )) dlsym(RTLD_NEXT, "cuMemCreate");
		tracer._kernel_map[(void *) lcuMemCreate] = std::string("cuMemCreate");
	}
	assert(lcuMemCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemCreate(handle, size, prop, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemCreate);
	}
	return res;
}

CUresult cuMemRelease(CUmemGenericAllocationHandle  handle)
{
	static CUresult (*lcuMemRelease) (CUmemGenericAllocationHandle );
	if (!lcuMemRelease) {
		lcuMemRelease = (CUresult (*) (CUmemGenericAllocationHandle )) dlsym(RTLD_NEXT, "cuMemRelease");
		tracer._kernel_map[(void *) lcuMemRelease] = std::string("cuMemRelease");
	}
	assert(lcuMemRelease);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemRelease(handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemRelease);
	}
	return res;
}

CUresult cuMemMap(CUdeviceptr  ptr, size_t  size, size_t  offset, CUmemGenericAllocationHandle  handle, unsigned long long  flags)
{
	static CUresult (*lcuMemMap) (CUdeviceptr , size_t , size_t , CUmemGenericAllocationHandle , unsigned long long );
	if (!lcuMemMap) {
		lcuMemMap = (CUresult (*) (CUdeviceptr , size_t , size_t , CUmemGenericAllocationHandle , unsigned long long )) dlsym(RTLD_NEXT, "cuMemMap");
		tracer._kernel_map[(void *) lcuMemMap] = std::string("cuMemMap");
	}
	assert(lcuMemMap);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemMap(ptr, size, offset, handle, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemMap);
	}
	return res;
}

CUresult cuMemMapArrayAsync(CUarrayMapInfo * mapInfoList, unsigned int  count, CUstream  hStream)
{
	static CUresult (*lcuMemMapArrayAsync) (CUarrayMapInfo *, unsigned int , CUstream );
	if (!lcuMemMapArrayAsync) {
		lcuMemMapArrayAsync = (CUresult (*) (CUarrayMapInfo *, unsigned int , CUstream )) dlsym(RTLD_NEXT, "cuMemMapArrayAsync");
		tracer._kernel_map[(void *) lcuMemMapArrayAsync] = std::string("cuMemMapArrayAsync");
	}
	assert(lcuMemMapArrayAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemMapArrayAsync(mapInfoList, count, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemMapArrayAsync);
	}
	return res;
}

CUresult cuMemUnmap(CUdeviceptr  ptr, size_t  size)
{
	static CUresult (*lcuMemUnmap) (CUdeviceptr , size_t );
	if (!lcuMemUnmap) {
		lcuMemUnmap = (CUresult (*) (CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemUnmap");
		tracer._kernel_map[(void *) lcuMemUnmap] = std::string("cuMemUnmap");
	}
	assert(lcuMemUnmap);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemUnmap(ptr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemUnmap);
	}
	return res;
}

CUresult cuMemSetAccess(CUdeviceptr  ptr, size_t  size, const CUmemAccessDesc * desc, size_t  count)
{
	static CUresult (*lcuMemSetAccess) (CUdeviceptr , size_t , const CUmemAccessDesc *, size_t );
	if (!lcuMemSetAccess) {
		lcuMemSetAccess = (CUresult (*) (CUdeviceptr , size_t , const CUmemAccessDesc *, size_t )) dlsym(RTLD_NEXT, "cuMemSetAccess");
		tracer._kernel_map[(void *) lcuMemSetAccess] = std::string("cuMemSetAccess");
	}
	assert(lcuMemSetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemSetAccess(ptr, size, desc, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemSetAccess);
	}
	return res;
}

CUresult cuMemGetAccess(unsigned long long * flags, const CUmemLocation * location, CUdeviceptr  ptr)
{
	static CUresult (*lcuMemGetAccess) (unsigned long long *, const CUmemLocation *, CUdeviceptr );
	if (!lcuMemGetAccess) {
		lcuMemGetAccess = (CUresult (*) (unsigned long long *, const CUmemLocation *, CUdeviceptr )) dlsym(RTLD_NEXT, "cuMemGetAccess");
		tracer._kernel_map[(void *) lcuMemGetAccess] = std::string("cuMemGetAccess");
	}
	assert(lcuMemGetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetAccess(flags, location, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetAccess);
	}
	return res;
}

CUresult cuMemExportToShareableHandle(void * shareableHandle, CUmemGenericAllocationHandle  handle, CUmemAllocationHandleType  handleType, unsigned long long  flags)
{
	static CUresult (*lcuMemExportToShareableHandle) (void *, CUmemGenericAllocationHandle , CUmemAllocationHandleType , unsigned long long );
	if (!lcuMemExportToShareableHandle) {
		lcuMemExportToShareableHandle = (CUresult (*) (void *, CUmemGenericAllocationHandle , CUmemAllocationHandleType , unsigned long long )) dlsym(RTLD_NEXT, "cuMemExportToShareableHandle");
		tracer._kernel_map[(void *) lcuMemExportToShareableHandle] = std::string("cuMemExportToShareableHandle");
	}
	assert(lcuMemExportToShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemExportToShareableHandle(shareableHandle, handle, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemExportToShareableHandle);
	}
	return res;
}

CUresult cuMemImportFromShareableHandle(CUmemGenericAllocationHandle * handle, void * osHandle, CUmemAllocationHandleType  shHandleType)
{
	static CUresult (*lcuMemImportFromShareableHandle) (CUmemGenericAllocationHandle *, void *, CUmemAllocationHandleType );
	if (!lcuMemImportFromShareableHandle) {
		lcuMemImportFromShareableHandle = (CUresult (*) (CUmemGenericAllocationHandle *, void *, CUmemAllocationHandleType )) dlsym(RTLD_NEXT, "cuMemImportFromShareableHandle");
		tracer._kernel_map[(void *) lcuMemImportFromShareableHandle] = std::string("cuMemImportFromShareableHandle");
	}
	assert(lcuMemImportFromShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemImportFromShareableHandle(handle, osHandle, shHandleType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemImportFromShareableHandle);
	}
	return res;
}

CUresult cuMemGetAllocationGranularity(size_t * granularity, const CUmemAllocationProp * prop, CUmemAllocationGranularity_flags  option)
{
	static CUresult (*lcuMemGetAllocationGranularity) (size_t *, const CUmemAllocationProp *, CUmemAllocationGranularity_flags );
	if (!lcuMemGetAllocationGranularity) {
		lcuMemGetAllocationGranularity = (CUresult (*) (size_t *, const CUmemAllocationProp *, CUmemAllocationGranularity_flags )) dlsym(RTLD_NEXT, "cuMemGetAllocationGranularity");
		tracer._kernel_map[(void *) lcuMemGetAllocationGranularity] = std::string("cuMemGetAllocationGranularity");
	}
	assert(lcuMemGetAllocationGranularity);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetAllocationGranularity(granularity, prop, option);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetAllocationGranularity);
	}
	return res;
}

CUresult cuMemGetAllocationPropertiesFromHandle(CUmemAllocationProp * prop, CUmemGenericAllocationHandle  handle)
{
	static CUresult (*lcuMemGetAllocationPropertiesFromHandle) (CUmemAllocationProp *, CUmemGenericAllocationHandle );
	if (!lcuMemGetAllocationPropertiesFromHandle) {
		lcuMemGetAllocationPropertiesFromHandle = (CUresult (*) (CUmemAllocationProp *, CUmemGenericAllocationHandle )) dlsym(RTLD_NEXT, "cuMemGetAllocationPropertiesFromHandle");
		tracer._kernel_map[(void *) lcuMemGetAllocationPropertiesFromHandle] = std::string("cuMemGetAllocationPropertiesFromHandle");
	}
	assert(lcuMemGetAllocationPropertiesFromHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemGetAllocationPropertiesFromHandle(prop, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemGetAllocationPropertiesFromHandle);
	}
	return res;
}

CUresult cuMemRetainAllocationHandle(CUmemGenericAllocationHandle * handle, void * addr)
{
	static CUresult (*lcuMemRetainAllocationHandle) (CUmemGenericAllocationHandle *, void *);
	if (!lcuMemRetainAllocationHandle) {
		lcuMemRetainAllocationHandle = (CUresult (*) (CUmemGenericAllocationHandle *, void *)) dlsym(RTLD_NEXT, "cuMemRetainAllocationHandle");
		tracer._kernel_map[(void *) lcuMemRetainAllocationHandle] = std::string("cuMemRetainAllocationHandle");
	}
	assert(lcuMemRetainAllocationHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemRetainAllocationHandle(handle, addr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemRetainAllocationHandle);
	}
	return res;
}

CUresult cuMemFreeAsync(CUdeviceptr  dptr, CUstream  hStream)
{
	static CUresult (*lcuMemFreeAsync) (CUdeviceptr , CUstream );
	if (!lcuMemFreeAsync) {
		lcuMemFreeAsync = (CUresult (*) (CUdeviceptr , CUstream )) dlsym(RTLD_NEXT, "cuMemFreeAsync");
		tracer._kernel_map[(void *) lcuMemFreeAsync] = std::string("cuMemFreeAsync");
	}
	assert(lcuMemFreeAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemFreeAsync(dptr, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemFreeAsync);
	}
	return res;
}

CUresult cuMemAllocAsync(CUdeviceptr * dptr, size_t  bytesize, CUstream  hStream)
{
	static CUresult (*lcuMemAllocAsync) (CUdeviceptr *, size_t , CUstream );
	if (!lcuMemAllocAsync) {
		lcuMemAllocAsync = (CUresult (*) (CUdeviceptr *, size_t , CUstream )) dlsym(RTLD_NEXT, "cuMemAllocAsync");
		tracer._kernel_map[(void *) lcuMemAllocAsync] = std::string("cuMemAllocAsync");
	}
	assert(lcuMemAllocAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAllocAsync(dptr, bytesize, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAllocAsync);
	}
	return res;
}

CUresult cuMemPoolTrimTo(CUmemoryPool  pool, size_t  minBytesToKeep)
{
	static CUresult (*lcuMemPoolTrimTo) (CUmemoryPool , size_t );
	if (!lcuMemPoolTrimTo) {
		lcuMemPoolTrimTo = (CUresult (*) (CUmemoryPool , size_t )) dlsym(RTLD_NEXT, "cuMemPoolTrimTo");
		tracer._kernel_map[(void *) lcuMemPoolTrimTo] = std::string("cuMemPoolTrimTo");
	}
	assert(lcuMemPoolTrimTo);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolTrimTo(pool, minBytesToKeep);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolTrimTo);
	}
	return res;
}

CUresult cuMemPoolSetAttribute(CUmemoryPool  pool, CUmemPool_attribute  attr, void * value)
{
	static CUresult (*lcuMemPoolSetAttribute) (CUmemoryPool , CUmemPool_attribute , void *);
	if (!lcuMemPoolSetAttribute) {
		lcuMemPoolSetAttribute = (CUresult (*) (CUmemoryPool , CUmemPool_attribute , void *)) dlsym(RTLD_NEXT, "cuMemPoolSetAttribute");
		tracer._kernel_map[(void *) lcuMemPoolSetAttribute] = std::string("cuMemPoolSetAttribute");
	}
	assert(lcuMemPoolSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolSetAttribute(pool, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolSetAttribute);
	}
	return res;
}

CUresult cuMemPoolGetAttribute(CUmemoryPool  pool, CUmemPool_attribute  attr, void * value)
{
	static CUresult (*lcuMemPoolGetAttribute) (CUmemoryPool , CUmemPool_attribute , void *);
	if (!lcuMemPoolGetAttribute) {
		lcuMemPoolGetAttribute = (CUresult (*) (CUmemoryPool , CUmemPool_attribute , void *)) dlsym(RTLD_NEXT, "cuMemPoolGetAttribute");
		tracer._kernel_map[(void *) lcuMemPoolGetAttribute] = std::string("cuMemPoolGetAttribute");
	}
	assert(lcuMemPoolGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolGetAttribute(pool, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolGetAttribute);
	}
	return res;
}

CUresult cuMemPoolSetAccess(CUmemoryPool  pool, const CUmemAccessDesc * map, size_t  count)
{
	static CUresult (*lcuMemPoolSetAccess) (CUmemoryPool , const CUmemAccessDesc *, size_t );
	if (!lcuMemPoolSetAccess) {
		lcuMemPoolSetAccess = (CUresult (*) (CUmemoryPool , const CUmemAccessDesc *, size_t )) dlsym(RTLD_NEXT, "cuMemPoolSetAccess");
		tracer._kernel_map[(void *) lcuMemPoolSetAccess] = std::string("cuMemPoolSetAccess");
	}
	assert(lcuMemPoolSetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolSetAccess(pool, map, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolSetAccess);
	}
	return res;
}

CUresult cuMemPoolGetAccess(CUmemAccess_flags * flags, CUmemoryPool  memPool, CUmemLocation * location)
{
	static CUresult (*lcuMemPoolGetAccess) (CUmemAccess_flags *, CUmemoryPool , CUmemLocation *);
	if (!lcuMemPoolGetAccess) {
		lcuMemPoolGetAccess = (CUresult (*) (CUmemAccess_flags *, CUmemoryPool , CUmemLocation *)) dlsym(RTLD_NEXT, "cuMemPoolGetAccess");
		tracer._kernel_map[(void *) lcuMemPoolGetAccess] = std::string("cuMemPoolGetAccess");
	}
	assert(lcuMemPoolGetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolGetAccess(flags, memPool, location);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolGetAccess);
	}
	return res;
}

CUresult cuMemPoolCreate(CUmemoryPool * pool, const CUmemPoolProps * poolProps)
{
	static CUresult (*lcuMemPoolCreate) (CUmemoryPool *, const CUmemPoolProps *);
	if (!lcuMemPoolCreate) {
		lcuMemPoolCreate = (CUresult (*) (CUmemoryPool *, const CUmemPoolProps *)) dlsym(RTLD_NEXT, "cuMemPoolCreate");
		tracer._kernel_map[(void *) lcuMemPoolCreate] = std::string("cuMemPoolCreate");
	}
	assert(lcuMemPoolCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolCreate(pool, poolProps);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolCreate);
	}
	return res;
}

CUresult cuMemPoolDestroy(CUmemoryPool  pool)
{
	static CUresult (*lcuMemPoolDestroy) (CUmemoryPool );
	if (!lcuMemPoolDestroy) {
		lcuMemPoolDestroy = (CUresult (*) (CUmemoryPool )) dlsym(RTLD_NEXT, "cuMemPoolDestroy");
		tracer._kernel_map[(void *) lcuMemPoolDestroy] = std::string("cuMemPoolDestroy");
	}
	assert(lcuMemPoolDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolDestroy(pool);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolDestroy);
	}
	return res;
}

CUresult cuMemAllocFromPoolAsync(CUdeviceptr * dptr, size_t  bytesize, CUmemoryPool  pool, CUstream  hStream)
{
	static CUresult (*lcuMemAllocFromPoolAsync) (CUdeviceptr *, size_t , CUmemoryPool , CUstream );
	if (!lcuMemAllocFromPoolAsync) {
		lcuMemAllocFromPoolAsync = (CUresult (*) (CUdeviceptr *, size_t , CUmemoryPool , CUstream )) dlsym(RTLD_NEXT, "cuMemAllocFromPoolAsync");
		tracer._kernel_map[(void *) lcuMemAllocFromPoolAsync] = std::string("cuMemAllocFromPoolAsync");
	}
	assert(lcuMemAllocFromPoolAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAllocFromPoolAsync(dptr, bytesize, pool, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAllocFromPoolAsync);
	}
	return res;
}

CUresult cuMemPoolExportToShareableHandle(void * handle_out, CUmemoryPool  pool, CUmemAllocationHandleType  handleType, unsigned long long  flags)
{
	static CUresult (*lcuMemPoolExportToShareableHandle) (void *, CUmemoryPool , CUmemAllocationHandleType , unsigned long long );
	if (!lcuMemPoolExportToShareableHandle) {
		lcuMemPoolExportToShareableHandle = (CUresult (*) (void *, CUmemoryPool , CUmemAllocationHandleType , unsigned long long )) dlsym(RTLD_NEXT, "cuMemPoolExportToShareableHandle");
		tracer._kernel_map[(void *) lcuMemPoolExportToShareableHandle] = std::string("cuMemPoolExportToShareableHandle");
	}
	assert(lcuMemPoolExportToShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolExportToShareableHandle(handle_out, pool, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolExportToShareableHandle);
	}
	return res;
}

CUresult cuMemPoolImportFromShareableHandle(CUmemoryPool * pool_out, void * handle, CUmemAllocationHandleType  handleType, unsigned long long  flags)
{
	static CUresult (*lcuMemPoolImportFromShareableHandle) (CUmemoryPool *, void *, CUmemAllocationHandleType , unsigned long long );
	if (!lcuMemPoolImportFromShareableHandle) {
		lcuMemPoolImportFromShareableHandle = (CUresult (*) (CUmemoryPool *, void *, CUmemAllocationHandleType , unsigned long long )) dlsym(RTLD_NEXT, "cuMemPoolImportFromShareableHandle");
		tracer._kernel_map[(void *) lcuMemPoolImportFromShareableHandle] = std::string("cuMemPoolImportFromShareableHandle");
	}
	assert(lcuMemPoolImportFromShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolImportFromShareableHandle(pool_out, handle, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolImportFromShareableHandle);
	}
	return res;
}

CUresult cuMemPoolExportPointer(CUmemPoolPtrExportData * shareData_out, CUdeviceptr  ptr)
{
	static CUresult (*lcuMemPoolExportPointer) (CUmemPoolPtrExportData *, CUdeviceptr );
	if (!lcuMemPoolExportPointer) {
		lcuMemPoolExportPointer = (CUresult (*) (CUmemPoolPtrExportData *, CUdeviceptr )) dlsym(RTLD_NEXT, "cuMemPoolExportPointer");
		tracer._kernel_map[(void *) lcuMemPoolExportPointer] = std::string("cuMemPoolExportPointer");
	}
	assert(lcuMemPoolExportPointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolExportPointer(shareData_out, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolExportPointer);
	}
	return res;
}

CUresult cuMemPoolImportPointer(CUdeviceptr * ptr_out, CUmemoryPool  pool, CUmemPoolPtrExportData * shareData)
{
	static CUresult (*lcuMemPoolImportPointer) (CUdeviceptr *, CUmemoryPool , CUmemPoolPtrExportData *);
	if (!lcuMemPoolImportPointer) {
		lcuMemPoolImportPointer = (CUresult (*) (CUdeviceptr *, CUmemoryPool , CUmemPoolPtrExportData *)) dlsym(RTLD_NEXT, "cuMemPoolImportPointer");
		tracer._kernel_map[(void *) lcuMemPoolImportPointer] = std::string("cuMemPoolImportPointer");
	}
	assert(lcuMemPoolImportPointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPoolImportPointer(ptr_out, pool, shareData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPoolImportPointer);
	}
	return res;
}

CUresult cuMulticastCreate(CUmemGenericAllocationHandle * mcHandle, const CUmulticastObjectProp * prop)
{
	static CUresult (*lcuMulticastCreate) (CUmemGenericAllocationHandle *, const CUmulticastObjectProp *);
	if (!lcuMulticastCreate) {
		lcuMulticastCreate = (CUresult (*) (CUmemGenericAllocationHandle *, const CUmulticastObjectProp *)) dlsym(RTLD_NEXT, "cuMulticastCreate");
		tracer._kernel_map[(void *) lcuMulticastCreate] = std::string("cuMulticastCreate");
	}
	assert(lcuMulticastCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastCreate(mcHandle, prop);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastCreate);
	}
	return res;
}

CUresult cuMulticastAddDevice(CUmemGenericAllocationHandle  mcHandle, CUdevice  dev)
{
	static CUresult (*lcuMulticastAddDevice) (CUmemGenericAllocationHandle , CUdevice );
	if (!lcuMulticastAddDevice) {
		lcuMulticastAddDevice = (CUresult (*) (CUmemGenericAllocationHandle , CUdevice )) dlsym(RTLD_NEXT, "cuMulticastAddDevice");
		tracer._kernel_map[(void *) lcuMulticastAddDevice] = std::string("cuMulticastAddDevice");
	}
	assert(lcuMulticastAddDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastAddDevice(mcHandle, dev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastAddDevice);
	}
	return res;
}

CUresult cuMulticastBindMem(CUmemGenericAllocationHandle  mcHandle, size_t  mcOffset, CUmemGenericAllocationHandle  memHandle, size_t  memOffset, size_t  size, unsigned long long  flags)
{
	static CUresult (*lcuMulticastBindMem) (CUmemGenericAllocationHandle , size_t , CUmemGenericAllocationHandle , size_t , size_t , unsigned long long );
	if (!lcuMulticastBindMem) {
		lcuMulticastBindMem = (CUresult (*) (CUmemGenericAllocationHandle , size_t , CUmemGenericAllocationHandle , size_t , size_t , unsigned long long )) dlsym(RTLD_NEXT, "cuMulticastBindMem");
		tracer._kernel_map[(void *) lcuMulticastBindMem] = std::string("cuMulticastBindMem");
	}
	assert(lcuMulticastBindMem);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastBindMem(mcHandle, mcOffset, memHandle, memOffset, size, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastBindMem);
	}
	return res;
}

CUresult cuMulticastBindAddr(CUmemGenericAllocationHandle  mcHandle, size_t  mcOffset, CUdeviceptr  memptr, size_t  size, unsigned long long  flags)
{
	static CUresult (*lcuMulticastBindAddr) (CUmemGenericAllocationHandle , size_t , CUdeviceptr , size_t , unsigned long long );
	if (!lcuMulticastBindAddr) {
		lcuMulticastBindAddr = (CUresult (*) (CUmemGenericAllocationHandle , size_t , CUdeviceptr , size_t , unsigned long long )) dlsym(RTLD_NEXT, "cuMulticastBindAddr");
		tracer._kernel_map[(void *) lcuMulticastBindAddr] = std::string("cuMulticastBindAddr");
	}
	assert(lcuMulticastBindAddr);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastBindAddr(mcHandle, mcOffset, memptr, size, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastBindAddr);
	}
	return res;
}

CUresult cuMulticastUnbind(CUmemGenericAllocationHandle  mcHandle, CUdevice  dev, size_t  mcOffset, size_t  size)
{
	static CUresult (*lcuMulticastUnbind) (CUmemGenericAllocationHandle , CUdevice , size_t , size_t );
	if (!lcuMulticastUnbind) {
		lcuMulticastUnbind = (CUresult (*) (CUmemGenericAllocationHandle , CUdevice , size_t , size_t )) dlsym(RTLD_NEXT, "cuMulticastUnbind");
		tracer._kernel_map[(void *) lcuMulticastUnbind] = std::string("cuMulticastUnbind");
	}
	assert(lcuMulticastUnbind);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastUnbind(mcHandle, dev, mcOffset, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastUnbind);
	}
	return res;
}

CUresult cuMulticastGetGranularity(size_t * granularity, const CUmulticastObjectProp * prop, CUmulticastGranularity_flags  option)
{
	static CUresult (*lcuMulticastGetGranularity) (size_t *, const CUmulticastObjectProp *, CUmulticastGranularity_flags );
	if (!lcuMulticastGetGranularity) {
		lcuMulticastGetGranularity = (CUresult (*) (size_t *, const CUmulticastObjectProp *, CUmulticastGranularity_flags )) dlsym(RTLD_NEXT, "cuMulticastGetGranularity");
		tracer._kernel_map[(void *) lcuMulticastGetGranularity] = std::string("cuMulticastGetGranularity");
	}
	assert(lcuMulticastGetGranularity);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMulticastGetGranularity(granularity, prop, option);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMulticastGetGranularity);
	}
	return res;
}

CUresult cuPointerGetAttribute(void * data, CUpointer_attribute  attribute, CUdeviceptr  ptr)
{
	static CUresult (*lcuPointerGetAttribute) (void *, CUpointer_attribute , CUdeviceptr );
	if (!lcuPointerGetAttribute) {
		lcuPointerGetAttribute = (CUresult (*) (void *, CUpointer_attribute , CUdeviceptr )) dlsym(RTLD_NEXT, "cuPointerGetAttribute");
		tracer._kernel_map[(void *) lcuPointerGetAttribute] = std::string("cuPointerGetAttribute");
	}
	assert(lcuPointerGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuPointerGetAttribute(data, attribute, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuPointerGetAttribute);
	}
	return res;
}

CUresult cuMemPrefetchAsync(CUdeviceptr  devPtr, size_t  count, CUdevice  dstDevice, CUstream  hStream)
{
	static CUresult (*lcuMemPrefetchAsync) (CUdeviceptr , size_t , CUdevice , CUstream );
	if (!lcuMemPrefetchAsync) {
		lcuMemPrefetchAsync = (CUresult (*) (CUdeviceptr , size_t , CUdevice , CUstream )) dlsym(RTLD_NEXT, "cuMemPrefetchAsync");
		tracer._kernel_map[(void *) lcuMemPrefetchAsync] = std::string("cuMemPrefetchAsync");
	}
	assert(lcuMemPrefetchAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPrefetchAsync(devPtr, count, dstDevice, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPrefetchAsync);
	}
	return res;
}

CUresult cuMemPrefetchAsync_v2(CUdeviceptr  devPtr, size_t  count, CUmemLocation  location, unsigned int  flags, CUstream  hStream)
{
	static CUresult (*lcuMemPrefetchAsync_v2) (CUdeviceptr , size_t , CUmemLocation , unsigned int , CUstream );
	if (!lcuMemPrefetchAsync_v2) {
		lcuMemPrefetchAsync_v2 = (CUresult (*) (CUdeviceptr , size_t , CUmemLocation , unsigned int , CUstream )) dlsym(RTLD_NEXT, "cuMemPrefetchAsync_v2");
		tracer._kernel_map[(void *) lcuMemPrefetchAsync_v2] = std::string("cuMemPrefetchAsync_v2");
	}
	assert(lcuMemPrefetchAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemPrefetchAsync_v2(devPtr, count, location, flags, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemPrefetchAsync_v2);
	}
	return res;
}

CUresult cuMemAdvise(CUdeviceptr  devPtr, size_t  count, CUmem_advise  advice, CUdevice  device)
{
	static CUresult (*lcuMemAdvise) (CUdeviceptr , size_t , CUmem_advise , CUdevice );
	if (!lcuMemAdvise) {
		lcuMemAdvise = (CUresult (*) (CUdeviceptr , size_t , CUmem_advise , CUdevice )) dlsym(RTLD_NEXT, "cuMemAdvise");
		tracer._kernel_map[(void *) lcuMemAdvise] = std::string("cuMemAdvise");
	}
	assert(lcuMemAdvise);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAdvise(devPtr, count, advice, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAdvise);
	}
	return res;
}

CUresult cuMemAdvise_v2(CUdeviceptr  devPtr, size_t  count, CUmem_advise  advice, CUmemLocation  location)
{
	static CUresult (*lcuMemAdvise_v2) (CUdeviceptr , size_t , CUmem_advise , CUmemLocation );
	if (!lcuMemAdvise_v2) {
		lcuMemAdvise_v2 = (CUresult (*) (CUdeviceptr , size_t , CUmem_advise , CUmemLocation )) dlsym(RTLD_NEXT, "cuMemAdvise_v2");
		tracer._kernel_map[(void *) lcuMemAdvise_v2] = std::string("cuMemAdvise_v2");
	}
	assert(lcuMemAdvise_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemAdvise_v2(devPtr, count, advice, location);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemAdvise_v2);
	}
	return res;
}

CUresult cuMemRangeGetAttribute(void * data, size_t  dataSize, CUmem_range_attribute  attribute, CUdeviceptr  devPtr, size_t  count)
{
	static CUresult (*lcuMemRangeGetAttribute) (void *, size_t , CUmem_range_attribute , CUdeviceptr , size_t );
	if (!lcuMemRangeGetAttribute) {
		lcuMemRangeGetAttribute = (CUresult (*) (void *, size_t , CUmem_range_attribute , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemRangeGetAttribute");
		tracer._kernel_map[(void *) lcuMemRangeGetAttribute] = std::string("cuMemRangeGetAttribute");
	}
	assert(lcuMemRangeGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemRangeGetAttribute(data, dataSize, attribute, devPtr, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemRangeGetAttribute);
	}
	return res;
}

CUresult cuMemRangeGetAttributes(void ** data, size_t * dataSizes, CUmem_range_attribute * attributes, size_t  numAttributes, CUdeviceptr  devPtr, size_t  count)
{
	static CUresult (*lcuMemRangeGetAttributes) (void **, size_t *, CUmem_range_attribute *, size_t , CUdeviceptr , size_t );
	if (!lcuMemRangeGetAttributes) {
		lcuMemRangeGetAttributes = (CUresult (*) (void **, size_t *, CUmem_range_attribute *, size_t , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuMemRangeGetAttributes");
		tracer._kernel_map[(void *) lcuMemRangeGetAttributes] = std::string("cuMemRangeGetAttributes");
	}
	assert(lcuMemRangeGetAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuMemRangeGetAttributes(data, dataSizes, attributes, numAttributes, devPtr, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuMemRangeGetAttributes);
	}
	return res;
}

CUresult cuPointerSetAttribute(const void * value, CUpointer_attribute  attribute, CUdeviceptr  ptr)
{
	static CUresult (*lcuPointerSetAttribute) (const void *, CUpointer_attribute , CUdeviceptr );
	if (!lcuPointerSetAttribute) {
		lcuPointerSetAttribute = (CUresult (*) (const void *, CUpointer_attribute , CUdeviceptr )) dlsym(RTLD_NEXT, "cuPointerSetAttribute");
		tracer._kernel_map[(void *) lcuPointerSetAttribute] = std::string("cuPointerSetAttribute");
	}
	assert(lcuPointerSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuPointerSetAttribute(value, attribute, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuPointerSetAttribute);
	}
	return res;
}

CUresult cuPointerGetAttributes(unsigned int  numAttributes, CUpointer_attribute * attributes, void ** data, CUdeviceptr  ptr)
{
	static CUresult (*lcuPointerGetAttributes) (unsigned int , CUpointer_attribute *, void **, CUdeviceptr );
	if (!lcuPointerGetAttributes) {
		lcuPointerGetAttributes = (CUresult (*) (unsigned int , CUpointer_attribute *, void **, CUdeviceptr )) dlsym(RTLD_NEXT, "cuPointerGetAttributes");
		tracer._kernel_map[(void *) lcuPointerGetAttributes] = std::string("cuPointerGetAttributes");
	}
	assert(lcuPointerGetAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuPointerGetAttributes(numAttributes, attributes, data, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuPointerGetAttributes);
	}
	return res;
}

CUresult cuStreamCreate(CUstream * phStream, unsigned int  Flags)
{
	static CUresult (*lcuStreamCreate) (CUstream *, unsigned int );
	if (!lcuStreamCreate) {
		lcuStreamCreate = (CUresult (*) (CUstream *, unsigned int )) dlsym(RTLD_NEXT, "cuStreamCreate");
		tracer._kernel_map[(void *) lcuStreamCreate] = std::string("cuStreamCreate");
	}
	assert(lcuStreamCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamCreate(phStream, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamCreate);
	}
	return res;
}

CUresult cuStreamCreateWithPriority(CUstream * phStream, unsigned int  flags, int  priority)
{
	static CUresult (*lcuStreamCreateWithPriority) (CUstream *, unsigned int , int );
	if (!lcuStreamCreateWithPriority) {
		lcuStreamCreateWithPriority = (CUresult (*) (CUstream *, unsigned int , int )) dlsym(RTLD_NEXT, "cuStreamCreateWithPriority");
		tracer._kernel_map[(void *) lcuStreamCreateWithPriority] = std::string("cuStreamCreateWithPriority");
	}
	assert(lcuStreamCreateWithPriority);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamCreateWithPriority(phStream, flags, priority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamCreateWithPriority);
	}
	return res;
}

CUresult cuStreamGetPriority(CUstream  hStream, int * priority)
{
	static CUresult (*lcuStreamGetPriority) (CUstream , int *);
	if (!lcuStreamGetPriority) {
		lcuStreamGetPriority = (CUresult (*) (CUstream , int *)) dlsym(RTLD_NEXT, "cuStreamGetPriority");
		tracer._kernel_map[(void *) lcuStreamGetPriority] = std::string("cuStreamGetPriority");
	}
	assert(lcuStreamGetPriority);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetPriority(hStream, priority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetPriority);
	}
	return res;
}

CUresult cuStreamGetFlags(CUstream  hStream, unsigned int * flags)
{
	static CUresult (*lcuStreamGetFlags) (CUstream , unsigned int *);
	if (!lcuStreamGetFlags) {
		lcuStreamGetFlags = (CUresult (*) (CUstream , unsigned int *)) dlsym(RTLD_NEXT, "cuStreamGetFlags");
		tracer._kernel_map[(void *) lcuStreamGetFlags] = std::string("cuStreamGetFlags");
	}
	assert(lcuStreamGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetFlags(hStream, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetFlags);
	}
	return res;
}

CUresult cuStreamGetId(CUstream  hStream, unsigned long long * streamId)
{
	static CUresult (*lcuStreamGetId) (CUstream , unsigned long long *);
	if (!lcuStreamGetId) {
		lcuStreamGetId = (CUresult (*) (CUstream , unsigned long long *)) dlsym(RTLD_NEXT, "cuStreamGetId");
		tracer._kernel_map[(void *) lcuStreamGetId] = std::string("cuStreamGetId");
	}
	assert(lcuStreamGetId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetId(hStream, streamId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetId);
	}
	return res;
}

CUresult cuStreamGetCtx(CUstream  hStream, CUcontext * pctx)
{
	static CUresult (*lcuStreamGetCtx) (CUstream , CUcontext *);
	if (!lcuStreamGetCtx) {
		lcuStreamGetCtx = (CUresult (*) (CUstream , CUcontext *)) dlsym(RTLD_NEXT, "cuStreamGetCtx");
		tracer._kernel_map[(void *) lcuStreamGetCtx] = std::string("cuStreamGetCtx");
	}
	assert(lcuStreamGetCtx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetCtx(hStream, pctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetCtx);
	}
	return res;
}

CUresult cuStreamWaitEvent(CUstream  hStream, CUevent  hEvent, unsigned int  Flags)
{
	static CUresult (*lcuStreamWaitEvent) (CUstream , CUevent , unsigned int );
	if (!lcuStreamWaitEvent) {
		lcuStreamWaitEvent = (CUresult (*) (CUstream , CUevent , unsigned int )) dlsym(RTLD_NEXT, "cuStreamWaitEvent");
		tracer._kernel_map[(void *) lcuStreamWaitEvent] = std::string("cuStreamWaitEvent");
	}
	assert(lcuStreamWaitEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamWaitEvent(hStream, hEvent, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamWaitEvent);
	}
	return res;
}

CUresult cuStreamAddCallback(CUstream  hStream, CUstreamCallback  callback, void * userData, unsigned int  flags)
{
	static CUresult (*lcuStreamAddCallback) (CUstream , CUstreamCallback , void *, unsigned int );
	if (!lcuStreamAddCallback) {
		lcuStreamAddCallback = (CUresult (*) (CUstream , CUstreamCallback , void *, unsigned int )) dlsym(RTLD_NEXT, "cuStreamAddCallback");
		tracer._kernel_map[(void *) lcuStreamAddCallback] = std::string("cuStreamAddCallback");
	}
	assert(lcuStreamAddCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamAddCallback(hStream, callback, userData, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamAddCallback);
	}
	return res;
}

CUresult cuStreamBeginCapture_v2(CUstream  hStream, CUstreamCaptureMode  mode)
{
	static CUresult (*lcuStreamBeginCapture_v2) (CUstream , CUstreamCaptureMode );
	if (!lcuStreamBeginCapture_v2) {
		lcuStreamBeginCapture_v2 = (CUresult (*) (CUstream , CUstreamCaptureMode )) dlsym(RTLD_NEXT, "cuStreamBeginCapture_v2");
		tracer._kernel_map[(void *) lcuStreamBeginCapture_v2] = std::string("cuStreamBeginCapture_v2");
	}
	assert(lcuStreamBeginCapture_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamBeginCapture_v2(hStream, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamBeginCapture_v2);
	}
	return res;
}

CUresult cuThreadExchangeStreamCaptureMode(CUstreamCaptureMode * mode)
{
	static CUresult (*lcuThreadExchangeStreamCaptureMode) (CUstreamCaptureMode *);
	if (!lcuThreadExchangeStreamCaptureMode) {
		lcuThreadExchangeStreamCaptureMode = (CUresult (*) (CUstreamCaptureMode *)) dlsym(RTLD_NEXT, "cuThreadExchangeStreamCaptureMode");
		tracer._kernel_map[(void *) lcuThreadExchangeStreamCaptureMode] = std::string("cuThreadExchangeStreamCaptureMode");
	}
	assert(lcuThreadExchangeStreamCaptureMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuThreadExchangeStreamCaptureMode(mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuThreadExchangeStreamCaptureMode);
	}
	return res;
}

CUresult cuStreamEndCapture(CUstream  hStream, CUgraph * phGraph)
{
	static CUresult (*lcuStreamEndCapture) (CUstream , CUgraph *);
	if (!lcuStreamEndCapture) {
		lcuStreamEndCapture = (CUresult (*) (CUstream , CUgraph *)) dlsym(RTLD_NEXT, "cuStreamEndCapture");
		tracer._kernel_map[(void *) lcuStreamEndCapture] = std::string("cuStreamEndCapture");
	}
	assert(lcuStreamEndCapture);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamEndCapture(hStream, phGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamEndCapture);
	}
	return res;
}

CUresult cuStreamIsCapturing(CUstream  hStream, CUstreamCaptureStatus * captureStatus)
{
	static CUresult (*lcuStreamIsCapturing) (CUstream , CUstreamCaptureStatus *);
	if (!lcuStreamIsCapturing) {
		lcuStreamIsCapturing = (CUresult (*) (CUstream , CUstreamCaptureStatus *)) dlsym(RTLD_NEXT, "cuStreamIsCapturing");
		tracer._kernel_map[(void *) lcuStreamIsCapturing] = std::string("cuStreamIsCapturing");
	}
	assert(lcuStreamIsCapturing);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamIsCapturing(hStream, captureStatus);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamIsCapturing);
	}
	return res;
}

CUresult cuStreamGetCaptureInfo_v2(CUstream  hStream, CUstreamCaptureStatus * captureStatus_out, cuuint64_t * id_out, CUgraph * graph_out, const CUgraphNode ** dependencies_out, size_t * numDependencies_out)
{
	static CUresult (*lcuStreamGetCaptureInfo_v2) (CUstream , CUstreamCaptureStatus *, cuuint64_t *, CUgraph *, const CUgraphNode **, size_t *);
	if (!lcuStreamGetCaptureInfo_v2) {
		lcuStreamGetCaptureInfo_v2 = (CUresult (*) (CUstream , CUstreamCaptureStatus *, cuuint64_t *, CUgraph *, const CUgraphNode **, size_t *)) dlsym(RTLD_NEXT, "cuStreamGetCaptureInfo_v2");
		tracer._kernel_map[(void *) lcuStreamGetCaptureInfo_v2] = std::string("cuStreamGetCaptureInfo_v2");
	}
	assert(lcuStreamGetCaptureInfo_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetCaptureInfo_v2(hStream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetCaptureInfo_v2);
	}
	return res;
}

CUresult cuStreamUpdateCaptureDependencies(CUstream  hStream, CUgraphNode * dependencies, size_t  numDependencies, unsigned int  flags)
{
	static CUresult (*lcuStreamUpdateCaptureDependencies) (CUstream , CUgraphNode *, size_t , unsigned int );
	if (!lcuStreamUpdateCaptureDependencies) {
		lcuStreamUpdateCaptureDependencies = (CUresult (*) (CUstream , CUgraphNode *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamUpdateCaptureDependencies");
		tracer._kernel_map[(void *) lcuStreamUpdateCaptureDependencies] = std::string("cuStreamUpdateCaptureDependencies");
	}
	assert(lcuStreamUpdateCaptureDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamUpdateCaptureDependencies(hStream, dependencies, numDependencies, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamUpdateCaptureDependencies);
	}
	return res;
}

CUresult cuStreamAttachMemAsync(CUstream  hStream, CUdeviceptr  dptr, size_t  length, unsigned int  flags)
{
	static CUresult (*lcuStreamAttachMemAsync) (CUstream , CUdeviceptr , size_t , unsigned int );
	if (!lcuStreamAttachMemAsync) {
		lcuStreamAttachMemAsync = (CUresult (*) (CUstream , CUdeviceptr , size_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamAttachMemAsync");
		tracer._kernel_map[(void *) lcuStreamAttachMemAsync] = std::string("cuStreamAttachMemAsync");
	}
	assert(lcuStreamAttachMemAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamAttachMemAsync(hStream, dptr, length, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamAttachMemAsync);
	}
	return res;
}

CUresult cuStreamQuery(CUstream  hStream)
{
	static CUresult (*lcuStreamQuery) (CUstream );
	if (!lcuStreamQuery) {
		lcuStreamQuery = (CUresult (*) (CUstream )) dlsym(RTLD_NEXT, "cuStreamQuery");
		tracer._kernel_map[(void *) lcuStreamQuery] = std::string("cuStreamQuery");
	}
	assert(lcuStreamQuery);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamQuery(hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamQuery);
	}
	return res;
}

CUresult cuStreamSynchronize(CUstream  hStream)
{
	static CUresult (*lcuStreamSynchronize) (CUstream );
	if (!lcuStreamSynchronize) {
		lcuStreamSynchronize = (CUresult (*) (CUstream )) dlsym(RTLD_NEXT, "cuStreamSynchronize");
		tracer._kernel_map[(void *) lcuStreamSynchronize] = std::string("cuStreamSynchronize");
	}
	assert(lcuStreamSynchronize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamSynchronize(hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamSynchronize);
	}
	return res;
}

CUresult cuStreamDestroy_v2(CUstream  hStream)
{
	static CUresult (*lcuStreamDestroy_v2) (CUstream );
	if (!lcuStreamDestroy_v2) {
		lcuStreamDestroy_v2 = (CUresult (*) (CUstream )) dlsym(RTLD_NEXT, "cuStreamDestroy_v2");
		tracer._kernel_map[(void *) lcuStreamDestroy_v2] = std::string("cuStreamDestroy_v2");
	}
	assert(lcuStreamDestroy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamDestroy_v2(hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamDestroy_v2);
	}
	return res;
}

CUresult cuStreamCopyAttributes(CUstream  dst, CUstream  src)
{
	static CUresult (*lcuStreamCopyAttributes) (CUstream , CUstream );
	if (!lcuStreamCopyAttributes) {
		lcuStreamCopyAttributes = (CUresult (*) (CUstream , CUstream )) dlsym(RTLD_NEXT, "cuStreamCopyAttributes");
		tracer._kernel_map[(void *) lcuStreamCopyAttributes] = std::string("cuStreamCopyAttributes");
	}
	assert(lcuStreamCopyAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamCopyAttributes(dst, src);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamCopyAttributes);
	}
	return res;
}

CUresult cuStreamGetAttribute(CUstream  hStream, CUstreamAttrID  attr, CUstreamAttrValue * value_out)
{
	static CUresult (*lcuStreamGetAttribute) (CUstream , CUstreamAttrID , CUstreamAttrValue *);
	if (!lcuStreamGetAttribute) {
		lcuStreamGetAttribute = (CUresult (*) (CUstream , CUstreamAttrID , CUstreamAttrValue *)) dlsym(RTLD_NEXT, "cuStreamGetAttribute");
		tracer._kernel_map[(void *) lcuStreamGetAttribute] = std::string("cuStreamGetAttribute");
	}
	assert(lcuStreamGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamGetAttribute(hStream, attr, value_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamGetAttribute);
	}
	return res;
}

CUresult cuStreamSetAttribute(CUstream  hStream, CUstreamAttrID  attr, const CUstreamAttrValue * value)
{
	static CUresult (*lcuStreamSetAttribute) (CUstream , CUstreamAttrID , const CUstreamAttrValue *);
	if (!lcuStreamSetAttribute) {
		lcuStreamSetAttribute = (CUresult (*) (CUstream , CUstreamAttrID , const CUstreamAttrValue *)) dlsym(RTLD_NEXT, "cuStreamSetAttribute");
		tracer._kernel_map[(void *) lcuStreamSetAttribute] = std::string("cuStreamSetAttribute");
	}
	assert(lcuStreamSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamSetAttribute(hStream, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamSetAttribute);
	}
	return res;
}

CUresult cuEventCreate(CUevent * phEvent, unsigned int  Flags)
{
	static CUresult (*lcuEventCreate) (CUevent *, unsigned int );
	if (!lcuEventCreate) {
		lcuEventCreate = (CUresult (*) (CUevent *, unsigned int )) dlsym(RTLD_NEXT, "cuEventCreate");
		tracer._kernel_map[(void *) lcuEventCreate] = std::string("cuEventCreate");
	}
	assert(lcuEventCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventCreate(phEvent, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventCreate);
	}
	return res;
}

CUresult cuEventRecord(CUevent  hEvent, CUstream  hStream)
{
	static CUresult (*lcuEventRecord) (CUevent , CUstream );
	if (!lcuEventRecord) {
		lcuEventRecord = (CUresult (*) (CUevent , CUstream )) dlsym(RTLD_NEXT, "cuEventRecord");
		tracer._kernel_map[(void *) lcuEventRecord] = std::string("cuEventRecord");
	}
	assert(lcuEventRecord);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventRecord(hEvent, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventRecord);
	}
	return res;
}

CUresult cuEventRecordWithFlags(CUevent  hEvent, CUstream  hStream, unsigned int  flags)
{
	static CUresult (*lcuEventRecordWithFlags) (CUevent , CUstream , unsigned int );
	if (!lcuEventRecordWithFlags) {
		lcuEventRecordWithFlags = (CUresult (*) (CUevent , CUstream , unsigned int )) dlsym(RTLD_NEXT, "cuEventRecordWithFlags");
		tracer._kernel_map[(void *) lcuEventRecordWithFlags] = std::string("cuEventRecordWithFlags");
	}
	assert(lcuEventRecordWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventRecordWithFlags(hEvent, hStream, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventRecordWithFlags);
	}
	return res;
}

CUresult cuEventQuery(CUevent  hEvent)
{
	static CUresult (*lcuEventQuery) (CUevent );
	if (!lcuEventQuery) {
		lcuEventQuery = (CUresult (*) (CUevent )) dlsym(RTLD_NEXT, "cuEventQuery");
		tracer._kernel_map[(void *) lcuEventQuery] = std::string("cuEventQuery");
	}
	assert(lcuEventQuery);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventQuery(hEvent);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventQuery);
	}
	return res;
}

CUresult cuEventSynchronize(CUevent  hEvent)
{
	static CUresult (*lcuEventSynchronize) (CUevent );
	if (!lcuEventSynchronize) {
		lcuEventSynchronize = (CUresult (*) (CUevent )) dlsym(RTLD_NEXT, "cuEventSynchronize");
		tracer._kernel_map[(void *) lcuEventSynchronize] = std::string("cuEventSynchronize");
	}
	assert(lcuEventSynchronize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventSynchronize(hEvent);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventSynchronize);
	}
	return res;
}

CUresult cuEventDestroy_v2(CUevent  hEvent)
{
	static CUresult (*lcuEventDestroy_v2) (CUevent );
	if (!lcuEventDestroy_v2) {
		lcuEventDestroy_v2 = (CUresult (*) (CUevent )) dlsym(RTLD_NEXT, "cuEventDestroy_v2");
		tracer._kernel_map[(void *) lcuEventDestroy_v2] = std::string("cuEventDestroy_v2");
	}
	assert(lcuEventDestroy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventDestroy_v2(hEvent);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventDestroy_v2);
	}
	return res;
}

CUresult cuEventElapsedTime(float * pMilliseconds, CUevent  hStart, CUevent  hEnd)
{
	static CUresult (*lcuEventElapsedTime) (float *, CUevent , CUevent );
	if (!lcuEventElapsedTime) {
		lcuEventElapsedTime = (CUresult (*) (float *, CUevent , CUevent )) dlsym(RTLD_NEXT, "cuEventElapsedTime");
		tracer._kernel_map[(void *) lcuEventElapsedTime] = std::string("cuEventElapsedTime");
	}
	assert(lcuEventElapsedTime);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuEventElapsedTime(pMilliseconds, hStart, hEnd);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuEventElapsedTime);
	}
	return res;
}

CUresult cuImportExternalMemory(CUexternalMemory * extMem_out, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC * memHandleDesc)
{
	static CUresult (*lcuImportExternalMemory) (CUexternalMemory *, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC *);
	if (!lcuImportExternalMemory) {
		lcuImportExternalMemory = (CUresult (*) (CUexternalMemory *, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC *)) dlsym(RTLD_NEXT, "cuImportExternalMemory");
		tracer._kernel_map[(void *) lcuImportExternalMemory] = std::string("cuImportExternalMemory");
	}
	assert(lcuImportExternalMemory);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuImportExternalMemory(extMem_out, memHandleDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuImportExternalMemory);
	}
	return res;
}

CUresult cuExternalMemoryGetMappedBuffer(CUdeviceptr * devPtr, CUexternalMemory  extMem, const CUDA_EXTERNAL_MEMORY_BUFFER_DESC * bufferDesc)
{
	static CUresult (*lcuExternalMemoryGetMappedBuffer) (CUdeviceptr *, CUexternalMemory , const CUDA_EXTERNAL_MEMORY_BUFFER_DESC *);
	if (!lcuExternalMemoryGetMappedBuffer) {
		lcuExternalMemoryGetMappedBuffer = (CUresult (*) (CUdeviceptr *, CUexternalMemory , const CUDA_EXTERNAL_MEMORY_BUFFER_DESC *)) dlsym(RTLD_NEXT, "cuExternalMemoryGetMappedBuffer");
		tracer._kernel_map[(void *) lcuExternalMemoryGetMappedBuffer] = std::string("cuExternalMemoryGetMappedBuffer");
	}
	assert(lcuExternalMemoryGetMappedBuffer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuExternalMemoryGetMappedBuffer(devPtr, extMem, bufferDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuExternalMemoryGetMappedBuffer);
	}
	return res;
}

CUresult cuExternalMemoryGetMappedMipmappedArray(CUmipmappedArray * mipmap, CUexternalMemory  extMem, const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC * mipmapDesc)
{
	static CUresult (*lcuExternalMemoryGetMappedMipmappedArray) (CUmipmappedArray *, CUexternalMemory , const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC *);
	if (!lcuExternalMemoryGetMappedMipmappedArray) {
		lcuExternalMemoryGetMappedMipmappedArray = (CUresult (*) (CUmipmappedArray *, CUexternalMemory , const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC *)) dlsym(RTLD_NEXT, "cuExternalMemoryGetMappedMipmappedArray");
		tracer._kernel_map[(void *) lcuExternalMemoryGetMappedMipmappedArray] = std::string("cuExternalMemoryGetMappedMipmappedArray");
	}
	assert(lcuExternalMemoryGetMappedMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuExternalMemoryGetMappedMipmappedArray(mipmap, extMem, mipmapDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuExternalMemoryGetMappedMipmappedArray);
	}
	return res;
}

CUresult cuDestroyExternalMemory(CUexternalMemory  extMem)
{
	static CUresult (*lcuDestroyExternalMemory) (CUexternalMemory );
	if (!lcuDestroyExternalMemory) {
		lcuDestroyExternalMemory = (CUresult (*) (CUexternalMemory )) dlsym(RTLD_NEXT, "cuDestroyExternalMemory");
		tracer._kernel_map[(void *) lcuDestroyExternalMemory] = std::string("cuDestroyExternalMemory");
	}
	assert(lcuDestroyExternalMemory);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDestroyExternalMemory(extMem);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDestroyExternalMemory);
	}
	return res;
}

CUresult cuImportExternalSemaphore(CUexternalSemaphore * extSem_out, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC * semHandleDesc)
{
	static CUresult (*lcuImportExternalSemaphore) (CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC *);
	if (!lcuImportExternalSemaphore) {
		lcuImportExternalSemaphore = (CUresult (*) (CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC *)) dlsym(RTLD_NEXT, "cuImportExternalSemaphore");
		tracer._kernel_map[(void *) lcuImportExternalSemaphore] = std::string("cuImportExternalSemaphore");
	}
	assert(lcuImportExternalSemaphore);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuImportExternalSemaphore(extSem_out, semHandleDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuImportExternalSemaphore);
	}
	return res;
}

CUresult cuSignalExternalSemaphoresAsync(const CUexternalSemaphore * extSemArray, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS * paramsArray, unsigned int  numExtSems, CUstream  stream)
{
	static CUresult (*lcuSignalExternalSemaphoresAsync) (const CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *, unsigned int , CUstream );
	if (!lcuSignalExternalSemaphoresAsync) {
		lcuSignalExternalSemaphoresAsync = (CUresult (*) (const CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *, unsigned int , CUstream )) dlsym(RTLD_NEXT, "cuSignalExternalSemaphoresAsync");
		tracer._kernel_map[(void *) lcuSignalExternalSemaphoresAsync] = std::string("cuSignalExternalSemaphoresAsync");
	}
	assert(lcuSignalExternalSemaphoresAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSignalExternalSemaphoresAsync(extSemArray, paramsArray, numExtSems, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSignalExternalSemaphoresAsync);
	}
	return res;
}

CUresult cuWaitExternalSemaphoresAsync(const CUexternalSemaphore * extSemArray, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS * paramsArray, unsigned int  numExtSems, CUstream  stream)
{
	static CUresult (*lcuWaitExternalSemaphoresAsync) (const CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *, unsigned int , CUstream );
	if (!lcuWaitExternalSemaphoresAsync) {
		lcuWaitExternalSemaphoresAsync = (CUresult (*) (const CUexternalSemaphore *, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *, unsigned int , CUstream )) dlsym(RTLD_NEXT, "cuWaitExternalSemaphoresAsync");
		tracer._kernel_map[(void *) lcuWaitExternalSemaphoresAsync] = std::string("cuWaitExternalSemaphoresAsync");
	}
	assert(lcuWaitExternalSemaphoresAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuWaitExternalSemaphoresAsync(extSemArray, paramsArray, numExtSems, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuWaitExternalSemaphoresAsync);
	}
	return res;
}

CUresult cuDestroyExternalSemaphore(CUexternalSemaphore  extSem)
{
	static CUresult (*lcuDestroyExternalSemaphore) (CUexternalSemaphore );
	if (!lcuDestroyExternalSemaphore) {
		lcuDestroyExternalSemaphore = (CUresult (*) (CUexternalSemaphore )) dlsym(RTLD_NEXT, "cuDestroyExternalSemaphore");
		tracer._kernel_map[(void *) lcuDestroyExternalSemaphore] = std::string("cuDestroyExternalSemaphore");
	}
	assert(lcuDestroyExternalSemaphore);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDestroyExternalSemaphore(extSem);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDestroyExternalSemaphore);
	}
	return res;
}

CUresult cuStreamWaitValue32_v2(CUstream  stream, CUdeviceptr  addr, cuuint32_t  value, unsigned int  flags)
{
	static CUresult (*lcuStreamWaitValue32_v2) (CUstream , CUdeviceptr , cuuint32_t , unsigned int );
	if (!lcuStreamWaitValue32_v2) {
		lcuStreamWaitValue32_v2 = (CUresult (*) (CUstream , CUdeviceptr , cuuint32_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamWaitValue32_v2");
		tracer._kernel_map[(void *) lcuStreamWaitValue32_v2] = std::string("cuStreamWaitValue32_v2");
	}
	assert(lcuStreamWaitValue32_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamWaitValue32_v2(stream, addr, value, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamWaitValue32_v2);
	}
	return res;
}

CUresult cuStreamWaitValue64_v2(CUstream  stream, CUdeviceptr  addr, cuuint64_t  value, unsigned int  flags)
{
	static CUresult (*lcuStreamWaitValue64_v2) (CUstream , CUdeviceptr , cuuint64_t , unsigned int );
	if (!lcuStreamWaitValue64_v2) {
		lcuStreamWaitValue64_v2 = (CUresult (*) (CUstream , CUdeviceptr , cuuint64_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamWaitValue64_v2");
		tracer._kernel_map[(void *) lcuStreamWaitValue64_v2] = std::string("cuStreamWaitValue64_v2");
	}
	assert(lcuStreamWaitValue64_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamWaitValue64_v2(stream, addr, value, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamWaitValue64_v2);
	}
	return res;
}

CUresult cuStreamWriteValue32_v2(CUstream  stream, CUdeviceptr  addr, cuuint32_t  value, unsigned int  flags)
{
	static CUresult (*lcuStreamWriteValue32_v2) (CUstream , CUdeviceptr , cuuint32_t , unsigned int );
	if (!lcuStreamWriteValue32_v2) {
		lcuStreamWriteValue32_v2 = (CUresult (*) (CUstream , CUdeviceptr , cuuint32_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamWriteValue32_v2");
		tracer._kernel_map[(void *) lcuStreamWriteValue32_v2] = std::string("cuStreamWriteValue32_v2");
	}
	assert(lcuStreamWriteValue32_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamWriteValue32_v2(stream, addr, value, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamWriteValue32_v2);
	}
	return res;
}

CUresult cuStreamWriteValue64_v2(CUstream  stream, CUdeviceptr  addr, cuuint64_t  value, unsigned int  flags)
{
	static CUresult (*lcuStreamWriteValue64_v2) (CUstream , CUdeviceptr , cuuint64_t , unsigned int );
	if (!lcuStreamWriteValue64_v2) {
		lcuStreamWriteValue64_v2 = (CUresult (*) (CUstream , CUdeviceptr , cuuint64_t , unsigned int )) dlsym(RTLD_NEXT, "cuStreamWriteValue64_v2");
		tracer._kernel_map[(void *) lcuStreamWriteValue64_v2] = std::string("cuStreamWriteValue64_v2");
	}
	assert(lcuStreamWriteValue64_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamWriteValue64_v2(stream, addr, value, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamWriteValue64_v2);
	}
	return res;
}

CUresult cuStreamBatchMemOp_v2(CUstream  stream, unsigned int  count, CUstreamBatchMemOpParams * paramArray, unsigned int  flags)
{
	static CUresult (*lcuStreamBatchMemOp_v2) (CUstream , unsigned int , CUstreamBatchMemOpParams *, unsigned int );
	if (!lcuStreamBatchMemOp_v2) {
		lcuStreamBatchMemOp_v2 = (CUresult (*) (CUstream , unsigned int , CUstreamBatchMemOpParams *, unsigned int )) dlsym(RTLD_NEXT, "cuStreamBatchMemOp_v2");
		tracer._kernel_map[(void *) lcuStreamBatchMemOp_v2] = std::string("cuStreamBatchMemOp_v2");
	}
	assert(lcuStreamBatchMemOp_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuStreamBatchMemOp_v2(stream, count, paramArray, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuStreamBatchMemOp_v2);
	}
	return res;
}

CUresult cuFuncGetAttribute(int * pi, CUfunction_attribute  attrib, CUfunction  hfunc)
{
	static CUresult (*lcuFuncGetAttribute) (int *, CUfunction_attribute , CUfunction );
	if (!lcuFuncGetAttribute) {
		lcuFuncGetAttribute = (CUresult (*) (int *, CUfunction_attribute , CUfunction )) dlsym(RTLD_NEXT, "cuFuncGetAttribute");
		tracer._kernel_map[(void *) lcuFuncGetAttribute] = std::string("cuFuncGetAttribute");
	}
	assert(lcuFuncGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncGetAttribute(pi, attrib, hfunc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncGetAttribute);
	}
	return res;
}

CUresult cuFuncSetAttribute(CUfunction  hfunc, CUfunction_attribute  attrib, int  value)
{
	static CUresult (*lcuFuncSetAttribute) (CUfunction , CUfunction_attribute , int );
	if (!lcuFuncSetAttribute) {
		lcuFuncSetAttribute = (CUresult (*) (CUfunction , CUfunction_attribute , int )) dlsym(RTLD_NEXT, "cuFuncSetAttribute");
		tracer._kernel_map[(void *) lcuFuncSetAttribute] = std::string("cuFuncSetAttribute");
	}
	assert(lcuFuncSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncSetAttribute(hfunc, attrib, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncSetAttribute);
	}
	return res;
}

CUresult cuFuncSetCacheConfig(CUfunction  hfunc, CUfunc_cache  config)
{
	static CUresult (*lcuFuncSetCacheConfig) (CUfunction , CUfunc_cache );
	if (!lcuFuncSetCacheConfig) {
		lcuFuncSetCacheConfig = (CUresult (*) (CUfunction , CUfunc_cache )) dlsym(RTLD_NEXT, "cuFuncSetCacheConfig");
		tracer._kernel_map[(void *) lcuFuncSetCacheConfig] = std::string("cuFuncSetCacheConfig");
	}
	assert(lcuFuncSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncSetCacheConfig(hfunc, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncSetCacheConfig);
	}
	return res;
}

CUresult cuFuncSetSharedMemConfig(CUfunction  hfunc, CUsharedconfig  config)
{
	static CUresult (*lcuFuncSetSharedMemConfig) (CUfunction , CUsharedconfig );
	if (!lcuFuncSetSharedMemConfig) {
		lcuFuncSetSharedMemConfig = (CUresult (*) (CUfunction , CUsharedconfig )) dlsym(RTLD_NEXT, "cuFuncSetSharedMemConfig");
		tracer._kernel_map[(void *) lcuFuncSetSharedMemConfig] = std::string("cuFuncSetSharedMemConfig");
	}
	assert(lcuFuncSetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncSetSharedMemConfig(hfunc, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncSetSharedMemConfig);
	}
	return res;
}

CUresult cuFuncGetModule(CUmodule * hmod, CUfunction  hfunc)
{
	static CUresult (*lcuFuncGetModule) (CUmodule *, CUfunction );
	if (!lcuFuncGetModule) {
		lcuFuncGetModule = (CUresult (*) (CUmodule *, CUfunction )) dlsym(RTLD_NEXT, "cuFuncGetModule");
		tracer._kernel_map[(void *) lcuFuncGetModule] = std::string("cuFuncGetModule");
	}
	assert(lcuFuncGetModule);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncGetModule(hmod, hfunc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncGetModule);
	}
	return res;
}

CUresult cuLaunchKernel(CUfunction  f, unsigned int  gridDimX, unsigned int  gridDimY, unsigned int  gridDimZ, unsigned int  blockDimX, unsigned int  blockDimY, unsigned int  blockDimZ, unsigned int  sharedMemBytes, CUstream  hStream, void ** kernelParams, void ** extra)
{
	static CUresult (*lcuLaunchKernel) (CUfunction , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , CUstream , void **, void **);
	if (!lcuLaunchKernel) {
		lcuLaunchKernel = (CUresult (*) (CUfunction , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , CUstream , void **, void **)) dlsym(RTLD_NEXT, "cuLaunchKernel");
		tracer._kernel_map[(void *) lcuLaunchKernel] = std::string("cuLaunchKernel");
	}
	assert(lcuLaunchKernel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams, extra);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchKernel);
	}
	return res;
}

CUresult cuLaunchKernelEx(const CUlaunchConfig * config, CUfunction  f, void ** kernelParams, void ** extra)
{
	static CUresult (*lcuLaunchKernelEx) (const CUlaunchConfig *, CUfunction , void **, void **);
	if (!lcuLaunchKernelEx) {
		lcuLaunchKernelEx = (CUresult (*) (const CUlaunchConfig *, CUfunction , void **, void **)) dlsym(RTLD_NEXT, "cuLaunchKernelEx");
		tracer._kernel_map[(void *) lcuLaunchKernelEx] = std::string("cuLaunchKernelEx");
	}
	assert(lcuLaunchKernelEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchKernelEx(config, f, kernelParams, extra);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchKernelEx);
	}
	return res;
}

CUresult cuLaunchCooperativeKernel(CUfunction  f, unsigned int  gridDimX, unsigned int  gridDimY, unsigned int  gridDimZ, unsigned int  blockDimX, unsigned int  blockDimY, unsigned int  blockDimZ, unsigned int  sharedMemBytes, CUstream  hStream, void ** kernelParams)
{
	static CUresult (*lcuLaunchCooperativeKernel) (CUfunction , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , CUstream , void **);
	if (!lcuLaunchCooperativeKernel) {
		lcuLaunchCooperativeKernel = (CUresult (*) (CUfunction , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , CUstream , void **)) dlsym(RTLD_NEXT, "cuLaunchCooperativeKernel");
		tracer._kernel_map[(void *) lcuLaunchCooperativeKernel] = std::string("cuLaunchCooperativeKernel");
	}
	assert(lcuLaunchCooperativeKernel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchCooperativeKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchCooperativeKernel);
	}
	return res;
}

CUresult cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS * launchParamsList, unsigned int  numDevices, unsigned int  flags)
{
	static CUresult (*lcuLaunchCooperativeKernelMultiDevice) (CUDA_LAUNCH_PARAMS *, unsigned int , unsigned int );
	if (!lcuLaunchCooperativeKernelMultiDevice) {
		lcuLaunchCooperativeKernelMultiDevice = (CUresult (*) (CUDA_LAUNCH_PARAMS *, unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cuLaunchCooperativeKernelMultiDevice");
		tracer._kernel_map[(void *) lcuLaunchCooperativeKernelMultiDevice] = std::string("cuLaunchCooperativeKernelMultiDevice");
	}
	assert(lcuLaunchCooperativeKernelMultiDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchCooperativeKernelMultiDevice(launchParamsList, numDevices, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchCooperativeKernelMultiDevice);
	}
	return res;
}

CUresult cuLaunchHostFunc(CUstream  hStream, CUhostFn  fn, void * userData)
{
	static CUresult (*lcuLaunchHostFunc) (CUstream , CUhostFn , void *);
	if (!lcuLaunchHostFunc) {
		lcuLaunchHostFunc = (CUresult (*) (CUstream , CUhostFn , void *)) dlsym(RTLD_NEXT, "cuLaunchHostFunc");
		tracer._kernel_map[(void *) lcuLaunchHostFunc] = std::string("cuLaunchHostFunc");
	}
	assert(lcuLaunchHostFunc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchHostFunc(hStream, fn, userData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchHostFunc);
	}
	return res;
}

CUresult cuFuncSetBlockShape(CUfunction  hfunc, int  x, int  y, int  z)
{
	static CUresult (*lcuFuncSetBlockShape) (CUfunction , int , int , int );
	if (!lcuFuncSetBlockShape) {
		lcuFuncSetBlockShape = (CUresult (*) (CUfunction , int , int , int )) dlsym(RTLD_NEXT, "cuFuncSetBlockShape");
		tracer._kernel_map[(void *) lcuFuncSetBlockShape] = std::string("cuFuncSetBlockShape");
	}
	assert(lcuFuncSetBlockShape);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncSetBlockShape(hfunc, x, y, z);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncSetBlockShape);
	}
	return res;
}

CUresult cuFuncSetSharedSize(CUfunction  hfunc, unsigned int  bytes)
{
	static CUresult (*lcuFuncSetSharedSize) (CUfunction , unsigned int );
	if (!lcuFuncSetSharedSize) {
		lcuFuncSetSharedSize = (CUresult (*) (CUfunction , unsigned int )) dlsym(RTLD_NEXT, "cuFuncSetSharedSize");
		tracer._kernel_map[(void *) lcuFuncSetSharedSize] = std::string("cuFuncSetSharedSize");
	}
	assert(lcuFuncSetSharedSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuFuncSetSharedSize(hfunc, bytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuFuncSetSharedSize);
	}
	return res;
}

CUresult cuParamSetSize(CUfunction  hfunc, unsigned int  numbytes)
{
	static CUresult (*lcuParamSetSize) (CUfunction , unsigned int );
	if (!lcuParamSetSize) {
		lcuParamSetSize = (CUresult (*) (CUfunction , unsigned int )) dlsym(RTLD_NEXT, "cuParamSetSize");
		tracer._kernel_map[(void *) lcuParamSetSize] = std::string("cuParamSetSize");
	}
	assert(lcuParamSetSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuParamSetSize(hfunc, numbytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuParamSetSize);
	}
	return res;
}

CUresult cuParamSeti(CUfunction  hfunc, int  offset, unsigned int  value)
{
	static CUresult (*lcuParamSeti) (CUfunction , int , unsigned int );
	if (!lcuParamSeti) {
		lcuParamSeti = (CUresult (*) (CUfunction , int , unsigned int )) dlsym(RTLD_NEXT, "cuParamSeti");
		tracer._kernel_map[(void *) lcuParamSeti] = std::string("cuParamSeti");
	}
	assert(lcuParamSeti);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuParamSeti(hfunc, offset, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuParamSeti);
	}
	return res;
}

CUresult cuParamSetf(CUfunction  hfunc, int  offset, float  value)
{
	static CUresult (*lcuParamSetf) (CUfunction , int , float );
	if (!lcuParamSetf) {
		lcuParamSetf = (CUresult (*) (CUfunction , int , float )) dlsym(RTLD_NEXT, "cuParamSetf");
		tracer._kernel_map[(void *) lcuParamSetf] = std::string("cuParamSetf");
	}
	assert(lcuParamSetf);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuParamSetf(hfunc, offset, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuParamSetf);
	}
	return res;
}

CUresult cuParamSetv(CUfunction  hfunc, int  offset, void * ptr, unsigned int  numbytes)
{
	static CUresult (*lcuParamSetv) (CUfunction , int , void *, unsigned int );
	if (!lcuParamSetv) {
		lcuParamSetv = (CUresult (*) (CUfunction , int , void *, unsigned int )) dlsym(RTLD_NEXT, "cuParamSetv");
		tracer._kernel_map[(void *) lcuParamSetv] = std::string("cuParamSetv");
	}
	assert(lcuParamSetv);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuParamSetv(hfunc, offset, ptr, numbytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuParamSetv);
	}
	return res;
}

CUresult cuLaunch(CUfunction  f)
{
	static CUresult (*lcuLaunch) (CUfunction );
	if (!lcuLaunch) {
		lcuLaunch = (CUresult (*) (CUfunction )) dlsym(RTLD_NEXT, "cuLaunch");
		tracer._kernel_map[(void *) lcuLaunch] = std::string("cuLaunch");
	}
	assert(lcuLaunch);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunch(f);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunch);
	}
	return res;
}

CUresult cuLaunchGrid(CUfunction  f, int  grid_width, int  grid_height)
{
	static CUresult (*lcuLaunchGrid) (CUfunction , int , int );
	if (!lcuLaunchGrid) {
		lcuLaunchGrid = (CUresult (*) (CUfunction , int , int )) dlsym(RTLD_NEXT, "cuLaunchGrid");
		tracer._kernel_map[(void *) lcuLaunchGrid] = std::string("cuLaunchGrid");
	}
	assert(lcuLaunchGrid);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchGrid(f, grid_width, grid_height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchGrid);
	}
	return res;
}

CUresult cuLaunchGridAsync(CUfunction  f, int  grid_width, int  grid_height, CUstream  hStream)
{
	static CUresult (*lcuLaunchGridAsync) (CUfunction , int , int , CUstream );
	if (!lcuLaunchGridAsync) {
		lcuLaunchGridAsync = (CUresult (*) (CUfunction , int , int , CUstream )) dlsym(RTLD_NEXT, "cuLaunchGridAsync");
		tracer._kernel_map[(void *) lcuLaunchGridAsync] = std::string("cuLaunchGridAsync");
	}
	assert(lcuLaunchGridAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuLaunchGridAsync(f, grid_width, grid_height, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuLaunchGridAsync);
	}
	return res;
}

CUresult cuParamSetTexRef(CUfunction  hfunc, int  texunit, CUtexref  hTexRef)
{
	static CUresult (*lcuParamSetTexRef) (CUfunction , int , CUtexref );
	if (!lcuParamSetTexRef) {
		lcuParamSetTexRef = (CUresult (*) (CUfunction , int , CUtexref )) dlsym(RTLD_NEXT, "cuParamSetTexRef");
		tracer._kernel_map[(void *) lcuParamSetTexRef] = std::string("cuParamSetTexRef");
	}
	assert(lcuParamSetTexRef);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuParamSetTexRef(hfunc, texunit, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuParamSetTexRef);
	}
	return res;
}

CUresult cuGraphCreate(CUgraph * phGraph, unsigned int  flags)
{
	static CUresult (*lcuGraphCreate) (CUgraph *, unsigned int );
	if (!lcuGraphCreate) {
		lcuGraphCreate = (CUresult (*) (CUgraph *, unsigned int )) dlsym(RTLD_NEXT, "cuGraphCreate");
		tracer._kernel_map[(void *) lcuGraphCreate] = std::string("cuGraphCreate");
	}
	assert(lcuGraphCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphCreate(phGraph, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphCreate);
	}
	return res;
}

CUresult cuGraphAddKernelNode_v2(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_KERNEL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddKernelNode_v2) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_KERNEL_NODE_PARAMS *);
	if (!lcuGraphAddKernelNode_v2) {
		lcuGraphAddKernelNode_v2 = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_KERNEL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddKernelNode_v2");
		tracer._kernel_map[(void *) lcuGraphAddKernelNode_v2] = std::string("cuGraphAddKernelNode_v2");
	}
	assert(lcuGraphAddKernelNode_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddKernelNode_v2(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddKernelNode_v2);
	}
	return res;
}

CUresult cuGraphKernelNodeGetParams_v2(CUgraphNode  hNode, CUDA_KERNEL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphKernelNodeGetParams_v2) (CUgraphNode , CUDA_KERNEL_NODE_PARAMS *);
	if (!lcuGraphKernelNodeGetParams_v2) {
		lcuGraphKernelNodeGetParams_v2 = (CUresult (*) (CUgraphNode , CUDA_KERNEL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphKernelNodeGetParams_v2");
		tracer._kernel_map[(void *) lcuGraphKernelNodeGetParams_v2] = std::string("cuGraphKernelNodeGetParams_v2");
	}
	assert(lcuGraphKernelNodeGetParams_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphKernelNodeGetParams_v2(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphKernelNodeGetParams_v2);
	}
	return res;
}

CUresult cuGraphKernelNodeSetParams_v2(CUgraphNode  hNode, const CUDA_KERNEL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphKernelNodeSetParams_v2) (CUgraphNode , const CUDA_KERNEL_NODE_PARAMS *);
	if (!lcuGraphKernelNodeSetParams_v2) {
		lcuGraphKernelNodeSetParams_v2 = (CUresult (*) (CUgraphNode , const CUDA_KERNEL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphKernelNodeSetParams_v2");
		tracer._kernel_map[(void *) lcuGraphKernelNodeSetParams_v2] = std::string("cuGraphKernelNodeSetParams_v2");
	}
	assert(lcuGraphKernelNodeSetParams_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphKernelNodeSetParams_v2(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphKernelNodeSetParams_v2);
	}
	return res;
}

CUresult cuGraphAddMemcpyNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_MEMCPY3D * copyParams, CUcontext  ctx)
{
	static CUresult (*lcuGraphAddMemcpyNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_MEMCPY3D *, CUcontext );
	if (!lcuGraphAddMemcpyNode) {
		lcuGraphAddMemcpyNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_MEMCPY3D *, CUcontext )) dlsym(RTLD_NEXT, "cuGraphAddMemcpyNode");
		tracer._kernel_map[(void *) lcuGraphAddMemcpyNode] = std::string("cuGraphAddMemcpyNode");
	}
	assert(lcuGraphAddMemcpyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddMemcpyNode(phGraphNode, hGraph, dependencies, numDependencies, copyParams, ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddMemcpyNode);
	}
	return res;
}

CUresult cuGraphMemcpyNodeGetParams(CUgraphNode  hNode, CUDA_MEMCPY3D * nodeParams)
{
	static CUresult (*lcuGraphMemcpyNodeGetParams) (CUgraphNode , CUDA_MEMCPY3D *);
	if (!lcuGraphMemcpyNodeGetParams) {
		lcuGraphMemcpyNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_MEMCPY3D *)) dlsym(RTLD_NEXT, "cuGraphMemcpyNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphMemcpyNodeGetParams] = std::string("cuGraphMemcpyNodeGetParams");
	}
	assert(lcuGraphMemcpyNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemcpyNodeGetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemcpyNodeGetParams);
	}
	return res;
}

CUresult cuGraphMemcpyNodeSetParams(CUgraphNode  hNode, const CUDA_MEMCPY3D * nodeParams)
{
	static CUresult (*lcuGraphMemcpyNodeSetParams) (CUgraphNode , const CUDA_MEMCPY3D *);
	if (!lcuGraphMemcpyNodeSetParams) {
		lcuGraphMemcpyNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_MEMCPY3D *)) dlsym(RTLD_NEXT, "cuGraphMemcpyNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphMemcpyNodeSetParams] = std::string("cuGraphMemcpyNodeSetParams");
	}
	assert(lcuGraphMemcpyNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemcpyNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemcpyNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddMemsetNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_MEMSET_NODE_PARAMS * memsetParams, CUcontext  ctx)
{
	static CUresult (*lcuGraphAddMemsetNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_MEMSET_NODE_PARAMS *, CUcontext );
	if (!lcuGraphAddMemsetNode) {
		lcuGraphAddMemsetNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_MEMSET_NODE_PARAMS *, CUcontext )) dlsym(RTLD_NEXT, "cuGraphAddMemsetNode");
		tracer._kernel_map[(void *) lcuGraphAddMemsetNode] = std::string("cuGraphAddMemsetNode");
	}
	assert(lcuGraphAddMemsetNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddMemsetNode(phGraphNode, hGraph, dependencies, numDependencies, memsetParams, ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddMemsetNode);
	}
	return res;
}

CUresult cuGraphMemsetNodeGetParams(CUgraphNode  hNode, CUDA_MEMSET_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphMemsetNodeGetParams) (CUgraphNode , CUDA_MEMSET_NODE_PARAMS *);
	if (!lcuGraphMemsetNodeGetParams) {
		lcuGraphMemsetNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_MEMSET_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphMemsetNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphMemsetNodeGetParams] = std::string("cuGraphMemsetNodeGetParams");
	}
	assert(lcuGraphMemsetNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemsetNodeGetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemsetNodeGetParams);
	}
	return res;
}

CUresult cuGraphMemsetNodeSetParams(CUgraphNode  hNode, const CUDA_MEMSET_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphMemsetNodeSetParams) (CUgraphNode , const CUDA_MEMSET_NODE_PARAMS *);
	if (!lcuGraphMemsetNodeSetParams) {
		lcuGraphMemsetNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_MEMSET_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphMemsetNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphMemsetNodeSetParams] = std::string("cuGraphMemsetNodeSetParams");
	}
	assert(lcuGraphMemsetNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemsetNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemsetNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddHostNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_HOST_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddHostNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_HOST_NODE_PARAMS *);
	if (!lcuGraphAddHostNode) {
		lcuGraphAddHostNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_HOST_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddHostNode");
		tracer._kernel_map[(void *) lcuGraphAddHostNode] = std::string("cuGraphAddHostNode");
	}
	assert(lcuGraphAddHostNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddHostNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddHostNode);
	}
	return res;
}

CUresult cuGraphHostNodeGetParams(CUgraphNode  hNode, CUDA_HOST_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphHostNodeGetParams) (CUgraphNode , CUDA_HOST_NODE_PARAMS *);
	if (!lcuGraphHostNodeGetParams) {
		lcuGraphHostNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_HOST_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphHostNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphHostNodeGetParams] = std::string("cuGraphHostNodeGetParams");
	}
	assert(lcuGraphHostNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphHostNodeGetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphHostNodeGetParams);
	}
	return res;
}

CUresult cuGraphHostNodeSetParams(CUgraphNode  hNode, const CUDA_HOST_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphHostNodeSetParams) (CUgraphNode , const CUDA_HOST_NODE_PARAMS *);
	if (!lcuGraphHostNodeSetParams) {
		lcuGraphHostNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_HOST_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphHostNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphHostNodeSetParams] = std::string("cuGraphHostNodeSetParams");
	}
	assert(lcuGraphHostNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphHostNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphHostNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddChildGraphNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUgraph  childGraph)
{
	static CUresult (*lcuGraphAddChildGraphNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUgraph );
	if (!lcuGraphAddChildGraphNode) {
		lcuGraphAddChildGraphNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUgraph )) dlsym(RTLD_NEXT, "cuGraphAddChildGraphNode");
		tracer._kernel_map[(void *) lcuGraphAddChildGraphNode] = std::string("cuGraphAddChildGraphNode");
	}
	assert(lcuGraphAddChildGraphNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddChildGraphNode(phGraphNode, hGraph, dependencies, numDependencies, childGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddChildGraphNode);
	}
	return res;
}

CUresult cuGraphChildGraphNodeGetGraph(CUgraphNode  hNode, CUgraph * phGraph)
{
	static CUresult (*lcuGraphChildGraphNodeGetGraph) (CUgraphNode , CUgraph *);
	if (!lcuGraphChildGraphNodeGetGraph) {
		lcuGraphChildGraphNodeGetGraph = (CUresult (*) (CUgraphNode , CUgraph *)) dlsym(RTLD_NEXT, "cuGraphChildGraphNodeGetGraph");
		tracer._kernel_map[(void *) lcuGraphChildGraphNodeGetGraph] = std::string("cuGraphChildGraphNodeGetGraph");
	}
	assert(lcuGraphChildGraphNodeGetGraph);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphChildGraphNodeGetGraph(hNode, phGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphChildGraphNodeGetGraph);
	}
	return res;
}

CUresult cuGraphAddEmptyNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies)
{
	static CUresult (*lcuGraphAddEmptyNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t );
	if (!lcuGraphAddEmptyNode) {
		lcuGraphAddEmptyNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t )) dlsym(RTLD_NEXT, "cuGraphAddEmptyNode");
		tracer._kernel_map[(void *) lcuGraphAddEmptyNode] = std::string("cuGraphAddEmptyNode");
	}
	assert(lcuGraphAddEmptyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddEmptyNode(phGraphNode, hGraph, dependencies, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddEmptyNode);
	}
	return res;
}

CUresult cuGraphAddEventRecordNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUevent  event)
{
	static CUresult (*lcuGraphAddEventRecordNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUevent );
	if (!lcuGraphAddEventRecordNode) {
		lcuGraphAddEventRecordNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUevent )) dlsym(RTLD_NEXT, "cuGraphAddEventRecordNode");
		tracer._kernel_map[(void *) lcuGraphAddEventRecordNode] = std::string("cuGraphAddEventRecordNode");
	}
	assert(lcuGraphAddEventRecordNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddEventRecordNode(phGraphNode, hGraph, dependencies, numDependencies, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddEventRecordNode);
	}
	return res;
}

CUresult cuGraphEventRecordNodeGetEvent(CUgraphNode  hNode, CUevent * event_out)
{
	static CUresult (*lcuGraphEventRecordNodeGetEvent) (CUgraphNode , CUevent *);
	if (!lcuGraphEventRecordNodeGetEvent) {
		lcuGraphEventRecordNodeGetEvent = (CUresult (*) (CUgraphNode , CUevent *)) dlsym(RTLD_NEXT, "cuGraphEventRecordNodeGetEvent");
		tracer._kernel_map[(void *) lcuGraphEventRecordNodeGetEvent] = std::string("cuGraphEventRecordNodeGetEvent");
	}
	assert(lcuGraphEventRecordNodeGetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphEventRecordNodeGetEvent(hNode, event_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphEventRecordNodeGetEvent);
	}
	return res;
}

CUresult cuGraphEventRecordNodeSetEvent(CUgraphNode  hNode, CUevent  event)
{
	static CUresult (*lcuGraphEventRecordNodeSetEvent) (CUgraphNode , CUevent );
	if (!lcuGraphEventRecordNodeSetEvent) {
		lcuGraphEventRecordNodeSetEvent = (CUresult (*) (CUgraphNode , CUevent )) dlsym(RTLD_NEXT, "cuGraphEventRecordNodeSetEvent");
		tracer._kernel_map[(void *) lcuGraphEventRecordNodeSetEvent] = std::string("cuGraphEventRecordNodeSetEvent");
	}
	assert(lcuGraphEventRecordNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphEventRecordNodeSetEvent(hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphEventRecordNodeSetEvent);
	}
	return res;
}

CUresult cuGraphAddEventWaitNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUevent  event)
{
	static CUresult (*lcuGraphAddEventWaitNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUevent );
	if (!lcuGraphAddEventWaitNode) {
		lcuGraphAddEventWaitNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUevent )) dlsym(RTLD_NEXT, "cuGraphAddEventWaitNode");
		tracer._kernel_map[(void *) lcuGraphAddEventWaitNode] = std::string("cuGraphAddEventWaitNode");
	}
	assert(lcuGraphAddEventWaitNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddEventWaitNode(phGraphNode, hGraph, dependencies, numDependencies, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddEventWaitNode);
	}
	return res;
}

CUresult cuGraphEventWaitNodeGetEvent(CUgraphNode  hNode, CUevent * event_out)
{
	static CUresult (*lcuGraphEventWaitNodeGetEvent) (CUgraphNode , CUevent *);
	if (!lcuGraphEventWaitNodeGetEvent) {
		lcuGraphEventWaitNodeGetEvent = (CUresult (*) (CUgraphNode , CUevent *)) dlsym(RTLD_NEXT, "cuGraphEventWaitNodeGetEvent");
		tracer._kernel_map[(void *) lcuGraphEventWaitNodeGetEvent] = std::string("cuGraphEventWaitNodeGetEvent");
	}
	assert(lcuGraphEventWaitNodeGetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphEventWaitNodeGetEvent(hNode, event_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphEventWaitNodeGetEvent);
	}
	return res;
}

CUresult cuGraphEventWaitNodeSetEvent(CUgraphNode  hNode, CUevent  event)
{
	static CUresult (*lcuGraphEventWaitNodeSetEvent) (CUgraphNode , CUevent );
	if (!lcuGraphEventWaitNodeSetEvent) {
		lcuGraphEventWaitNodeSetEvent = (CUresult (*) (CUgraphNode , CUevent )) dlsym(RTLD_NEXT, "cuGraphEventWaitNodeSetEvent");
		tracer._kernel_map[(void *) lcuGraphEventWaitNodeSetEvent] = std::string("cuGraphEventWaitNodeSetEvent");
	}
	assert(lcuGraphEventWaitNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphEventWaitNodeSetEvent(hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphEventWaitNodeSetEvent);
	}
	return res;
}

CUresult cuGraphAddExternalSemaphoresSignalNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddExternalSemaphoresSignalNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *);
	if (!lcuGraphAddExternalSemaphoresSignalNode) {
		lcuGraphAddExternalSemaphoresSignalNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddExternalSemaphoresSignalNode");
		tracer._kernel_map[(void *) lcuGraphAddExternalSemaphoresSignalNode] = std::string("cuGraphAddExternalSemaphoresSignalNode");
	}
	assert(lcuGraphAddExternalSemaphoresSignalNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddExternalSemaphoresSignalNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddExternalSemaphoresSignalNode);
	}
	return res;
}

CUresult cuGraphExternalSemaphoresSignalNodeGetParams(CUgraphNode  hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * params_out)
{
	static CUresult (*lcuGraphExternalSemaphoresSignalNodeGetParams) (CUgraphNode , CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *);
	if (!lcuGraphExternalSemaphoresSignalNodeGetParams) {
		lcuGraphExternalSemaphoresSignalNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExternalSemaphoresSignalNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphExternalSemaphoresSignalNodeGetParams] = std::string("cuGraphExternalSemaphoresSignalNodeGetParams");
	}
	assert(lcuGraphExternalSemaphoresSignalNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExternalSemaphoresSignalNodeGetParams(hNode, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExternalSemaphoresSignalNodeGetParams);
	}
	return res;
}

CUresult cuGraphExternalSemaphoresSignalNodeSetParams(CUgraphNode  hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExternalSemaphoresSignalNodeSetParams) (CUgraphNode , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *);
	if (!lcuGraphExternalSemaphoresSignalNodeSetParams) {
		lcuGraphExternalSemaphoresSignalNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExternalSemaphoresSignalNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExternalSemaphoresSignalNodeSetParams] = std::string("cuGraphExternalSemaphoresSignalNodeSetParams");
	}
	assert(lcuGraphExternalSemaphoresSignalNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExternalSemaphoresSignalNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddExternalSemaphoresWaitNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddExternalSemaphoresWaitNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *);
	if (!lcuGraphAddExternalSemaphoresWaitNode) {
		lcuGraphAddExternalSemaphoresWaitNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddExternalSemaphoresWaitNode");
		tracer._kernel_map[(void *) lcuGraphAddExternalSemaphoresWaitNode] = std::string("cuGraphAddExternalSemaphoresWaitNode");
	}
	assert(lcuGraphAddExternalSemaphoresWaitNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddExternalSemaphoresWaitNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddExternalSemaphoresWaitNode);
	}
	return res;
}

CUresult cuGraphExternalSemaphoresWaitNodeGetParams(CUgraphNode  hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS * params_out)
{
	static CUresult (*lcuGraphExternalSemaphoresWaitNodeGetParams) (CUgraphNode , CUDA_EXT_SEM_WAIT_NODE_PARAMS *);
	if (!lcuGraphExternalSemaphoresWaitNodeGetParams) {
		lcuGraphExternalSemaphoresWaitNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_EXT_SEM_WAIT_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExternalSemaphoresWaitNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphExternalSemaphoresWaitNodeGetParams] = std::string("cuGraphExternalSemaphoresWaitNodeGetParams");
	}
	assert(lcuGraphExternalSemaphoresWaitNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExternalSemaphoresWaitNodeGetParams(hNode, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExternalSemaphoresWaitNodeGetParams);
	}
	return res;
}

CUresult cuGraphExternalSemaphoresWaitNodeSetParams(CUgraphNode  hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExternalSemaphoresWaitNodeSetParams) (CUgraphNode , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *);
	if (!lcuGraphExternalSemaphoresWaitNodeSetParams) {
		lcuGraphExternalSemaphoresWaitNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExternalSemaphoresWaitNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExternalSemaphoresWaitNodeSetParams] = std::string("cuGraphExternalSemaphoresWaitNodeSetParams");
	}
	assert(lcuGraphExternalSemaphoresWaitNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExternalSemaphoresWaitNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddBatchMemOpNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddBatchMemOpNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_BATCH_MEM_OP_NODE_PARAMS *);
	if (!lcuGraphAddBatchMemOpNode) {
		lcuGraphAddBatchMemOpNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , const CUDA_BATCH_MEM_OP_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddBatchMemOpNode");
		tracer._kernel_map[(void *) lcuGraphAddBatchMemOpNode] = std::string("cuGraphAddBatchMemOpNode");
	}
	assert(lcuGraphAddBatchMemOpNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddBatchMemOpNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddBatchMemOpNode);
	}
	return res;
}

CUresult cuGraphBatchMemOpNodeGetParams(CUgraphNode  hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams_out)
{
	static CUresult (*lcuGraphBatchMemOpNodeGetParams) (CUgraphNode , CUDA_BATCH_MEM_OP_NODE_PARAMS *);
	if (!lcuGraphBatchMemOpNodeGetParams) {
		lcuGraphBatchMemOpNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_BATCH_MEM_OP_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphBatchMemOpNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphBatchMemOpNodeGetParams] = std::string("cuGraphBatchMemOpNodeGetParams");
	}
	assert(lcuGraphBatchMemOpNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphBatchMemOpNodeGetParams(hNode, nodeParams_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphBatchMemOpNodeGetParams);
	}
	return res;
}

CUresult cuGraphBatchMemOpNodeSetParams(CUgraphNode  hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphBatchMemOpNodeSetParams) (CUgraphNode , const CUDA_BATCH_MEM_OP_NODE_PARAMS *);
	if (!lcuGraphBatchMemOpNodeSetParams) {
		lcuGraphBatchMemOpNodeSetParams = (CUresult (*) (CUgraphNode , const CUDA_BATCH_MEM_OP_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphBatchMemOpNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphBatchMemOpNodeSetParams] = std::string("cuGraphBatchMemOpNodeSetParams");
	}
	assert(lcuGraphBatchMemOpNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphBatchMemOpNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphBatchMemOpNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecBatchMemOpNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExecBatchMemOpNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_BATCH_MEM_OP_NODE_PARAMS *);
	if (!lcuGraphExecBatchMemOpNodeSetParams) {
		lcuGraphExecBatchMemOpNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_BATCH_MEM_OP_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExecBatchMemOpNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecBatchMemOpNodeSetParams] = std::string("cuGraphExecBatchMemOpNodeSetParams");
	}
	assert(lcuGraphExecBatchMemOpNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecBatchMemOpNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecBatchMemOpNodeSetParams);
	}
	return res;
}

CUresult cuGraphAddMemAllocNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUDA_MEM_ALLOC_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphAddMemAllocNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUDA_MEM_ALLOC_NODE_PARAMS *);
	if (!lcuGraphAddMemAllocNode) {
		lcuGraphAddMemAllocNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUDA_MEM_ALLOC_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphAddMemAllocNode");
		tracer._kernel_map[(void *) lcuGraphAddMemAllocNode] = std::string("cuGraphAddMemAllocNode");
	}
	assert(lcuGraphAddMemAllocNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddMemAllocNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddMemAllocNode);
	}
	return res;
}

CUresult cuGraphMemAllocNodeGetParams(CUgraphNode  hNode, CUDA_MEM_ALLOC_NODE_PARAMS * params_out)
{
	static CUresult (*lcuGraphMemAllocNodeGetParams) (CUgraphNode , CUDA_MEM_ALLOC_NODE_PARAMS *);
	if (!lcuGraphMemAllocNodeGetParams) {
		lcuGraphMemAllocNodeGetParams = (CUresult (*) (CUgraphNode , CUDA_MEM_ALLOC_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphMemAllocNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphMemAllocNodeGetParams] = std::string("cuGraphMemAllocNodeGetParams");
	}
	assert(lcuGraphMemAllocNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemAllocNodeGetParams(hNode, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemAllocNodeGetParams);
	}
	return res;
}

CUresult cuGraphAddMemFreeNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUdeviceptr  dptr)
{
	static CUresult (*lcuGraphAddMemFreeNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUdeviceptr );
	if (!lcuGraphAddMemFreeNode) {
		lcuGraphAddMemFreeNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUdeviceptr )) dlsym(RTLD_NEXT, "cuGraphAddMemFreeNode");
		tracer._kernel_map[(void *) lcuGraphAddMemFreeNode] = std::string("cuGraphAddMemFreeNode");
	}
	assert(lcuGraphAddMemFreeNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddMemFreeNode(phGraphNode, hGraph, dependencies, numDependencies, dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddMemFreeNode);
	}
	return res;
}

CUresult cuGraphMemFreeNodeGetParams(CUgraphNode  hNode, CUdeviceptr * dptr_out)
{
	static CUresult (*lcuGraphMemFreeNodeGetParams) (CUgraphNode , CUdeviceptr *);
	if (!lcuGraphMemFreeNodeGetParams) {
		lcuGraphMemFreeNodeGetParams = (CUresult (*) (CUgraphNode , CUdeviceptr *)) dlsym(RTLD_NEXT, "cuGraphMemFreeNodeGetParams");
		tracer._kernel_map[(void *) lcuGraphMemFreeNodeGetParams] = std::string("cuGraphMemFreeNodeGetParams");
	}
	assert(lcuGraphMemFreeNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphMemFreeNodeGetParams(hNode, dptr_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphMemFreeNodeGetParams);
	}
	return res;
}

CUresult cuDeviceGraphMemTrim(CUdevice  device)
{
	static CUresult (*lcuDeviceGraphMemTrim) (CUdevice );
	if (!lcuDeviceGraphMemTrim) {
		lcuDeviceGraphMemTrim = (CUresult (*) (CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGraphMemTrim");
		tracer._kernel_map[(void *) lcuDeviceGraphMemTrim] = std::string("cuDeviceGraphMemTrim");
	}
	assert(lcuDeviceGraphMemTrim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGraphMemTrim(device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGraphMemTrim);
	}
	return res;
}

CUresult cuDeviceGetGraphMemAttribute(CUdevice  device, CUgraphMem_attribute  attr, void*  value)
{
	static CUresult (*lcuDeviceGetGraphMemAttribute) (CUdevice , CUgraphMem_attribute , void* );
	if (!lcuDeviceGetGraphMemAttribute) {
		lcuDeviceGetGraphMemAttribute = (CUresult (*) (CUdevice , CUgraphMem_attribute , void* )) dlsym(RTLD_NEXT, "cuDeviceGetGraphMemAttribute");
		tracer._kernel_map[(void *) lcuDeviceGetGraphMemAttribute] = std::string("cuDeviceGetGraphMemAttribute");
	}
	assert(lcuDeviceGetGraphMemAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetGraphMemAttribute(device, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetGraphMemAttribute);
	}
	return res;
}

CUresult cuDeviceSetGraphMemAttribute(CUdevice  device, CUgraphMem_attribute  attr, void*  value)
{
	static CUresult (*lcuDeviceSetGraphMemAttribute) (CUdevice , CUgraphMem_attribute , void* );
	if (!lcuDeviceSetGraphMemAttribute) {
		lcuDeviceSetGraphMemAttribute = (CUresult (*) (CUdevice , CUgraphMem_attribute , void* )) dlsym(RTLD_NEXT, "cuDeviceSetGraphMemAttribute");
		tracer._kernel_map[(void *) lcuDeviceSetGraphMemAttribute] = std::string("cuDeviceSetGraphMemAttribute");
	}
	assert(lcuDeviceSetGraphMemAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceSetGraphMemAttribute(device, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceSetGraphMemAttribute);
	}
	return res;
}

CUresult cuGraphClone(CUgraph * phGraphClone, CUgraph  originalGraph)
{
	static CUresult (*lcuGraphClone) (CUgraph *, CUgraph );
	if (!lcuGraphClone) {
		lcuGraphClone = (CUresult (*) (CUgraph *, CUgraph )) dlsym(RTLD_NEXT, "cuGraphClone");
		tracer._kernel_map[(void *) lcuGraphClone] = std::string("cuGraphClone");
	}
	assert(lcuGraphClone);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphClone(phGraphClone, originalGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphClone);
	}
	return res;
}

CUresult cuGraphNodeFindInClone(CUgraphNode * phNode, CUgraphNode  hOriginalNode, CUgraph  hClonedGraph)
{
	static CUresult (*lcuGraphNodeFindInClone) (CUgraphNode *, CUgraphNode , CUgraph );
	if (!lcuGraphNodeFindInClone) {
		lcuGraphNodeFindInClone = (CUresult (*) (CUgraphNode *, CUgraphNode , CUgraph )) dlsym(RTLD_NEXT, "cuGraphNodeFindInClone");
		tracer._kernel_map[(void *) lcuGraphNodeFindInClone] = std::string("cuGraphNodeFindInClone");
	}
	assert(lcuGraphNodeFindInClone);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeFindInClone(phNode, hOriginalNode, hClonedGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeFindInClone);
	}
	return res;
}

CUresult cuGraphNodeGetType(CUgraphNode  hNode, CUgraphNodeType * type)
{
	static CUresult (*lcuGraphNodeGetType) (CUgraphNode , CUgraphNodeType *);
	if (!lcuGraphNodeGetType) {
		lcuGraphNodeGetType = (CUresult (*) (CUgraphNode , CUgraphNodeType *)) dlsym(RTLD_NEXT, "cuGraphNodeGetType");
		tracer._kernel_map[(void *) lcuGraphNodeGetType] = std::string("cuGraphNodeGetType");
	}
	assert(lcuGraphNodeGetType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeGetType(hNode, type);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeGetType);
	}
	return res;
}

CUresult cuGraphGetNodes(CUgraph  hGraph, CUgraphNode * nodes, size_t * numNodes)
{
	static CUresult (*lcuGraphGetNodes) (CUgraph , CUgraphNode *, size_t *);
	if (!lcuGraphGetNodes) {
		lcuGraphGetNodes = (CUresult (*) (CUgraph , CUgraphNode *, size_t *)) dlsym(RTLD_NEXT, "cuGraphGetNodes");
		tracer._kernel_map[(void *) lcuGraphGetNodes] = std::string("cuGraphGetNodes");
	}
	assert(lcuGraphGetNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphGetNodes(hGraph, nodes, numNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphGetNodes);
	}
	return res;
}

CUresult cuGraphGetRootNodes(CUgraph  hGraph, CUgraphNode * rootNodes, size_t * numRootNodes)
{
	static CUresult (*lcuGraphGetRootNodes) (CUgraph , CUgraphNode *, size_t *);
	if (!lcuGraphGetRootNodes) {
		lcuGraphGetRootNodes = (CUresult (*) (CUgraph , CUgraphNode *, size_t *)) dlsym(RTLD_NEXT, "cuGraphGetRootNodes");
		tracer._kernel_map[(void *) lcuGraphGetRootNodes] = std::string("cuGraphGetRootNodes");
	}
	assert(lcuGraphGetRootNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphGetRootNodes(hGraph, rootNodes, numRootNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphGetRootNodes);
	}
	return res;
}

CUresult cuGraphGetEdges(CUgraph  hGraph, CUgraphNode * from, CUgraphNode * to, size_t * numEdges)
{
	static CUresult (*lcuGraphGetEdges) (CUgraph , CUgraphNode *, CUgraphNode *, size_t *);
	if (!lcuGraphGetEdges) {
		lcuGraphGetEdges = (CUresult (*) (CUgraph , CUgraphNode *, CUgraphNode *, size_t *)) dlsym(RTLD_NEXT, "cuGraphGetEdges");
		tracer._kernel_map[(void *) lcuGraphGetEdges] = std::string("cuGraphGetEdges");
	}
	assert(lcuGraphGetEdges);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphGetEdges(hGraph, from, to, numEdges);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphGetEdges);
	}
	return res;
}

CUresult cuGraphNodeGetDependencies(CUgraphNode  hNode, CUgraphNode * dependencies, size_t * numDependencies)
{
	static CUresult (*lcuGraphNodeGetDependencies) (CUgraphNode , CUgraphNode *, size_t *);
	if (!lcuGraphNodeGetDependencies) {
		lcuGraphNodeGetDependencies = (CUresult (*) (CUgraphNode , CUgraphNode *, size_t *)) dlsym(RTLD_NEXT, "cuGraphNodeGetDependencies");
		tracer._kernel_map[(void *) lcuGraphNodeGetDependencies] = std::string("cuGraphNodeGetDependencies");
	}
	assert(lcuGraphNodeGetDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeGetDependencies(hNode, dependencies, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeGetDependencies);
	}
	return res;
}

CUresult cuGraphNodeGetDependentNodes(CUgraphNode  hNode, CUgraphNode * dependentNodes, size_t * numDependentNodes)
{
	static CUresult (*lcuGraphNodeGetDependentNodes) (CUgraphNode , CUgraphNode *, size_t *);
	if (!lcuGraphNodeGetDependentNodes) {
		lcuGraphNodeGetDependentNodes = (CUresult (*) (CUgraphNode , CUgraphNode *, size_t *)) dlsym(RTLD_NEXT, "cuGraphNodeGetDependentNodes");
		tracer._kernel_map[(void *) lcuGraphNodeGetDependentNodes] = std::string("cuGraphNodeGetDependentNodes");
	}
	assert(lcuGraphNodeGetDependentNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeGetDependentNodes(hNode, dependentNodes, numDependentNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeGetDependentNodes);
	}
	return res;
}

CUresult cuGraphAddDependencies(CUgraph  hGraph, const CUgraphNode * from, const CUgraphNode * to, size_t  numDependencies)
{
	static CUresult (*lcuGraphAddDependencies) (CUgraph , const CUgraphNode *, const CUgraphNode *, size_t );
	if (!lcuGraphAddDependencies) {
		lcuGraphAddDependencies = (CUresult (*) (CUgraph , const CUgraphNode *, const CUgraphNode *, size_t )) dlsym(RTLD_NEXT, "cuGraphAddDependencies");
		tracer._kernel_map[(void *) lcuGraphAddDependencies] = std::string("cuGraphAddDependencies");
	}
	assert(lcuGraphAddDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddDependencies(hGraph, from, to, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddDependencies);
	}
	return res;
}

CUresult cuGraphRemoveDependencies(CUgraph  hGraph, const CUgraphNode * from, const CUgraphNode * to, size_t  numDependencies)
{
	static CUresult (*lcuGraphRemoveDependencies) (CUgraph , const CUgraphNode *, const CUgraphNode *, size_t );
	if (!lcuGraphRemoveDependencies) {
		lcuGraphRemoveDependencies = (CUresult (*) (CUgraph , const CUgraphNode *, const CUgraphNode *, size_t )) dlsym(RTLD_NEXT, "cuGraphRemoveDependencies");
		tracer._kernel_map[(void *) lcuGraphRemoveDependencies] = std::string("cuGraphRemoveDependencies");
	}
	assert(lcuGraphRemoveDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphRemoveDependencies(hGraph, from, to, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphRemoveDependencies);
	}
	return res;
}

CUresult cuGraphDestroyNode(CUgraphNode  hNode)
{
	static CUresult (*lcuGraphDestroyNode) (CUgraphNode );
	if (!lcuGraphDestroyNode) {
		lcuGraphDestroyNode = (CUresult (*) (CUgraphNode )) dlsym(RTLD_NEXT, "cuGraphDestroyNode");
		tracer._kernel_map[(void *) lcuGraphDestroyNode] = std::string("cuGraphDestroyNode");
	}
	assert(lcuGraphDestroyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphDestroyNode(hNode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphDestroyNode);
	}
	return res;
}

CUresult cuGraphInstantiateWithFlags(CUgraphExec * phGraphExec, CUgraph  hGraph, unsigned long long  flags)
{
	static CUresult (*lcuGraphInstantiateWithFlags) (CUgraphExec *, CUgraph , unsigned long long );
	if (!lcuGraphInstantiateWithFlags) {
		lcuGraphInstantiateWithFlags = (CUresult (*) (CUgraphExec *, CUgraph , unsigned long long )) dlsym(RTLD_NEXT, "cuGraphInstantiateWithFlags");
		tracer._kernel_map[(void *) lcuGraphInstantiateWithFlags] = std::string("cuGraphInstantiateWithFlags");
	}
	assert(lcuGraphInstantiateWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphInstantiateWithFlags(phGraphExec, hGraph, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphInstantiateWithFlags);
	}
	return res;
}

CUresult cuGraphInstantiateWithParams(CUgraphExec * phGraphExec, CUgraph  hGraph, CUDA_GRAPH_INSTANTIATE_PARAMS * instantiateParams)
{
	static CUresult (*lcuGraphInstantiateWithParams) (CUgraphExec *, CUgraph , CUDA_GRAPH_INSTANTIATE_PARAMS *);
	if (!lcuGraphInstantiateWithParams) {
		lcuGraphInstantiateWithParams = (CUresult (*) (CUgraphExec *, CUgraph , CUDA_GRAPH_INSTANTIATE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphInstantiateWithParams");
		tracer._kernel_map[(void *) lcuGraphInstantiateWithParams] = std::string("cuGraphInstantiateWithParams");
	}
	assert(lcuGraphInstantiateWithParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphInstantiateWithParams(phGraphExec, hGraph, instantiateParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphInstantiateWithParams);
	}
	return res;
}

CUresult cuGraphExecGetFlags(CUgraphExec  hGraphExec, cuuint64_t * flags)
{
	static CUresult (*lcuGraphExecGetFlags) (CUgraphExec , cuuint64_t *);
	if (!lcuGraphExecGetFlags) {
		lcuGraphExecGetFlags = (CUresult (*) (CUgraphExec , cuuint64_t *)) dlsym(RTLD_NEXT, "cuGraphExecGetFlags");
		tracer._kernel_map[(void *) lcuGraphExecGetFlags] = std::string("cuGraphExecGetFlags");
	}
	assert(lcuGraphExecGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecGetFlags(hGraphExec, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecGetFlags);
	}
	return res;
}

CUresult cuGraphExecKernelNodeSetParams_v2(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_KERNEL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExecKernelNodeSetParams_v2) (CUgraphExec , CUgraphNode , const CUDA_KERNEL_NODE_PARAMS *);
	if (!lcuGraphExecKernelNodeSetParams_v2) {
		lcuGraphExecKernelNodeSetParams_v2 = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_KERNEL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExecKernelNodeSetParams_v2");
		tracer._kernel_map[(void *) lcuGraphExecKernelNodeSetParams_v2] = std::string("cuGraphExecKernelNodeSetParams_v2");
	}
	assert(lcuGraphExecKernelNodeSetParams_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecKernelNodeSetParams_v2(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecKernelNodeSetParams_v2);
	}
	return res;
}

CUresult cuGraphExecMemcpyNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_MEMCPY3D * copyParams, CUcontext  ctx)
{
	static CUresult (*lcuGraphExecMemcpyNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_MEMCPY3D *, CUcontext );
	if (!lcuGraphExecMemcpyNodeSetParams) {
		lcuGraphExecMemcpyNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_MEMCPY3D *, CUcontext )) dlsym(RTLD_NEXT, "cuGraphExecMemcpyNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecMemcpyNodeSetParams] = std::string("cuGraphExecMemcpyNodeSetParams");
	}
	assert(lcuGraphExecMemcpyNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecMemcpyNodeSetParams(hGraphExec, hNode, copyParams, ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecMemcpyNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecMemsetNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_MEMSET_NODE_PARAMS * memsetParams, CUcontext  ctx)
{
	static CUresult (*lcuGraphExecMemsetNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_MEMSET_NODE_PARAMS *, CUcontext );
	if (!lcuGraphExecMemsetNodeSetParams) {
		lcuGraphExecMemsetNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_MEMSET_NODE_PARAMS *, CUcontext )) dlsym(RTLD_NEXT, "cuGraphExecMemsetNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecMemsetNodeSetParams] = std::string("cuGraphExecMemsetNodeSetParams");
	}
	assert(lcuGraphExecMemsetNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecMemsetNodeSetParams(hGraphExec, hNode, memsetParams, ctx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecMemsetNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecHostNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_HOST_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExecHostNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_HOST_NODE_PARAMS *);
	if (!lcuGraphExecHostNodeSetParams) {
		lcuGraphExecHostNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_HOST_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExecHostNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecHostNodeSetParams] = std::string("cuGraphExecHostNodeSetParams");
	}
	assert(lcuGraphExecHostNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecHostNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecHostNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecChildGraphNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, CUgraph  childGraph)
{
	static CUresult (*lcuGraphExecChildGraphNodeSetParams) (CUgraphExec , CUgraphNode , CUgraph );
	if (!lcuGraphExecChildGraphNodeSetParams) {
		lcuGraphExecChildGraphNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , CUgraph )) dlsym(RTLD_NEXT, "cuGraphExecChildGraphNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecChildGraphNodeSetParams] = std::string("cuGraphExecChildGraphNodeSetParams");
	}
	assert(lcuGraphExecChildGraphNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecChildGraphNodeSetParams(hGraphExec, hNode, childGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecChildGraphNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecEventRecordNodeSetEvent(CUgraphExec  hGraphExec, CUgraphNode  hNode, CUevent  event)
{
	static CUresult (*lcuGraphExecEventRecordNodeSetEvent) (CUgraphExec , CUgraphNode , CUevent );
	if (!lcuGraphExecEventRecordNodeSetEvent) {
		lcuGraphExecEventRecordNodeSetEvent = (CUresult (*) (CUgraphExec , CUgraphNode , CUevent )) dlsym(RTLD_NEXT, "cuGraphExecEventRecordNodeSetEvent");
		tracer._kernel_map[(void *) lcuGraphExecEventRecordNodeSetEvent] = std::string("cuGraphExecEventRecordNodeSetEvent");
	}
	assert(lcuGraphExecEventRecordNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecEventRecordNodeSetEvent);
	}
	return res;
}

CUresult cuGraphExecEventWaitNodeSetEvent(CUgraphExec  hGraphExec, CUgraphNode  hNode, CUevent  event)
{
	static CUresult (*lcuGraphExecEventWaitNodeSetEvent) (CUgraphExec , CUgraphNode , CUevent );
	if (!lcuGraphExecEventWaitNodeSetEvent) {
		lcuGraphExecEventWaitNodeSetEvent = (CUresult (*) (CUgraphExec , CUgraphNode , CUevent )) dlsym(RTLD_NEXT, "cuGraphExecEventWaitNodeSetEvent");
		tracer._kernel_map[(void *) lcuGraphExecEventWaitNodeSetEvent] = std::string("cuGraphExecEventWaitNodeSetEvent");
	}
	assert(lcuGraphExecEventWaitNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecEventWaitNodeSetEvent);
	}
	return res;
}

CUresult cuGraphExecExternalSemaphoresSignalNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExecExternalSemaphoresSignalNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *);
	if (!lcuGraphExecExternalSemaphoresSignalNodeSetParams) {
		lcuGraphExecExternalSemaphoresSignalNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExecExternalSemaphoresSignalNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecExternalSemaphoresSignalNodeSetParams] = std::string("cuGraphExecExternalSemaphoresSignalNodeSetParams");
	}
	assert(lcuGraphExecExternalSemaphoresSignalNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecExternalSemaphoresSignalNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecExternalSemaphoresWaitNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS * nodeParams)
{
	static CUresult (*lcuGraphExecExternalSemaphoresWaitNodeSetParams) (CUgraphExec , CUgraphNode , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *);
	if (!lcuGraphExecExternalSemaphoresWaitNodeSetParams) {
		lcuGraphExecExternalSemaphoresWaitNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , const CUDA_EXT_SEM_WAIT_NODE_PARAMS *)) dlsym(RTLD_NEXT, "cuGraphExecExternalSemaphoresWaitNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecExternalSemaphoresWaitNodeSetParams] = std::string("cuGraphExecExternalSemaphoresWaitNodeSetParams");
	}
	assert(lcuGraphExecExternalSemaphoresWaitNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecExternalSemaphoresWaitNodeSetParams);
	}
	return res;
}

CUresult cuGraphNodeSetEnabled(CUgraphExec  hGraphExec, CUgraphNode  hNode, unsigned int  isEnabled)
{
	static CUresult (*lcuGraphNodeSetEnabled) (CUgraphExec , CUgraphNode , unsigned int );
	if (!lcuGraphNodeSetEnabled) {
		lcuGraphNodeSetEnabled = (CUresult (*) (CUgraphExec , CUgraphNode , unsigned int )) dlsym(RTLD_NEXT, "cuGraphNodeSetEnabled");
		tracer._kernel_map[(void *) lcuGraphNodeSetEnabled] = std::string("cuGraphNodeSetEnabled");
	}
	assert(lcuGraphNodeSetEnabled);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeSetEnabled(hGraphExec, hNode, isEnabled);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeSetEnabled);
	}
	return res;
}

CUresult cuGraphNodeGetEnabled(CUgraphExec  hGraphExec, CUgraphNode  hNode, unsigned int * isEnabled)
{
	static CUresult (*lcuGraphNodeGetEnabled) (CUgraphExec , CUgraphNode , unsigned int *);
	if (!lcuGraphNodeGetEnabled) {
		lcuGraphNodeGetEnabled = (CUresult (*) (CUgraphExec , CUgraphNode , unsigned int *)) dlsym(RTLD_NEXT, "cuGraphNodeGetEnabled");
		tracer._kernel_map[(void *) lcuGraphNodeGetEnabled] = std::string("cuGraphNodeGetEnabled");
	}
	assert(lcuGraphNodeGetEnabled);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeGetEnabled(hGraphExec, hNode, isEnabled);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeGetEnabled);
	}
	return res;
}

CUresult cuGraphUpload(CUgraphExec  hGraphExec, CUstream  hStream)
{
	static CUresult (*lcuGraphUpload) (CUgraphExec , CUstream );
	if (!lcuGraphUpload) {
		lcuGraphUpload = (CUresult (*) (CUgraphExec , CUstream )) dlsym(RTLD_NEXT, "cuGraphUpload");
		tracer._kernel_map[(void *) lcuGraphUpload] = std::string("cuGraphUpload");
	}
	assert(lcuGraphUpload);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphUpload(hGraphExec, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphUpload);
	}
	return res;
}

CUresult cuGraphLaunch(CUgraphExec  hGraphExec, CUstream  hStream)
{
	static CUresult (*lcuGraphLaunch) (CUgraphExec , CUstream );
	if (!lcuGraphLaunch) {
		lcuGraphLaunch = (CUresult (*) (CUgraphExec , CUstream )) dlsym(RTLD_NEXT, "cuGraphLaunch");
		tracer._kernel_map[(void *) lcuGraphLaunch] = std::string("cuGraphLaunch");
	}
	assert(lcuGraphLaunch);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphLaunch(hGraphExec, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphLaunch);
	}
	return res;
}

CUresult cuGraphExecDestroy(CUgraphExec  hGraphExec)
{
	static CUresult (*lcuGraphExecDestroy) (CUgraphExec );
	if (!lcuGraphExecDestroy) {
		lcuGraphExecDestroy = (CUresult (*) (CUgraphExec )) dlsym(RTLD_NEXT, "cuGraphExecDestroy");
		tracer._kernel_map[(void *) lcuGraphExecDestroy] = std::string("cuGraphExecDestroy");
	}
	assert(lcuGraphExecDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecDestroy(hGraphExec);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecDestroy);
	}
	return res;
}

CUresult cuGraphDestroy(CUgraph  hGraph)
{
	static CUresult (*lcuGraphDestroy) (CUgraph );
	if (!lcuGraphDestroy) {
		lcuGraphDestroy = (CUresult (*) (CUgraph )) dlsym(RTLD_NEXT, "cuGraphDestroy");
		tracer._kernel_map[(void *) lcuGraphDestroy] = std::string("cuGraphDestroy");
	}
	assert(lcuGraphDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphDestroy(hGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphDestroy);
	}
	return res;
}

CUresult cuGraphExecUpdate_v2(CUgraphExec  hGraphExec, CUgraph  hGraph, CUgraphExecUpdateResultInfo * resultInfo)
{
	static CUresult (*lcuGraphExecUpdate_v2) (CUgraphExec , CUgraph , CUgraphExecUpdateResultInfo *);
	if (!lcuGraphExecUpdate_v2) {
		lcuGraphExecUpdate_v2 = (CUresult (*) (CUgraphExec , CUgraph , CUgraphExecUpdateResultInfo *)) dlsym(RTLD_NEXT, "cuGraphExecUpdate_v2");
		tracer._kernel_map[(void *) lcuGraphExecUpdate_v2] = std::string("cuGraphExecUpdate_v2");
	}
	assert(lcuGraphExecUpdate_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecUpdate_v2(hGraphExec, hGraph, resultInfo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecUpdate_v2);
	}
	return res;
}

CUresult cuGraphKernelNodeCopyAttributes(CUgraphNode  dst, CUgraphNode  src)
{
	static CUresult (*lcuGraphKernelNodeCopyAttributes) (CUgraphNode , CUgraphNode );
	if (!lcuGraphKernelNodeCopyAttributes) {
		lcuGraphKernelNodeCopyAttributes = (CUresult (*) (CUgraphNode , CUgraphNode )) dlsym(RTLD_NEXT, "cuGraphKernelNodeCopyAttributes");
		tracer._kernel_map[(void *) lcuGraphKernelNodeCopyAttributes] = std::string("cuGraphKernelNodeCopyAttributes");
	}
	assert(lcuGraphKernelNodeCopyAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphKernelNodeCopyAttributes(dst, src);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphKernelNodeCopyAttributes);
	}
	return res;
}

CUresult cuGraphKernelNodeGetAttribute(CUgraphNode  hNode, CUkernelNodeAttrID  attr, CUkernelNodeAttrValue * value_out)
{
	static CUresult (*lcuGraphKernelNodeGetAttribute) (CUgraphNode , CUkernelNodeAttrID , CUkernelNodeAttrValue *);
	if (!lcuGraphKernelNodeGetAttribute) {
		lcuGraphKernelNodeGetAttribute = (CUresult (*) (CUgraphNode , CUkernelNodeAttrID , CUkernelNodeAttrValue *)) dlsym(RTLD_NEXT, "cuGraphKernelNodeGetAttribute");
		tracer._kernel_map[(void *) lcuGraphKernelNodeGetAttribute] = std::string("cuGraphKernelNodeGetAttribute");
	}
	assert(lcuGraphKernelNodeGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphKernelNodeGetAttribute(hNode, attr, value_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphKernelNodeGetAttribute);
	}
	return res;
}

CUresult cuGraphKernelNodeSetAttribute(CUgraphNode  hNode, CUkernelNodeAttrID  attr, const CUkernelNodeAttrValue * value)
{
	static CUresult (*lcuGraphKernelNodeSetAttribute) (CUgraphNode , CUkernelNodeAttrID , const CUkernelNodeAttrValue *);
	if (!lcuGraphKernelNodeSetAttribute) {
		lcuGraphKernelNodeSetAttribute = (CUresult (*) (CUgraphNode , CUkernelNodeAttrID , const CUkernelNodeAttrValue *)) dlsym(RTLD_NEXT, "cuGraphKernelNodeSetAttribute");
		tracer._kernel_map[(void *) lcuGraphKernelNodeSetAttribute] = std::string("cuGraphKernelNodeSetAttribute");
	}
	assert(lcuGraphKernelNodeSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphKernelNodeSetAttribute(hNode, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphKernelNodeSetAttribute);
	}
	return res;
}

CUresult cuGraphDebugDotPrint(CUgraph  hGraph, const char * path, unsigned int  flags)
{
	static CUresult (*lcuGraphDebugDotPrint) (CUgraph , const char *, unsigned int );
	if (!lcuGraphDebugDotPrint) {
		lcuGraphDebugDotPrint = (CUresult (*) (CUgraph , const char *, unsigned int )) dlsym(RTLD_NEXT, "cuGraphDebugDotPrint");
		tracer._kernel_map[(void *) lcuGraphDebugDotPrint] = std::string("cuGraphDebugDotPrint");
	}
	assert(lcuGraphDebugDotPrint);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphDebugDotPrint(hGraph, path, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphDebugDotPrint);
	}
	return res;
}

CUresult cuUserObjectCreate(CUuserObject * object_out, void * ptr, CUhostFn  destroy, unsigned int  initialRefcount, unsigned int  flags)
{
	static CUresult (*lcuUserObjectCreate) (CUuserObject *, void *, CUhostFn , unsigned int , unsigned int );
	if (!lcuUserObjectCreate) {
		lcuUserObjectCreate = (CUresult (*) (CUuserObject *, void *, CUhostFn , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cuUserObjectCreate");
		tracer._kernel_map[(void *) lcuUserObjectCreate] = std::string("cuUserObjectCreate");
	}
	assert(lcuUserObjectCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuUserObjectCreate(object_out, ptr, destroy, initialRefcount, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuUserObjectCreate);
	}
	return res;
}

CUresult cuUserObjectRetain(CUuserObject  object, unsigned int  count)
{
	static CUresult (*lcuUserObjectRetain) (CUuserObject , unsigned int );
	if (!lcuUserObjectRetain) {
		lcuUserObjectRetain = (CUresult (*) (CUuserObject , unsigned int )) dlsym(RTLD_NEXT, "cuUserObjectRetain");
		tracer._kernel_map[(void *) lcuUserObjectRetain] = std::string("cuUserObjectRetain");
	}
	assert(lcuUserObjectRetain);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuUserObjectRetain(object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuUserObjectRetain);
	}
	return res;
}

CUresult cuUserObjectRelease(CUuserObject  object, unsigned int  count)
{
	static CUresult (*lcuUserObjectRelease) (CUuserObject , unsigned int );
	if (!lcuUserObjectRelease) {
		lcuUserObjectRelease = (CUresult (*) (CUuserObject , unsigned int )) dlsym(RTLD_NEXT, "cuUserObjectRelease");
		tracer._kernel_map[(void *) lcuUserObjectRelease] = std::string("cuUserObjectRelease");
	}
	assert(lcuUserObjectRelease);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuUserObjectRelease(object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuUserObjectRelease);
	}
	return res;
}

CUresult cuGraphRetainUserObject(CUgraph  graph, CUuserObject  object, unsigned int  count, unsigned int  flags)
{
	static CUresult (*lcuGraphRetainUserObject) (CUgraph , CUuserObject , unsigned int , unsigned int );
	if (!lcuGraphRetainUserObject) {
		lcuGraphRetainUserObject = (CUresult (*) (CUgraph , CUuserObject , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cuGraphRetainUserObject");
		tracer._kernel_map[(void *) lcuGraphRetainUserObject] = std::string("cuGraphRetainUserObject");
	}
	assert(lcuGraphRetainUserObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphRetainUserObject(graph, object, count, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphRetainUserObject);
	}
	return res;
}

CUresult cuGraphReleaseUserObject(CUgraph  graph, CUuserObject  object, unsigned int  count)
{
	static CUresult (*lcuGraphReleaseUserObject) (CUgraph , CUuserObject , unsigned int );
	if (!lcuGraphReleaseUserObject) {
		lcuGraphReleaseUserObject = (CUresult (*) (CUgraph , CUuserObject , unsigned int )) dlsym(RTLD_NEXT, "cuGraphReleaseUserObject");
		tracer._kernel_map[(void *) lcuGraphReleaseUserObject] = std::string("cuGraphReleaseUserObject");
	}
	assert(lcuGraphReleaseUserObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphReleaseUserObject(graph, object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphReleaseUserObject);
	}
	return res;
}

CUresult cuGraphAddNode(CUgraphNode * phGraphNode, CUgraph  hGraph, const CUgraphNode * dependencies, size_t  numDependencies, CUgraphNodeParams * nodeParams)
{
	static CUresult (*lcuGraphAddNode) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUgraphNodeParams *);
	if (!lcuGraphAddNode) {
		lcuGraphAddNode = (CUresult (*) (CUgraphNode *, CUgraph , const CUgraphNode *, size_t , CUgraphNodeParams *)) dlsym(RTLD_NEXT, "cuGraphAddNode");
		tracer._kernel_map[(void *) lcuGraphAddNode] = std::string("cuGraphAddNode");
	}
	assert(lcuGraphAddNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphAddNode(phGraphNode, hGraph, dependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphAddNode);
	}
	return res;
}

CUresult cuGraphNodeSetParams(CUgraphNode  hNode, CUgraphNodeParams * nodeParams)
{
	static CUresult (*lcuGraphNodeSetParams) (CUgraphNode , CUgraphNodeParams *);
	if (!lcuGraphNodeSetParams) {
		lcuGraphNodeSetParams = (CUresult (*) (CUgraphNode , CUgraphNodeParams *)) dlsym(RTLD_NEXT, "cuGraphNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphNodeSetParams] = std::string("cuGraphNodeSetParams");
	}
	assert(lcuGraphNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphNodeSetParams);
	}
	return res;
}

CUresult cuGraphExecNodeSetParams(CUgraphExec  hGraphExec, CUgraphNode  hNode, CUgraphNodeParams * nodeParams)
{
	static CUresult (*lcuGraphExecNodeSetParams) (CUgraphExec , CUgraphNode , CUgraphNodeParams *);
	if (!lcuGraphExecNodeSetParams) {
		lcuGraphExecNodeSetParams = (CUresult (*) (CUgraphExec , CUgraphNode , CUgraphNodeParams *)) dlsym(RTLD_NEXT, "cuGraphExecNodeSetParams");
		tracer._kernel_map[(void *) lcuGraphExecNodeSetParams] = std::string("cuGraphExecNodeSetParams");
	}
	assert(lcuGraphExecNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphExecNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphExecNodeSetParams);
	}
	return res;
}

CUresult cuOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, CUfunction  func, int  blockSize, size_t  dynamicSMemSize)
{
	static CUresult (*lcuOccupancyMaxActiveBlocksPerMultiprocessor) (int *, CUfunction , int , size_t );
	if (!lcuOccupancyMaxActiveBlocksPerMultiprocessor) {
		lcuOccupancyMaxActiveBlocksPerMultiprocessor = (CUresult (*) (int *, CUfunction , int , size_t )) dlsym(RTLD_NEXT, "cuOccupancyMaxActiveBlocksPerMultiprocessor");
		tracer._kernel_map[(void *) lcuOccupancyMaxActiveBlocksPerMultiprocessor] = std::string("cuOccupancyMaxActiveBlocksPerMultiprocessor");
	}
	assert(lcuOccupancyMaxActiveBlocksPerMultiprocessor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks, func, blockSize, dynamicSMemSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxActiveBlocksPerMultiprocessor);
	}
	return res;
}

CUresult cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, CUfunction  func, int  blockSize, size_t  dynamicSMemSize, unsigned int  flags)
{
	static CUresult (*lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) (int *, CUfunction , int , size_t , unsigned int );
	if (!lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) {
		lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = (CUresult (*) (int *, CUfunction , int , size_t , unsigned int )) dlsym(RTLD_NEXT, "cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags");
		tracer._kernel_map[(void *) lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags] = std::string("cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags");
	}
	assert(lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, func, blockSize, dynamicSMemSize, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags);
	}
	return res;
}

CUresult cuOccupancyMaxPotentialBlockSize(int * minGridSize, int * blockSize, CUfunction  func, CUoccupancyB2DSize  blockSizeToDynamicSMemSize, size_t  dynamicSMemSize, int  blockSizeLimit)
{
	static CUresult (*lcuOccupancyMaxPotentialBlockSize) (int *, int *, CUfunction , CUoccupancyB2DSize , size_t , int );
	if (!lcuOccupancyMaxPotentialBlockSize) {
		lcuOccupancyMaxPotentialBlockSize = (CUresult (*) (int *, int *, CUfunction , CUoccupancyB2DSize , size_t , int )) dlsym(RTLD_NEXT, "cuOccupancyMaxPotentialBlockSize");
		tracer._kernel_map[(void *) lcuOccupancyMaxPotentialBlockSize] = std::string("cuOccupancyMaxPotentialBlockSize");
	}
	assert(lcuOccupancyMaxPotentialBlockSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxPotentialBlockSize(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxPotentialBlockSize);
	}
	return res;
}

CUresult cuOccupancyMaxPotentialBlockSizeWithFlags(int * minGridSize, int * blockSize, CUfunction  func, CUoccupancyB2DSize  blockSizeToDynamicSMemSize, size_t  dynamicSMemSize, int  blockSizeLimit, unsigned int  flags)
{
	static CUresult (*lcuOccupancyMaxPotentialBlockSizeWithFlags) (int *, int *, CUfunction , CUoccupancyB2DSize , size_t , int , unsigned int );
	if (!lcuOccupancyMaxPotentialBlockSizeWithFlags) {
		lcuOccupancyMaxPotentialBlockSizeWithFlags = (CUresult (*) (int *, int *, CUfunction , CUoccupancyB2DSize , size_t , int , unsigned int )) dlsym(RTLD_NEXT, "cuOccupancyMaxPotentialBlockSizeWithFlags");
		tracer._kernel_map[(void *) lcuOccupancyMaxPotentialBlockSizeWithFlags] = std::string("cuOccupancyMaxPotentialBlockSizeWithFlags");
	}
	assert(lcuOccupancyMaxPotentialBlockSizeWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxPotentialBlockSizeWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxPotentialBlockSizeWithFlags);
	}
	return res;
}

CUresult cuOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, CUfunction  func, int  numBlocks, int  blockSize)
{
	static CUresult (*lcuOccupancyAvailableDynamicSMemPerBlock) (size_t *, CUfunction , int , int );
	if (!lcuOccupancyAvailableDynamicSMemPerBlock) {
		lcuOccupancyAvailableDynamicSMemPerBlock = (CUresult (*) (size_t *, CUfunction , int , int )) dlsym(RTLD_NEXT, "cuOccupancyAvailableDynamicSMemPerBlock");
		tracer._kernel_map[(void *) lcuOccupancyAvailableDynamicSMemPerBlock] = std::string("cuOccupancyAvailableDynamicSMemPerBlock");
	}
	assert(lcuOccupancyAvailableDynamicSMemPerBlock);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, func, numBlocks, blockSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyAvailableDynamicSMemPerBlock);
	}
	return res;
}

CUresult cuOccupancyMaxPotentialClusterSize(int * clusterSize, CUfunction  func, const CUlaunchConfig * config)
{
	static CUresult (*lcuOccupancyMaxPotentialClusterSize) (int *, CUfunction , const CUlaunchConfig *);
	if (!lcuOccupancyMaxPotentialClusterSize) {
		lcuOccupancyMaxPotentialClusterSize = (CUresult (*) (int *, CUfunction , const CUlaunchConfig *)) dlsym(RTLD_NEXT, "cuOccupancyMaxPotentialClusterSize");
		tracer._kernel_map[(void *) lcuOccupancyMaxPotentialClusterSize] = std::string("cuOccupancyMaxPotentialClusterSize");
	}
	assert(lcuOccupancyMaxPotentialClusterSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxPotentialClusterSize(clusterSize, func, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxPotentialClusterSize);
	}
	return res;
}

CUresult cuOccupancyMaxActiveClusters(int * numClusters, CUfunction  func, const CUlaunchConfig * config)
{
	static CUresult (*lcuOccupancyMaxActiveClusters) (int *, CUfunction , const CUlaunchConfig *);
	if (!lcuOccupancyMaxActiveClusters) {
		lcuOccupancyMaxActiveClusters = (CUresult (*) (int *, CUfunction , const CUlaunchConfig *)) dlsym(RTLD_NEXT, "cuOccupancyMaxActiveClusters");
		tracer._kernel_map[(void *) lcuOccupancyMaxActiveClusters] = std::string("cuOccupancyMaxActiveClusters");
	}
	assert(lcuOccupancyMaxActiveClusters);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuOccupancyMaxActiveClusters(numClusters, func, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuOccupancyMaxActiveClusters);
	}
	return res;
}

CUresult cuTexRefSetArray(CUtexref  hTexRef, CUarray  hArray, unsigned int  Flags)
{
	static CUresult (*lcuTexRefSetArray) (CUtexref , CUarray , unsigned int );
	if (!lcuTexRefSetArray) {
		lcuTexRefSetArray = (CUresult (*) (CUtexref , CUarray , unsigned int )) dlsym(RTLD_NEXT, "cuTexRefSetArray");
		tracer._kernel_map[(void *) lcuTexRefSetArray] = std::string("cuTexRefSetArray");
	}
	assert(lcuTexRefSetArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetArray(hTexRef, hArray, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetArray);
	}
	return res;
}

CUresult cuTexRefSetMipmappedArray(CUtexref  hTexRef, CUmipmappedArray  hMipmappedArray, unsigned int  Flags)
{
	static CUresult (*lcuTexRefSetMipmappedArray) (CUtexref , CUmipmappedArray , unsigned int );
	if (!lcuTexRefSetMipmappedArray) {
		lcuTexRefSetMipmappedArray = (CUresult (*) (CUtexref , CUmipmappedArray , unsigned int )) dlsym(RTLD_NEXT, "cuTexRefSetMipmappedArray");
		tracer._kernel_map[(void *) lcuTexRefSetMipmappedArray] = std::string("cuTexRefSetMipmappedArray");
	}
	assert(lcuTexRefSetMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetMipmappedArray(hTexRef, hMipmappedArray, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetMipmappedArray);
	}
	return res;
}

CUresult cuTexRefSetAddress_v2(size_t * ByteOffset, CUtexref  hTexRef, CUdeviceptr  dptr, size_t  bytes)
{
	static CUresult (*lcuTexRefSetAddress_v2) (size_t *, CUtexref , CUdeviceptr , size_t );
	if (!lcuTexRefSetAddress_v2) {
		lcuTexRefSetAddress_v2 = (CUresult (*) (size_t *, CUtexref , CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuTexRefSetAddress_v2");
		tracer._kernel_map[(void *) lcuTexRefSetAddress_v2] = std::string("cuTexRefSetAddress_v2");
	}
	assert(lcuTexRefSetAddress_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetAddress_v2(ByteOffset, hTexRef, dptr, bytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetAddress_v2);
	}
	return res;
}

CUresult cuTexRefSetAddress2D_v3(CUtexref  hTexRef, const CUDA_ARRAY_DESCRIPTOR * desc, CUdeviceptr  dptr, size_t  Pitch)
{
	static CUresult (*lcuTexRefSetAddress2D_v3) (CUtexref , const CUDA_ARRAY_DESCRIPTOR *, CUdeviceptr , size_t );
	if (!lcuTexRefSetAddress2D_v3) {
		lcuTexRefSetAddress2D_v3 = (CUresult (*) (CUtexref , const CUDA_ARRAY_DESCRIPTOR *, CUdeviceptr , size_t )) dlsym(RTLD_NEXT, "cuTexRefSetAddress2D_v3");
		tracer._kernel_map[(void *) lcuTexRefSetAddress2D_v3] = std::string("cuTexRefSetAddress2D_v3");
	}
	assert(lcuTexRefSetAddress2D_v3);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetAddress2D_v3(hTexRef, desc, dptr, Pitch);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetAddress2D_v3);
	}
	return res;
}

CUresult cuTexRefSetFormat(CUtexref  hTexRef, CUarray_format  fmt, int  NumPackedComponents)
{
	static CUresult (*lcuTexRefSetFormat) (CUtexref , CUarray_format , int );
	if (!lcuTexRefSetFormat) {
		lcuTexRefSetFormat = (CUresult (*) (CUtexref , CUarray_format , int )) dlsym(RTLD_NEXT, "cuTexRefSetFormat");
		tracer._kernel_map[(void *) lcuTexRefSetFormat] = std::string("cuTexRefSetFormat");
	}
	assert(lcuTexRefSetFormat);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetFormat(hTexRef, fmt, NumPackedComponents);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetFormat);
	}
	return res;
}

CUresult cuTexRefSetAddressMode(CUtexref  hTexRef, int  dim, CUaddress_mode  am)
{
	static CUresult (*lcuTexRefSetAddressMode) (CUtexref , int , CUaddress_mode );
	if (!lcuTexRefSetAddressMode) {
		lcuTexRefSetAddressMode = (CUresult (*) (CUtexref , int , CUaddress_mode )) dlsym(RTLD_NEXT, "cuTexRefSetAddressMode");
		tracer._kernel_map[(void *) lcuTexRefSetAddressMode] = std::string("cuTexRefSetAddressMode");
	}
	assert(lcuTexRefSetAddressMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetAddressMode(hTexRef, dim, am);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetAddressMode);
	}
	return res;
}

CUresult cuTexRefSetFilterMode(CUtexref  hTexRef, CUfilter_mode  fm)
{
	static CUresult (*lcuTexRefSetFilterMode) (CUtexref , CUfilter_mode );
	if (!lcuTexRefSetFilterMode) {
		lcuTexRefSetFilterMode = (CUresult (*) (CUtexref , CUfilter_mode )) dlsym(RTLD_NEXT, "cuTexRefSetFilterMode");
		tracer._kernel_map[(void *) lcuTexRefSetFilterMode] = std::string("cuTexRefSetFilterMode");
	}
	assert(lcuTexRefSetFilterMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetFilterMode(hTexRef, fm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetFilterMode);
	}
	return res;
}

CUresult cuTexRefSetMipmapFilterMode(CUtexref  hTexRef, CUfilter_mode  fm)
{
	static CUresult (*lcuTexRefSetMipmapFilterMode) (CUtexref , CUfilter_mode );
	if (!lcuTexRefSetMipmapFilterMode) {
		lcuTexRefSetMipmapFilterMode = (CUresult (*) (CUtexref , CUfilter_mode )) dlsym(RTLD_NEXT, "cuTexRefSetMipmapFilterMode");
		tracer._kernel_map[(void *) lcuTexRefSetMipmapFilterMode] = std::string("cuTexRefSetMipmapFilterMode");
	}
	assert(lcuTexRefSetMipmapFilterMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetMipmapFilterMode(hTexRef, fm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetMipmapFilterMode);
	}
	return res;
}

CUresult cuTexRefSetMipmapLevelBias(CUtexref  hTexRef, float  bias)
{
	static CUresult (*lcuTexRefSetMipmapLevelBias) (CUtexref , float );
	if (!lcuTexRefSetMipmapLevelBias) {
		lcuTexRefSetMipmapLevelBias = (CUresult (*) (CUtexref , float )) dlsym(RTLD_NEXT, "cuTexRefSetMipmapLevelBias");
		tracer._kernel_map[(void *) lcuTexRefSetMipmapLevelBias] = std::string("cuTexRefSetMipmapLevelBias");
	}
	assert(lcuTexRefSetMipmapLevelBias);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetMipmapLevelBias(hTexRef, bias);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetMipmapLevelBias);
	}
	return res;
}

CUresult cuTexRefSetMipmapLevelClamp(CUtexref  hTexRef, float  minMipmapLevelClamp, float  maxMipmapLevelClamp)
{
	static CUresult (*lcuTexRefSetMipmapLevelClamp) (CUtexref , float , float );
	if (!lcuTexRefSetMipmapLevelClamp) {
		lcuTexRefSetMipmapLevelClamp = (CUresult (*) (CUtexref , float , float )) dlsym(RTLD_NEXT, "cuTexRefSetMipmapLevelClamp");
		tracer._kernel_map[(void *) lcuTexRefSetMipmapLevelClamp] = std::string("cuTexRefSetMipmapLevelClamp");
	}
	assert(lcuTexRefSetMipmapLevelClamp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetMipmapLevelClamp(hTexRef, minMipmapLevelClamp, maxMipmapLevelClamp);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetMipmapLevelClamp);
	}
	return res;
}

CUresult cuTexRefSetMaxAnisotropy(CUtexref  hTexRef, unsigned int  maxAniso)
{
	static CUresult (*lcuTexRefSetMaxAnisotropy) (CUtexref , unsigned int );
	if (!lcuTexRefSetMaxAnisotropy) {
		lcuTexRefSetMaxAnisotropy = (CUresult (*) (CUtexref , unsigned int )) dlsym(RTLD_NEXT, "cuTexRefSetMaxAnisotropy");
		tracer._kernel_map[(void *) lcuTexRefSetMaxAnisotropy] = std::string("cuTexRefSetMaxAnisotropy");
	}
	assert(lcuTexRefSetMaxAnisotropy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetMaxAnisotropy(hTexRef, maxAniso);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetMaxAnisotropy);
	}
	return res;
}

CUresult cuTexRefSetBorderColor(CUtexref  hTexRef, float * pBorderColor)
{
	static CUresult (*lcuTexRefSetBorderColor) (CUtexref , float *);
	if (!lcuTexRefSetBorderColor) {
		lcuTexRefSetBorderColor = (CUresult (*) (CUtexref , float *)) dlsym(RTLD_NEXT, "cuTexRefSetBorderColor");
		tracer._kernel_map[(void *) lcuTexRefSetBorderColor] = std::string("cuTexRefSetBorderColor");
	}
	assert(lcuTexRefSetBorderColor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetBorderColor(hTexRef, pBorderColor);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetBorderColor);
	}
	return res;
}

CUresult cuTexRefSetFlags(CUtexref  hTexRef, unsigned int  Flags)
{
	static CUresult (*lcuTexRefSetFlags) (CUtexref , unsigned int );
	if (!lcuTexRefSetFlags) {
		lcuTexRefSetFlags = (CUresult (*) (CUtexref , unsigned int )) dlsym(RTLD_NEXT, "cuTexRefSetFlags");
		tracer._kernel_map[(void *) lcuTexRefSetFlags] = std::string("cuTexRefSetFlags");
	}
	assert(lcuTexRefSetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefSetFlags(hTexRef, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefSetFlags);
	}
	return res;
}

CUresult cuTexRefGetAddress_v2(CUdeviceptr * pdptr, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetAddress_v2) (CUdeviceptr *, CUtexref );
	if (!lcuTexRefGetAddress_v2) {
		lcuTexRefGetAddress_v2 = (CUresult (*) (CUdeviceptr *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetAddress_v2");
		tracer._kernel_map[(void *) lcuTexRefGetAddress_v2] = std::string("cuTexRefGetAddress_v2");
	}
	assert(lcuTexRefGetAddress_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetAddress_v2(pdptr, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetAddress_v2);
	}
	return res;
}

CUresult cuTexRefGetArray(CUarray * phArray, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetArray) (CUarray *, CUtexref );
	if (!lcuTexRefGetArray) {
		lcuTexRefGetArray = (CUresult (*) (CUarray *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetArray");
		tracer._kernel_map[(void *) lcuTexRefGetArray] = std::string("cuTexRefGetArray");
	}
	assert(lcuTexRefGetArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetArray(phArray, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetArray);
	}
	return res;
}

CUresult cuTexRefGetMipmappedArray(CUmipmappedArray * phMipmappedArray, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetMipmappedArray) (CUmipmappedArray *, CUtexref );
	if (!lcuTexRefGetMipmappedArray) {
		lcuTexRefGetMipmappedArray = (CUresult (*) (CUmipmappedArray *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetMipmappedArray");
		tracer._kernel_map[(void *) lcuTexRefGetMipmappedArray] = std::string("cuTexRefGetMipmappedArray");
	}
	assert(lcuTexRefGetMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetMipmappedArray(phMipmappedArray, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetMipmappedArray);
	}
	return res;
}

CUresult cuTexRefGetAddressMode(CUaddress_mode * pam, CUtexref  hTexRef, int  dim)
{
	static CUresult (*lcuTexRefGetAddressMode) (CUaddress_mode *, CUtexref , int );
	if (!lcuTexRefGetAddressMode) {
		lcuTexRefGetAddressMode = (CUresult (*) (CUaddress_mode *, CUtexref , int )) dlsym(RTLD_NEXT, "cuTexRefGetAddressMode");
		tracer._kernel_map[(void *) lcuTexRefGetAddressMode] = std::string("cuTexRefGetAddressMode");
	}
	assert(lcuTexRefGetAddressMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetAddressMode(pam, hTexRef, dim);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetAddressMode);
	}
	return res;
}

CUresult cuTexRefGetFilterMode(CUfilter_mode * pfm, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetFilterMode) (CUfilter_mode *, CUtexref );
	if (!lcuTexRefGetFilterMode) {
		lcuTexRefGetFilterMode = (CUresult (*) (CUfilter_mode *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetFilterMode");
		tracer._kernel_map[(void *) lcuTexRefGetFilterMode] = std::string("cuTexRefGetFilterMode");
	}
	assert(lcuTexRefGetFilterMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetFilterMode(pfm, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetFilterMode);
	}
	return res;
}

CUresult cuTexRefGetFormat(CUarray_format * pFormat, int * pNumChannels, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetFormat) (CUarray_format *, int *, CUtexref );
	if (!lcuTexRefGetFormat) {
		lcuTexRefGetFormat = (CUresult (*) (CUarray_format *, int *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetFormat");
		tracer._kernel_map[(void *) lcuTexRefGetFormat] = std::string("cuTexRefGetFormat");
	}
	assert(lcuTexRefGetFormat);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetFormat(pFormat, pNumChannels, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetFormat);
	}
	return res;
}

CUresult cuTexRefGetMipmapFilterMode(CUfilter_mode * pfm, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetMipmapFilterMode) (CUfilter_mode *, CUtexref );
	if (!lcuTexRefGetMipmapFilterMode) {
		lcuTexRefGetMipmapFilterMode = (CUresult (*) (CUfilter_mode *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetMipmapFilterMode");
		tracer._kernel_map[(void *) lcuTexRefGetMipmapFilterMode] = std::string("cuTexRefGetMipmapFilterMode");
	}
	assert(lcuTexRefGetMipmapFilterMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetMipmapFilterMode(pfm, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetMipmapFilterMode);
	}
	return res;
}

CUresult cuTexRefGetMipmapLevelBias(float * pbias, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetMipmapLevelBias) (float *, CUtexref );
	if (!lcuTexRefGetMipmapLevelBias) {
		lcuTexRefGetMipmapLevelBias = (CUresult (*) (float *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetMipmapLevelBias");
		tracer._kernel_map[(void *) lcuTexRefGetMipmapLevelBias] = std::string("cuTexRefGetMipmapLevelBias");
	}
	assert(lcuTexRefGetMipmapLevelBias);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetMipmapLevelBias(pbias, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetMipmapLevelBias);
	}
	return res;
}

CUresult cuTexRefGetMipmapLevelClamp(float * pminMipmapLevelClamp, float * pmaxMipmapLevelClamp, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetMipmapLevelClamp) (float *, float *, CUtexref );
	if (!lcuTexRefGetMipmapLevelClamp) {
		lcuTexRefGetMipmapLevelClamp = (CUresult (*) (float *, float *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetMipmapLevelClamp");
		tracer._kernel_map[(void *) lcuTexRefGetMipmapLevelClamp] = std::string("cuTexRefGetMipmapLevelClamp");
	}
	assert(lcuTexRefGetMipmapLevelClamp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetMipmapLevelClamp(pminMipmapLevelClamp, pmaxMipmapLevelClamp, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetMipmapLevelClamp);
	}
	return res;
}

CUresult cuTexRefGetMaxAnisotropy(int * pmaxAniso, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetMaxAnisotropy) (int *, CUtexref );
	if (!lcuTexRefGetMaxAnisotropy) {
		lcuTexRefGetMaxAnisotropy = (CUresult (*) (int *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetMaxAnisotropy");
		tracer._kernel_map[(void *) lcuTexRefGetMaxAnisotropy] = std::string("cuTexRefGetMaxAnisotropy");
	}
	assert(lcuTexRefGetMaxAnisotropy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetMaxAnisotropy(pmaxAniso, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetMaxAnisotropy);
	}
	return res;
}

CUresult cuTexRefGetBorderColor(float * pBorderColor, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetBorderColor) (float *, CUtexref );
	if (!lcuTexRefGetBorderColor) {
		lcuTexRefGetBorderColor = (CUresult (*) (float *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetBorderColor");
		tracer._kernel_map[(void *) lcuTexRefGetBorderColor] = std::string("cuTexRefGetBorderColor");
	}
	assert(lcuTexRefGetBorderColor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetBorderColor(pBorderColor, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetBorderColor);
	}
	return res;
}

CUresult cuTexRefGetFlags(unsigned int * pFlags, CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefGetFlags) (unsigned int *, CUtexref );
	if (!lcuTexRefGetFlags) {
		lcuTexRefGetFlags = (CUresult (*) (unsigned int *, CUtexref )) dlsym(RTLD_NEXT, "cuTexRefGetFlags");
		tracer._kernel_map[(void *) lcuTexRefGetFlags] = std::string("cuTexRefGetFlags");
	}
	assert(lcuTexRefGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefGetFlags(pFlags, hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefGetFlags);
	}
	return res;
}

CUresult cuTexRefCreate(CUtexref * pTexRef)
{
	static CUresult (*lcuTexRefCreate) (CUtexref *);
	if (!lcuTexRefCreate) {
		lcuTexRefCreate = (CUresult (*) (CUtexref *)) dlsym(RTLD_NEXT, "cuTexRefCreate");
		tracer._kernel_map[(void *) lcuTexRefCreate] = std::string("cuTexRefCreate");
	}
	assert(lcuTexRefCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefCreate(pTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefCreate);
	}
	return res;
}

CUresult cuTexRefDestroy(CUtexref  hTexRef)
{
	static CUresult (*lcuTexRefDestroy) (CUtexref );
	if (!lcuTexRefDestroy) {
		lcuTexRefDestroy = (CUresult (*) (CUtexref )) dlsym(RTLD_NEXT, "cuTexRefDestroy");
		tracer._kernel_map[(void *) lcuTexRefDestroy] = std::string("cuTexRefDestroy");
	}
	assert(lcuTexRefDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexRefDestroy(hTexRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexRefDestroy);
	}
	return res;
}

CUresult cuSurfRefSetArray(CUsurfref  hSurfRef, CUarray  hArray, unsigned int  Flags)
{
	static CUresult (*lcuSurfRefSetArray) (CUsurfref , CUarray , unsigned int );
	if (!lcuSurfRefSetArray) {
		lcuSurfRefSetArray = (CUresult (*) (CUsurfref , CUarray , unsigned int )) dlsym(RTLD_NEXT, "cuSurfRefSetArray");
		tracer._kernel_map[(void *) lcuSurfRefSetArray] = std::string("cuSurfRefSetArray");
	}
	assert(lcuSurfRefSetArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSurfRefSetArray(hSurfRef, hArray, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSurfRefSetArray);
	}
	return res;
}

CUresult cuSurfRefGetArray(CUarray * phArray, CUsurfref  hSurfRef)
{
	static CUresult (*lcuSurfRefGetArray) (CUarray *, CUsurfref );
	if (!lcuSurfRefGetArray) {
		lcuSurfRefGetArray = (CUresult (*) (CUarray *, CUsurfref )) dlsym(RTLD_NEXT, "cuSurfRefGetArray");
		tracer._kernel_map[(void *) lcuSurfRefGetArray] = std::string("cuSurfRefGetArray");
	}
	assert(lcuSurfRefGetArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSurfRefGetArray(phArray, hSurfRef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSurfRefGetArray);
	}
	return res;
}

CUresult cuTexObjectCreate(CUtexObject * pTexObject, const CUDA_RESOURCE_DESC * pResDesc, const CUDA_TEXTURE_DESC * pTexDesc, const CUDA_RESOURCE_VIEW_DESC * pResViewDesc)
{
	static CUresult (*lcuTexObjectCreate) (CUtexObject *, const CUDA_RESOURCE_DESC *, const CUDA_TEXTURE_DESC *, const CUDA_RESOURCE_VIEW_DESC *);
	if (!lcuTexObjectCreate) {
		lcuTexObjectCreate = (CUresult (*) (CUtexObject *, const CUDA_RESOURCE_DESC *, const CUDA_TEXTURE_DESC *, const CUDA_RESOURCE_VIEW_DESC *)) dlsym(RTLD_NEXT, "cuTexObjectCreate");
		tracer._kernel_map[(void *) lcuTexObjectCreate] = std::string("cuTexObjectCreate");
	}
	assert(lcuTexObjectCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexObjectCreate(pTexObject, pResDesc, pTexDesc, pResViewDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexObjectCreate);
	}
	return res;
}

CUresult cuTexObjectDestroy(CUtexObject  texObject)
{
	static CUresult (*lcuTexObjectDestroy) (CUtexObject );
	if (!lcuTexObjectDestroy) {
		lcuTexObjectDestroy = (CUresult (*) (CUtexObject )) dlsym(RTLD_NEXT, "cuTexObjectDestroy");
		tracer._kernel_map[(void *) lcuTexObjectDestroy] = std::string("cuTexObjectDestroy");
	}
	assert(lcuTexObjectDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexObjectDestroy(texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexObjectDestroy);
	}
	return res;
}

CUresult cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUtexObject  texObject)
{
	static CUresult (*lcuTexObjectGetResourceDesc) (CUDA_RESOURCE_DESC *, CUtexObject );
	if (!lcuTexObjectGetResourceDesc) {
		lcuTexObjectGetResourceDesc = (CUresult (*) (CUDA_RESOURCE_DESC *, CUtexObject )) dlsym(RTLD_NEXT, "cuTexObjectGetResourceDesc");
		tracer._kernel_map[(void *) lcuTexObjectGetResourceDesc] = std::string("cuTexObjectGetResourceDesc");
	}
	assert(lcuTexObjectGetResourceDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexObjectGetResourceDesc(pResDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexObjectGetResourceDesc);
	}
	return res;
}

CUresult cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * pTexDesc, CUtexObject  texObject)
{
	static CUresult (*lcuTexObjectGetTextureDesc) (CUDA_TEXTURE_DESC *, CUtexObject );
	if (!lcuTexObjectGetTextureDesc) {
		lcuTexObjectGetTextureDesc = (CUresult (*) (CUDA_TEXTURE_DESC *, CUtexObject )) dlsym(RTLD_NEXT, "cuTexObjectGetTextureDesc");
		tracer._kernel_map[(void *) lcuTexObjectGetTextureDesc] = std::string("cuTexObjectGetTextureDesc");
	}
	assert(lcuTexObjectGetTextureDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexObjectGetTextureDesc(pTexDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexObjectGetTextureDesc);
	}
	return res;
}

CUresult cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * pResViewDesc, CUtexObject  texObject)
{
	static CUresult (*lcuTexObjectGetResourceViewDesc) (CUDA_RESOURCE_VIEW_DESC *, CUtexObject );
	if (!lcuTexObjectGetResourceViewDesc) {
		lcuTexObjectGetResourceViewDesc = (CUresult (*) (CUDA_RESOURCE_VIEW_DESC *, CUtexObject )) dlsym(RTLD_NEXT, "cuTexObjectGetResourceViewDesc");
		tracer._kernel_map[(void *) lcuTexObjectGetResourceViewDesc] = std::string("cuTexObjectGetResourceViewDesc");
	}
	assert(lcuTexObjectGetResourceViewDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTexObjectGetResourceViewDesc(pResViewDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTexObjectGetResourceViewDesc);
	}
	return res;
}

CUresult cuSurfObjectCreate(CUsurfObject * pSurfObject, const CUDA_RESOURCE_DESC * pResDesc)
{
	static CUresult (*lcuSurfObjectCreate) (CUsurfObject *, const CUDA_RESOURCE_DESC *);
	if (!lcuSurfObjectCreate) {
		lcuSurfObjectCreate = (CUresult (*) (CUsurfObject *, const CUDA_RESOURCE_DESC *)) dlsym(RTLD_NEXT, "cuSurfObjectCreate");
		tracer._kernel_map[(void *) lcuSurfObjectCreate] = std::string("cuSurfObjectCreate");
	}
	assert(lcuSurfObjectCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSurfObjectCreate(pSurfObject, pResDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSurfObjectCreate);
	}
	return res;
}

CUresult cuSurfObjectDestroy(CUsurfObject  surfObject)
{
	static CUresult (*lcuSurfObjectDestroy) (CUsurfObject );
	if (!lcuSurfObjectDestroy) {
		lcuSurfObjectDestroy = (CUresult (*) (CUsurfObject )) dlsym(RTLD_NEXT, "cuSurfObjectDestroy");
		tracer._kernel_map[(void *) lcuSurfObjectDestroy] = std::string("cuSurfObjectDestroy");
	}
	assert(lcuSurfObjectDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSurfObjectDestroy(surfObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSurfObjectDestroy);
	}
	return res;
}

CUresult cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUsurfObject  surfObject)
{
	static CUresult (*lcuSurfObjectGetResourceDesc) (CUDA_RESOURCE_DESC *, CUsurfObject );
	if (!lcuSurfObjectGetResourceDesc) {
		lcuSurfObjectGetResourceDesc = (CUresult (*) (CUDA_RESOURCE_DESC *, CUsurfObject )) dlsym(RTLD_NEXT, "cuSurfObjectGetResourceDesc");
		tracer._kernel_map[(void *) lcuSurfObjectGetResourceDesc] = std::string("cuSurfObjectGetResourceDesc");
	}
	assert(lcuSurfObjectGetResourceDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuSurfObjectGetResourceDesc(pResDesc, surfObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuSurfObjectGetResourceDesc);
	}
	return res;
}

CUresult cuTensorMapEncodeTiled(CUtensorMap * tensorMap, CUtensorMapDataType  tensorDataType, cuuint32_t  tensorRank, void * globalAddress, const cuuint64_t * globalDim, const cuuint64_t * globalStrides, const cuuint32_t * boxDim, const cuuint32_t * elementStrides, CUtensorMapInterleave  interleave, CUtensorMapSwizzle  swizzle, CUtensorMapL2promotion  l2Promotion, CUtensorMapFloatOOBfill  oobFill)
{
	static CUresult (*lcuTensorMapEncodeTiled) (CUtensorMap *, CUtensorMapDataType , cuuint32_t , void *, const cuuint64_t *, const cuuint64_t *, const cuuint32_t *, const cuuint32_t *, CUtensorMapInterleave , CUtensorMapSwizzle , CUtensorMapL2promotion , CUtensorMapFloatOOBfill );
	if (!lcuTensorMapEncodeTiled) {
		lcuTensorMapEncodeTiled = (CUresult (*) (CUtensorMap *, CUtensorMapDataType , cuuint32_t , void *, const cuuint64_t *, const cuuint64_t *, const cuuint32_t *, const cuuint32_t *, CUtensorMapInterleave , CUtensorMapSwizzle , CUtensorMapL2promotion , CUtensorMapFloatOOBfill )) dlsym(RTLD_NEXT, "cuTensorMapEncodeTiled");
		tracer._kernel_map[(void *) lcuTensorMapEncodeTiled] = std::string("cuTensorMapEncodeTiled");
	}
	assert(lcuTensorMapEncodeTiled);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTensorMapEncodeTiled(tensorMap, tensorDataType, tensorRank, globalAddress, globalDim, globalStrides, boxDim, elementStrides, interleave, swizzle, l2Promotion, oobFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTensorMapEncodeTiled);
	}
	return res;
}

CUresult cuTensorMapEncodeIm2col(CUtensorMap * tensorMap, CUtensorMapDataType  tensorDataType, cuuint32_t  tensorRank, void * globalAddress, const cuuint64_t * globalDim, const cuuint64_t * globalStrides, const int * pixelBoxLowerCorner, const int * pixelBoxUpperCorner, cuuint32_t  channelsPerPixel, cuuint32_t  pixelsPerColumn, const cuuint32_t * elementStrides, CUtensorMapInterleave  interleave, CUtensorMapSwizzle  swizzle, CUtensorMapL2promotion  l2Promotion, CUtensorMapFloatOOBfill  oobFill)
{
	static CUresult (*lcuTensorMapEncodeIm2col) (CUtensorMap *, CUtensorMapDataType , cuuint32_t , void *, const cuuint64_t *, const cuuint64_t *, const int *, const int *, cuuint32_t , cuuint32_t , const cuuint32_t *, CUtensorMapInterleave , CUtensorMapSwizzle , CUtensorMapL2promotion , CUtensorMapFloatOOBfill );
	if (!lcuTensorMapEncodeIm2col) {
		lcuTensorMapEncodeIm2col = (CUresult (*) (CUtensorMap *, CUtensorMapDataType , cuuint32_t , void *, const cuuint64_t *, const cuuint64_t *, const int *, const int *, cuuint32_t , cuuint32_t , const cuuint32_t *, CUtensorMapInterleave , CUtensorMapSwizzle , CUtensorMapL2promotion , CUtensorMapFloatOOBfill )) dlsym(RTLD_NEXT, "cuTensorMapEncodeIm2col");
		tracer._kernel_map[(void *) lcuTensorMapEncodeIm2col] = std::string("cuTensorMapEncodeIm2col");
	}
	assert(lcuTensorMapEncodeIm2col);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTensorMapEncodeIm2col(tensorMap, tensorDataType, tensorRank, globalAddress, globalDim, globalStrides, pixelBoxLowerCorner, pixelBoxUpperCorner, channelsPerPixel, pixelsPerColumn, elementStrides, interleave, swizzle, l2Promotion, oobFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTensorMapEncodeIm2col);
	}
	return res;
}

CUresult cuTensorMapReplaceAddress(CUtensorMap * tensorMap, void * globalAddress)
{
	static CUresult (*lcuTensorMapReplaceAddress) (CUtensorMap *, void *);
	if (!lcuTensorMapReplaceAddress) {
		lcuTensorMapReplaceAddress = (CUresult (*) (CUtensorMap *, void *)) dlsym(RTLD_NEXT, "cuTensorMapReplaceAddress");
		tracer._kernel_map[(void *) lcuTensorMapReplaceAddress] = std::string("cuTensorMapReplaceAddress");
	}
	assert(lcuTensorMapReplaceAddress);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuTensorMapReplaceAddress(tensorMap, globalAddress);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuTensorMapReplaceAddress);
	}
	return res;
}

CUresult cuDeviceCanAccessPeer(int * canAccessPeer, CUdevice  dev, CUdevice  peerDev)
{
	static CUresult (*lcuDeviceCanAccessPeer) (int *, CUdevice , CUdevice );
	if (!lcuDeviceCanAccessPeer) {
		lcuDeviceCanAccessPeer = (CUresult (*) (int *, CUdevice , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceCanAccessPeer");
		tracer._kernel_map[(void *) lcuDeviceCanAccessPeer] = std::string("cuDeviceCanAccessPeer");
	}
	assert(lcuDeviceCanAccessPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceCanAccessPeer(canAccessPeer, dev, peerDev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceCanAccessPeer);
	}
	return res;
}

CUresult cuCtxEnablePeerAccess(CUcontext  peerContext, unsigned int  Flags)
{
	static CUresult (*lcuCtxEnablePeerAccess) (CUcontext , unsigned int );
	if (!lcuCtxEnablePeerAccess) {
		lcuCtxEnablePeerAccess = (CUresult (*) (CUcontext , unsigned int )) dlsym(RTLD_NEXT, "cuCtxEnablePeerAccess");
		tracer._kernel_map[(void *) lcuCtxEnablePeerAccess] = std::string("cuCtxEnablePeerAccess");
	}
	assert(lcuCtxEnablePeerAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxEnablePeerAccess(peerContext, Flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxEnablePeerAccess);
	}
	return res;
}

CUresult cuCtxDisablePeerAccess(CUcontext  peerContext)
{
	static CUresult (*lcuCtxDisablePeerAccess) (CUcontext );
	if (!lcuCtxDisablePeerAccess) {
		lcuCtxDisablePeerAccess = (CUresult (*) (CUcontext )) dlsym(RTLD_NEXT, "cuCtxDisablePeerAccess");
		tracer._kernel_map[(void *) lcuCtxDisablePeerAccess] = std::string("cuCtxDisablePeerAccess");
	}
	assert(lcuCtxDisablePeerAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCtxDisablePeerAccess(peerContext);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCtxDisablePeerAccess);
	}
	return res;
}

CUresult cuDeviceGetP2PAttribute(int*  value, CUdevice_P2PAttribute  attrib, CUdevice  srcDevice, CUdevice  dstDevice)
{
	static CUresult (*lcuDeviceGetP2PAttribute) (int* , CUdevice_P2PAttribute , CUdevice , CUdevice );
	if (!lcuDeviceGetP2PAttribute) {
		lcuDeviceGetP2PAttribute = (CUresult (*) (int* , CUdevice_P2PAttribute , CUdevice , CUdevice )) dlsym(RTLD_NEXT, "cuDeviceGetP2PAttribute");
		tracer._kernel_map[(void *) lcuDeviceGetP2PAttribute] = std::string("cuDeviceGetP2PAttribute");
	}
	assert(lcuDeviceGetP2PAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuDeviceGetP2PAttribute(value, attrib, srcDevice, dstDevice);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuDeviceGetP2PAttribute);
	}
	return res;
}

CUresult cuGraphicsUnregisterResource(CUgraphicsResource  resource)
{
	static CUresult (*lcuGraphicsUnregisterResource) (CUgraphicsResource );
	if (!lcuGraphicsUnregisterResource) {
		lcuGraphicsUnregisterResource = (CUresult (*) (CUgraphicsResource )) dlsym(RTLD_NEXT, "cuGraphicsUnregisterResource");
		tracer._kernel_map[(void *) lcuGraphicsUnregisterResource] = std::string("cuGraphicsUnregisterResource");
	}
	assert(lcuGraphicsUnregisterResource);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsUnregisterResource(resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsUnregisterResource);
	}
	return res;
}

CUresult cuGraphicsSubResourceGetMappedArray(CUarray * pArray, CUgraphicsResource  resource, unsigned int  arrayIndex, unsigned int  mipLevel)
{
	static CUresult (*lcuGraphicsSubResourceGetMappedArray) (CUarray *, CUgraphicsResource , unsigned int , unsigned int );
	if (!lcuGraphicsSubResourceGetMappedArray) {
		lcuGraphicsSubResourceGetMappedArray = (CUresult (*) (CUarray *, CUgraphicsResource , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cuGraphicsSubResourceGetMappedArray");
		tracer._kernel_map[(void *) lcuGraphicsSubResourceGetMappedArray] = std::string("cuGraphicsSubResourceGetMappedArray");
	}
	assert(lcuGraphicsSubResourceGetMappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsSubResourceGetMappedArray(pArray, resource, arrayIndex, mipLevel);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsSubResourceGetMappedArray);
	}
	return res;
}

CUresult cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * pMipmappedArray, CUgraphicsResource  resource)
{
	static CUresult (*lcuGraphicsResourceGetMappedMipmappedArray) (CUmipmappedArray *, CUgraphicsResource );
	if (!lcuGraphicsResourceGetMappedMipmappedArray) {
		lcuGraphicsResourceGetMappedMipmappedArray = (CUresult (*) (CUmipmappedArray *, CUgraphicsResource )) dlsym(RTLD_NEXT, "cuGraphicsResourceGetMappedMipmappedArray");
		tracer._kernel_map[(void *) lcuGraphicsResourceGetMappedMipmappedArray] = std::string("cuGraphicsResourceGetMappedMipmappedArray");
	}
	assert(lcuGraphicsResourceGetMappedMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsResourceGetMappedMipmappedArray(pMipmappedArray, resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsResourceGetMappedMipmappedArray);
	}
	return res;
}

CUresult cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * pDevPtr, size_t * pSize, CUgraphicsResource  resource)
{
	static CUresult (*lcuGraphicsResourceGetMappedPointer_v2) (CUdeviceptr *, size_t *, CUgraphicsResource );
	if (!lcuGraphicsResourceGetMappedPointer_v2) {
		lcuGraphicsResourceGetMappedPointer_v2 = (CUresult (*) (CUdeviceptr *, size_t *, CUgraphicsResource )) dlsym(RTLD_NEXT, "cuGraphicsResourceGetMappedPointer_v2");
		tracer._kernel_map[(void *) lcuGraphicsResourceGetMappedPointer_v2] = std::string("cuGraphicsResourceGetMappedPointer_v2");
	}
	assert(lcuGraphicsResourceGetMappedPointer_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsResourceGetMappedPointer_v2(pDevPtr, pSize, resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsResourceGetMappedPointer_v2);
	}
	return res;
}

CUresult cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource  resource, unsigned int  flags)
{
	static CUresult (*lcuGraphicsResourceSetMapFlags_v2) (CUgraphicsResource , unsigned int );
	if (!lcuGraphicsResourceSetMapFlags_v2) {
		lcuGraphicsResourceSetMapFlags_v2 = (CUresult (*) (CUgraphicsResource , unsigned int )) dlsym(RTLD_NEXT, "cuGraphicsResourceSetMapFlags_v2");
		tracer._kernel_map[(void *) lcuGraphicsResourceSetMapFlags_v2] = std::string("cuGraphicsResourceSetMapFlags_v2");
	}
	assert(lcuGraphicsResourceSetMapFlags_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsResourceSetMapFlags_v2(resource, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsResourceSetMapFlags_v2);
	}
	return res;
}

CUresult cuGraphicsMapResources(unsigned int  count, CUgraphicsResource * resources, CUstream  hStream)
{
	static CUresult (*lcuGraphicsMapResources) (unsigned int , CUgraphicsResource *, CUstream );
	if (!lcuGraphicsMapResources) {
		lcuGraphicsMapResources = (CUresult (*) (unsigned int , CUgraphicsResource *, CUstream )) dlsym(RTLD_NEXT, "cuGraphicsMapResources");
		tracer._kernel_map[(void *) lcuGraphicsMapResources] = std::string("cuGraphicsMapResources");
	}
	assert(lcuGraphicsMapResources);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsMapResources(count, resources, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsMapResources);
	}
	return res;
}

CUresult cuGraphicsUnmapResources(unsigned int  count, CUgraphicsResource * resources, CUstream  hStream)
{
	static CUresult (*lcuGraphicsUnmapResources) (unsigned int , CUgraphicsResource *, CUstream );
	if (!lcuGraphicsUnmapResources) {
		lcuGraphicsUnmapResources = (CUresult (*) (unsigned int , CUgraphicsResource *, CUstream )) dlsym(RTLD_NEXT, "cuGraphicsUnmapResources");
		tracer._kernel_map[(void *) lcuGraphicsUnmapResources] = std::string("cuGraphicsUnmapResources");
	}
	assert(lcuGraphicsUnmapResources);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGraphicsUnmapResources(count, resources, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGraphicsUnmapResources);
	}
	return res;
}

CUresult cuGetProcAddress_v2(const char * symbol, void ** pfn, int  cudaVersion, cuuint64_t  flags, CUdriverProcAddressQueryResult * symbolStatus)
{
	static CUresult (*lcuGetProcAddress_v2) (const char *, void **, int , cuuint64_t , CUdriverProcAddressQueryResult *);
	if (!lcuGetProcAddress_v2) {
		lcuGetProcAddress_v2 = (CUresult (*) (const char *, void **, int , cuuint64_t , CUdriverProcAddressQueryResult *)) dlsym(RTLD_NEXT, "cuGetProcAddress_v2");
		tracer._kernel_map[(void *) lcuGetProcAddress_v2] = std::string("cuGetProcAddress_v2");
	}
	assert(lcuGetProcAddress_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGetProcAddress_v2(symbol, pfn, cudaVersion, flags, symbolStatus);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGetProcAddress_v2);
	}
	return res;
}

CUresult cuCoredumpGetAttribute(CUcoredumpSettings  attrib, void*  value, size_t * size)
{
	static CUresult (*lcuCoredumpGetAttribute) (CUcoredumpSettings , void* , size_t *);
	if (!lcuCoredumpGetAttribute) {
		lcuCoredumpGetAttribute = (CUresult (*) (CUcoredumpSettings , void* , size_t *)) dlsym(RTLD_NEXT, "cuCoredumpGetAttribute");
		tracer._kernel_map[(void *) lcuCoredumpGetAttribute] = std::string("cuCoredumpGetAttribute");
	}
	assert(lcuCoredumpGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCoredumpGetAttribute(attrib, value, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCoredumpGetAttribute);
	}
	return res;
}

CUresult cuCoredumpGetAttributeGlobal(CUcoredumpSettings  attrib, void * value, size_t * size)
{
	static CUresult (*lcuCoredumpGetAttributeGlobal) (CUcoredumpSettings , void *, size_t *);
	if (!lcuCoredumpGetAttributeGlobal) {
		lcuCoredumpGetAttributeGlobal = (CUresult (*) (CUcoredumpSettings , void *, size_t *)) dlsym(RTLD_NEXT, "cuCoredumpGetAttributeGlobal");
		tracer._kernel_map[(void *) lcuCoredumpGetAttributeGlobal] = std::string("cuCoredumpGetAttributeGlobal");
	}
	assert(lcuCoredumpGetAttributeGlobal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCoredumpGetAttributeGlobal(attrib, value, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCoredumpGetAttributeGlobal);
	}
	return res;
}

CUresult cuCoredumpSetAttribute(CUcoredumpSettings  attrib, void*  value, size_t * size)
{
	static CUresult (*lcuCoredumpSetAttribute) (CUcoredumpSettings , void* , size_t *);
	if (!lcuCoredumpSetAttribute) {
		lcuCoredumpSetAttribute = (CUresult (*) (CUcoredumpSettings , void* , size_t *)) dlsym(RTLD_NEXT, "cuCoredumpSetAttribute");
		tracer._kernel_map[(void *) lcuCoredumpSetAttribute] = std::string("cuCoredumpSetAttribute");
	}
	assert(lcuCoredumpSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCoredumpSetAttribute(attrib, value, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCoredumpSetAttribute);
	}
	return res;
}

CUresult cuCoredumpSetAttributeGlobal(CUcoredumpSettings  attrib, void * value, size_t * size)
{
	static CUresult (*lcuCoredumpSetAttributeGlobal) (CUcoredumpSettings , void *, size_t *);
	if (!lcuCoredumpSetAttributeGlobal) {
		lcuCoredumpSetAttributeGlobal = (CUresult (*) (CUcoredumpSettings , void *, size_t *)) dlsym(RTLD_NEXT, "cuCoredumpSetAttributeGlobal");
		tracer._kernel_map[(void *) lcuCoredumpSetAttributeGlobal] = std::string("cuCoredumpSetAttributeGlobal");
	}
	assert(lcuCoredumpSetAttributeGlobal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuCoredumpSetAttributeGlobal(attrib, value, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuCoredumpSetAttributeGlobal);
	}
	return res;
}

CUresult cuGetExportTable(const void ** ppExportTable, const CUuuid * pExportTableId)
{
	static CUresult (*lcuGetExportTable) (const void **, const CUuuid *);
	if (!lcuGetExportTable) {
		lcuGetExportTable = (CUresult (*) (const void **, const CUuuid *)) dlsym(RTLD_NEXT, "cuGetExportTable");
		tracer._kernel_map[(void *) lcuGetExportTable] = std::string("cuGetExportTable");
	}
	assert(lcuGetExportTable);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuGetExportTable(ppExportTable, pExportTableId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuGetExportTable);
	}
	return res;
}

cudaError_t cudaDeviceReset()
{
	static cudaError_t (*lcudaDeviceReset) ();
	if (!lcudaDeviceReset) {
		lcudaDeviceReset = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaDeviceReset");
		tracer._kernel_map[(void *) lcudaDeviceReset] = std::string("cudaDeviceReset");
	}
	assert(lcudaDeviceReset);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceReset();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceReset);
	}
	return res;
}


cudaError_t cudaDeviceSynchronize()
{
	static cudaError_t (*lcudaDeviceSynchronize) ();
	if (!lcudaDeviceSynchronize) {
		lcudaDeviceSynchronize = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaDeviceSynchronize");
		tracer._kernel_map[(void *) lcudaDeviceSynchronize] = std::string("cudaDeviceSynchronize");
	}
	assert(lcudaDeviceSynchronize);
    
    // Only matters when collecting CPU trace
    
    auto err = lcudaDeviceSynchronize();
    

    

    return lcudaDeviceSynchronize();
}
        

cudaError_t cudaDeviceSetLimit(enum cudaLimit  limit, size_t  value)
{
	static cudaError_t (*lcudaDeviceSetLimit) (enum cudaLimit , size_t );
	if (!lcudaDeviceSetLimit) {
		lcudaDeviceSetLimit = (cudaError_t (*) (enum cudaLimit , size_t )) dlsym(RTLD_NEXT, "cudaDeviceSetLimit");
		tracer._kernel_map[(void *) lcudaDeviceSetLimit] = std::string("cudaDeviceSetLimit");
	}
	assert(lcudaDeviceSetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceSetLimit(limit, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceSetLimit);
	}
	return res;
}

cudaError_t cudaDeviceGetLimit(size_t * pValue, enum cudaLimit  limit)
{
	static cudaError_t (*lcudaDeviceGetLimit) (size_t *, enum cudaLimit );
	if (!lcudaDeviceGetLimit) {
		lcudaDeviceGetLimit = (cudaError_t (*) (size_t *, enum cudaLimit )) dlsym(RTLD_NEXT, "cudaDeviceGetLimit");
		tracer._kernel_map[(void *) lcudaDeviceGetLimit] = std::string("cudaDeviceGetLimit");
	}
	assert(lcudaDeviceGetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetLimit(pValue, limit);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetLimit);
	}
	return res;
}

cudaError_t cudaDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, const struct cudaChannelFormatDesc * fmtDesc, int  device)
{
	static cudaError_t (*lcudaDeviceGetTexture1DLinearMaxWidth) (size_t *, const struct cudaChannelFormatDesc *, int );
	if (!lcudaDeviceGetTexture1DLinearMaxWidth) {
		lcudaDeviceGetTexture1DLinearMaxWidth = (cudaError_t (*) (size_t *, const struct cudaChannelFormatDesc *, int )) dlsym(RTLD_NEXT, "cudaDeviceGetTexture1DLinearMaxWidth");
		tracer._kernel_map[(void *) lcudaDeviceGetTexture1DLinearMaxWidth] = std::string("cudaDeviceGetTexture1DLinearMaxWidth");
	}
	assert(lcudaDeviceGetTexture1DLinearMaxWidth);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetTexture1DLinearMaxWidth(maxWidthInElements, fmtDesc, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetTexture1DLinearMaxWidth);
	}
	return res;
}

cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache * pCacheConfig)
{
	static cudaError_t (*lcudaDeviceGetCacheConfig) (enum cudaFuncCache *);
	if (!lcudaDeviceGetCacheConfig) {
		lcudaDeviceGetCacheConfig = (cudaError_t (*) (enum cudaFuncCache *)) dlsym(RTLD_NEXT, "cudaDeviceGetCacheConfig");
		tracer._kernel_map[(void *) lcudaDeviceGetCacheConfig] = std::string("cudaDeviceGetCacheConfig");
	}
	assert(lcudaDeviceGetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetCacheConfig(pCacheConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetCacheConfig);
	}
	return res;
}

cudaError_t cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority)
{
	static cudaError_t (*lcudaDeviceGetStreamPriorityRange) (int *, int *);
	if (!lcudaDeviceGetStreamPriorityRange) {
		lcudaDeviceGetStreamPriorityRange = (cudaError_t (*) (int *, int *)) dlsym(RTLD_NEXT, "cudaDeviceGetStreamPriorityRange");
		tracer._kernel_map[(void *) lcudaDeviceGetStreamPriorityRange] = std::string("cudaDeviceGetStreamPriorityRange");
	}
	assert(lcudaDeviceGetStreamPriorityRange);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetStreamPriorityRange(leastPriority, greatestPriority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetStreamPriorityRange);
	}
	return res;
}

cudaError_t cudaDeviceSetCacheConfig(enum cudaFuncCache  cacheConfig)
{
	static cudaError_t (*lcudaDeviceSetCacheConfig) (enum cudaFuncCache );
	if (!lcudaDeviceSetCacheConfig) {
		lcudaDeviceSetCacheConfig = (cudaError_t (*) (enum cudaFuncCache )) dlsym(RTLD_NEXT, "cudaDeviceSetCacheConfig");
		tracer._kernel_map[(void *) lcudaDeviceSetCacheConfig] = std::string("cudaDeviceSetCacheConfig");
	}
	assert(lcudaDeviceSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceSetCacheConfig(cacheConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceSetCacheConfig);
	}
	return res;
}

cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig * pConfig)
{
	static cudaError_t (*lcudaDeviceGetSharedMemConfig) (enum cudaSharedMemConfig *);
	if (!lcudaDeviceGetSharedMemConfig) {
		lcudaDeviceGetSharedMemConfig = (cudaError_t (*) (enum cudaSharedMemConfig *)) dlsym(RTLD_NEXT, "cudaDeviceGetSharedMemConfig");
		tracer._kernel_map[(void *) lcudaDeviceGetSharedMemConfig] = std::string("cudaDeviceGetSharedMemConfig");
	}
	assert(lcudaDeviceGetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetSharedMemConfig(pConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetSharedMemConfig);
	}
	return res;
}

cudaError_t cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig  config)
{
	static cudaError_t (*lcudaDeviceSetSharedMemConfig) (enum cudaSharedMemConfig );
	if (!lcudaDeviceSetSharedMemConfig) {
		lcudaDeviceSetSharedMemConfig = (cudaError_t (*) (enum cudaSharedMemConfig )) dlsym(RTLD_NEXT, "cudaDeviceSetSharedMemConfig");
		tracer._kernel_map[(void *) lcudaDeviceSetSharedMemConfig] = std::string("cudaDeviceSetSharedMemConfig");
	}
	assert(lcudaDeviceSetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceSetSharedMemConfig(config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceSetSharedMemConfig);
	}
	return res;
}

cudaError_t cudaDeviceGetByPCIBusId(int * device, const char * pciBusId)
{
	static cudaError_t (*lcudaDeviceGetByPCIBusId) (int *, const char *);
	if (!lcudaDeviceGetByPCIBusId) {
		lcudaDeviceGetByPCIBusId = (cudaError_t (*) (int *, const char *)) dlsym(RTLD_NEXT, "cudaDeviceGetByPCIBusId");
		tracer._kernel_map[(void *) lcudaDeviceGetByPCIBusId] = std::string("cudaDeviceGetByPCIBusId");
	}
	assert(lcudaDeviceGetByPCIBusId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetByPCIBusId(device, pciBusId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetByPCIBusId);
	}
	return res;
}

cudaError_t cudaDeviceGetPCIBusId(char * pciBusId, int  len, int  device)
{
	static cudaError_t (*lcudaDeviceGetPCIBusId) (char *, int , int );
	if (!lcudaDeviceGetPCIBusId) {
		lcudaDeviceGetPCIBusId = (cudaError_t (*) (char *, int , int )) dlsym(RTLD_NEXT, "cudaDeviceGetPCIBusId");
		tracer._kernel_map[(void *) lcudaDeviceGetPCIBusId] = std::string("cudaDeviceGetPCIBusId");
	}
	assert(lcudaDeviceGetPCIBusId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetPCIBusId(pciBusId, len, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetPCIBusId);
	}
	return res;
}

cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t  event)
{
	static cudaError_t (*lcudaIpcGetEventHandle) (cudaIpcEventHandle_t *, cudaEvent_t );
	if (!lcudaIpcGetEventHandle) {
		lcudaIpcGetEventHandle = (cudaError_t (*) (cudaIpcEventHandle_t *, cudaEvent_t )) dlsym(RTLD_NEXT, "cudaIpcGetEventHandle");
		tracer._kernel_map[(void *) lcudaIpcGetEventHandle] = std::string("cudaIpcGetEventHandle");
	}
	assert(lcudaIpcGetEventHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaIpcGetEventHandle(handle, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaIpcGetEventHandle);
	}
	return res;
}

cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t  handle)
{
	static cudaError_t (*lcudaIpcOpenEventHandle) (cudaEvent_t *, cudaIpcEventHandle_t );
	if (!lcudaIpcOpenEventHandle) {
		lcudaIpcOpenEventHandle = (cudaError_t (*) (cudaEvent_t *, cudaIpcEventHandle_t )) dlsym(RTLD_NEXT, "cudaIpcOpenEventHandle");
		tracer._kernel_map[(void *) lcudaIpcOpenEventHandle] = std::string("cudaIpcOpenEventHandle");
	}
	assert(lcudaIpcOpenEventHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaIpcOpenEventHandle(event, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaIpcOpenEventHandle);
	}
	return res;
}

cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr)
{
	static cudaError_t (*lcudaIpcGetMemHandle) (cudaIpcMemHandle_t *, void *);
	if (!lcudaIpcGetMemHandle) {
		lcudaIpcGetMemHandle = (cudaError_t (*) (cudaIpcMemHandle_t *, void *)) dlsym(RTLD_NEXT, "cudaIpcGetMemHandle");
		tracer._kernel_map[(void *) lcudaIpcGetMemHandle] = std::string("cudaIpcGetMemHandle");
	}
	assert(lcudaIpcGetMemHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaIpcGetMemHandle(handle, devPtr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaIpcGetMemHandle);
	}
	return res;
}

cudaError_t cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t  handle, unsigned int  flags)
{
	static cudaError_t (*lcudaIpcOpenMemHandle) (void **, cudaIpcMemHandle_t , unsigned int );
	if (!lcudaIpcOpenMemHandle) {
		lcudaIpcOpenMemHandle = (cudaError_t (*) (void **, cudaIpcMemHandle_t , unsigned int )) dlsym(RTLD_NEXT, "cudaIpcOpenMemHandle");
		tracer._kernel_map[(void *) lcudaIpcOpenMemHandle] = std::string("cudaIpcOpenMemHandle");
	}
	assert(lcudaIpcOpenMemHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaIpcOpenMemHandle(devPtr, handle, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaIpcOpenMemHandle);
	}
	return res;
}

cudaError_t cudaIpcCloseMemHandle(void * devPtr)
{
	static cudaError_t (*lcudaIpcCloseMemHandle) (void *);
	if (!lcudaIpcCloseMemHandle) {
		lcudaIpcCloseMemHandle = (cudaError_t (*) (void *)) dlsym(RTLD_NEXT, "cudaIpcCloseMemHandle");
		tracer._kernel_map[(void *) lcudaIpcCloseMemHandle] = std::string("cudaIpcCloseMemHandle");
	}
	assert(lcudaIpcCloseMemHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaIpcCloseMemHandle(devPtr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaIpcCloseMemHandle);
	}
	return res;
}

cudaError_t cudaDeviceFlushGPUDirectRDMAWrites(enum cudaFlushGPUDirectRDMAWritesTarget  target, enum cudaFlushGPUDirectRDMAWritesScope  scope)
{
	static cudaError_t (*lcudaDeviceFlushGPUDirectRDMAWrites) (enum cudaFlushGPUDirectRDMAWritesTarget , enum cudaFlushGPUDirectRDMAWritesScope );
	if (!lcudaDeviceFlushGPUDirectRDMAWrites) {
		lcudaDeviceFlushGPUDirectRDMAWrites = (cudaError_t (*) (enum cudaFlushGPUDirectRDMAWritesTarget , enum cudaFlushGPUDirectRDMAWritesScope )) dlsym(RTLD_NEXT, "cudaDeviceFlushGPUDirectRDMAWrites");
		tracer._kernel_map[(void *) lcudaDeviceFlushGPUDirectRDMAWrites] = std::string("cudaDeviceFlushGPUDirectRDMAWrites");
	}
	assert(lcudaDeviceFlushGPUDirectRDMAWrites);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceFlushGPUDirectRDMAWrites(target, scope);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceFlushGPUDirectRDMAWrites);
	}
	return res;
}

cudaError_t cudaThreadExit()
{
	static cudaError_t (*lcudaThreadExit) ();
	if (!lcudaThreadExit) {
		lcudaThreadExit = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaThreadExit");
		tracer._kernel_map[(void *) lcudaThreadExit] = std::string("cudaThreadExit");
	}
	assert(lcudaThreadExit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadExit();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadExit);
	}
	return res;
}

cudaError_t cudaThreadSynchronize()
{
	static cudaError_t (*lcudaThreadSynchronize) ();
	if (!lcudaThreadSynchronize) {
		lcudaThreadSynchronize = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaThreadSynchronize");
		tracer._kernel_map[(void *) lcudaThreadSynchronize] = std::string("cudaThreadSynchronize");
	}
	assert(lcudaThreadSynchronize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadSynchronize();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadSynchronize);
	}
	return res;
}

cudaError_t cudaThreadSetLimit(enum cudaLimit  limit, size_t  value)
{
	static cudaError_t (*lcudaThreadSetLimit) (enum cudaLimit , size_t );
	if (!lcudaThreadSetLimit) {
		lcudaThreadSetLimit = (cudaError_t (*) (enum cudaLimit , size_t )) dlsym(RTLD_NEXT, "cudaThreadSetLimit");
		tracer._kernel_map[(void *) lcudaThreadSetLimit] = std::string("cudaThreadSetLimit");
	}
	assert(lcudaThreadSetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadSetLimit(limit, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadSetLimit);
	}
	return res;
}

cudaError_t cudaThreadGetLimit(size_t * pValue, enum cudaLimit  limit)
{
	static cudaError_t (*lcudaThreadGetLimit) (size_t *, enum cudaLimit );
	if (!lcudaThreadGetLimit) {
		lcudaThreadGetLimit = (cudaError_t (*) (size_t *, enum cudaLimit )) dlsym(RTLD_NEXT, "cudaThreadGetLimit");
		tracer._kernel_map[(void *) lcudaThreadGetLimit] = std::string("cudaThreadGetLimit");
	}
	assert(lcudaThreadGetLimit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadGetLimit(pValue, limit);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadGetLimit);
	}
	return res;
}

cudaError_t cudaThreadGetCacheConfig(enum cudaFuncCache * pCacheConfig)
{
	static cudaError_t (*lcudaThreadGetCacheConfig) (enum cudaFuncCache *);
	if (!lcudaThreadGetCacheConfig) {
		lcudaThreadGetCacheConfig = (cudaError_t (*) (enum cudaFuncCache *)) dlsym(RTLD_NEXT, "cudaThreadGetCacheConfig");
		tracer._kernel_map[(void *) lcudaThreadGetCacheConfig] = std::string("cudaThreadGetCacheConfig");
	}
	assert(lcudaThreadGetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadGetCacheConfig(pCacheConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadGetCacheConfig);
	}
	return res;
}

cudaError_t cudaThreadSetCacheConfig(enum cudaFuncCache  cacheConfig)
{
	static cudaError_t (*lcudaThreadSetCacheConfig) (enum cudaFuncCache );
	if (!lcudaThreadSetCacheConfig) {
		lcudaThreadSetCacheConfig = (cudaError_t (*) (enum cudaFuncCache )) dlsym(RTLD_NEXT, "cudaThreadSetCacheConfig");
		tracer._kernel_map[(void *) lcudaThreadSetCacheConfig] = std::string("cudaThreadSetCacheConfig");
	}
	assert(lcudaThreadSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadSetCacheConfig(cacheConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadSetCacheConfig);
	}
	return res;
}

cudaError_t cudaGetLastError()
{
	static cudaError_t (*lcudaGetLastError) ();
	if (!lcudaGetLastError) {
		lcudaGetLastError = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaGetLastError");
		tracer._kernel_map[(void *) lcudaGetLastError] = std::string("cudaGetLastError");
	}
	assert(lcudaGetLastError);
	cudaError_t res = 
		lcudaGetLastError();
	return res;
}

cudaError_t cudaPeekAtLastError()
{
	static cudaError_t (*lcudaPeekAtLastError) ();
	if (!lcudaPeekAtLastError) {
		lcudaPeekAtLastError = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaPeekAtLastError");
		tracer._kernel_map[(void *) lcudaPeekAtLastError] = std::string("cudaPeekAtLastError");
	}
	assert(lcudaPeekAtLastError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaPeekAtLastError();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaPeekAtLastError);
	}
	return res;
}

const char* cudaGetErrorName(cudaError_t  error)
{
	static const char* (*lcudaGetErrorName) (cudaError_t );
	if (!lcudaGetErrorName) {
		lcudaGetErrorName = (const char* (*) (cudaError_t )) dlsym(RTLD_NEXT, "cudaGetErrorName");
		tracer._kernel_map[(void *) lcudaGetErrorName] = std::string("cudaGetErrorName");
	}
	assert(lcudaGetErrorName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcudaGetErrorName(error);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetErrorName);
	}
	return res;
}

const char* cudaGetErrorString(cudaError_t  error)
{
	static const char* (*lcudaGetErrorString) (cudaError_t );
	if (!lcudaGetErrorString) {
		lcudaGetErrorString = (const char* (*) (cudaError_t )) dlsym(RTLD_NEXT, "cudaGetErrorString");
		tracer._kernel_map[(void *) lcudaGetErrorString] = std::string("cudaGetErrorString");
	}
	assert(lcudaGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcudaGetErrorString(error);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetErrorString);
	}
	return res;
}

cudaError_t cudaGetDeviceCount(int * count)
{
	static cudaError_t (*lcudaGetDeviceCount) (int *);
	if (!lcudaGetDeviceCount) {
		lcudaGetDeviceCount = (cudaError_t (*) (int *)) dlsym(RTLD_NEXT, "cudaGetDeviceCount");
		tracer._kernel_map[(void *) lcudaGetDeviceCount] = std::string("cudaGetDeviceCount");
	}
	assert(lcudaGetDeviceCount);
	cudaError_t res = 
		lcudaGetDeviceCount(count);
	return res;
}

cudaError_t cudaGetDeviceProperties_v2(struct cudaDeviceProp * prop, int  device)
{
	static cudaError_t (*lcudaGetDeviceProperties_v2) (struct cudaDeviceProp *, int );
	if (!lcudaGetDeviceProperties_v2) {
		lcudaGetDeviceProperties_v2 = (cudaError_t (*) (struct cudaDeviceProp *, int )) dlsym(RTLD_NEXT, "cudaGetDeviceProperties_v2");
		tracer._kernel_map[(void *) lcudaGetDeviceProperties_v2] = std::string("cudaGetDeviceProperties_v2");
	}
	assert(lcudaGetDeviceProperties_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetDeviceProperties_v2(prop, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetDeviceProperties_v2);
	}
	return res;
}

cudaError_t cudaDeviceGetAttribute(int * value, enum cudaDeviceAttr  attr, int  device)
{
	static cudaError_t (*lcudaDeviceGetAttribute) (int *, enum cudaDeviceAttr , int );
	if (!lcudaDeviceGetAttribute) {
		lcudaDeviceGetAttribute = (cudaError_t (*) (int *, enum cudaDeviceAttr , int )) dlsym(RTLD_NEXT, "cudaDeviceGetAttribute");
		tracer._kernel_map[(void *) lcudaDeviceGetAttribute] = std::string("cudaDeviceGetAttribute");
	}
	assert(lcudaDeviceGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetAttribute(value, attr, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetAttribute);
	}
	return res;
}

cudaError_t cudaDeviceGetDefaultMemPool(cudaMemPool_t * memPool, int  device)
{
	static cudaError_t (*lcudaDeviceGetDefaultMemPool) (cudaMemPool_t *, int );
	if (!lcudaDeviceGetDefaultMemPool) {
		lcudaDeviceGetDefaultMemPool = (cudaError_t (*) (cudaMemPool_t *, int )) dlsym(RTLD_NEXT, "cudaDeviceGetDefaultMemPool");
		tracer._kernel_map[(void *) lcudaDeviceGetDefaultMemPool] = std::string("cudaDeviceGetDefaultMemPool");
	}
	assert(lcudaDeviceGetDefaultMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetDefaultMemPool(memPool, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetDefaultMemPool);
	}
	return res;
}

cudaError_t cudaDeviceSetMemPool(int  device, cudaMemPool_t  memPool)
{
	static cudaError_t (*lcudaDeviceSetMemPool) (int , cudaMemPool_t );
	if (!lcudaDeviceSetMemPool) {
		lcudaDeviceSetMemPool = (cudaError_t (*) (int , cudaMemPool_t )) dlsym(RTLD_NEXT, "cudaDeviceSetMemPool");
		tracer._kernel_map[(void *) lcudaDeviceSetMemPool] = std::string("cudaDeviceSetMemPool");
	}
	assert(lcudaDeviceSetMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceSetMemPool(device, memPool);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceSetMemPool);
	}
	return res;
}

cudaError_t cudaDeviceGetMemPool(cudaMemPool_t * memPool, int  device)
{
	static cudaError_t (*lcudaDeviceGetMemPool) (cudaMemPool_t *, int );
	if (!lcudaDeviceGetMemPool) {
		lcudaDeviceGetMemPool = (cudaError_t (*) (cudaMemPool_t *, int )) dlsym(RTLD_NEXT, "cudaDeviceGetMemPool");
		tracer._kernel_map[(void *) lcudaDeviceGetMemPool] = std::string("cudaDeviceGetMemPool");
	}
	assert(lcudaDeviceGetMemPool);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetMemPool(memPool, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetMemPool);
	}
	return res;
}

cudaError_t cudaDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, int  device, int  flags)
{
	static cudaError_t (*lcudaDeviceGetNvSciSyncAttributes) (void *, int , int );
	if (!lcudaDeviceGetNvSciSyncAttributes) {
		lcudaDeviceGetNvSciSyncAttributes = (cudaError_t (*) (void *, int , int )) dlsym(RTLD_NEXT, "cudaDeviceGetNvSciSyncAttributes");
		tracer._kernel_map[(void *) lcudaDeviceGetNvSciSyncAttributes] = std::string("cudaDeviceGetNvSciSyncAttributes");
	}
	assert(lcudaDeviceGetNvSciSyncAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, device, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetNvSciSyncAttributes);
	}
	return res;
}

cudaError_t cudaDeviceGetP2PAttribute(int * value, enum cudaDeviceP2PAttr  attr, int  srcDevice, int  dstDevice)
{
	static cudaError_t (*lcudaDeviceGetP2PAttribute) (int *, enum cudaDeviceP2PAttr , int , int );
	if (!lcudaDeviceGetP2PAttribute) {
		lcudaDeviceGetP2PAttribute = (cudaError_t (*) (int *, enum cudaDeviceP2PAttr , int , int )) dlsym(RTLD_NEXT, "cudaDeviceGetP2PAttribute");
		tracer._kernel_map[(void *) lcudaDeviceGetP2PAttribute] = std::string("cudaDeviceGetP2PAttribute");
	}
	assert(lcudaDeviceGetP2PAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetP2PAttribute(value, attr, srcDevice, dstDevice);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetP2PAttribute);
	}
	return res;
}

cudaError_t cudaChooseDevice(int * device, const struct cudaDeviceProp * prop)
{
	static cudaError_t (*lcudaChooseDevice) (int *, const struct cudaDeviceProp *);
	if (!lcudaChooseDevice) {
		lcudaChooseDevice = (cudaError_t (*) (int *, const struct cudaDeviceProp *)) dlsym(RTLD_NEXT, "cudaChooseDevice");
		tracer._kernel_map[(void *) lcudaChooseDevice] = std::string("cudaChooseDevice");
	}
	assert(lcudaChooseDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaChooseDevice(device, prop);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaChooseDevice);
	}
	return res;
}

cudaError_t cudaInitDevice(int  device, unsigned int  deviceFlags, unsigned int  flags)
{
	static cudaError_t (*lcudaInitDevice) (int , unsigned int , unsigned int );
	if (!lcudaInitDevice) {
		lcudaInitDevice = (cudaError_t (*) (int , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaInitDevice");
		tracer._kernel_map[(void *) lcudaInitDevice] = std::string("cudaInitDevice");
	}
	assert(lcudaInitDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaInitDevice(device, deviceFlags, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaInitDevice);
	}
	return res;
}

cudaError_t cudaSetDevice(int  device)
{
	static cudaError_t (*lcudaSetDevice) (int );
	if (!lcudaSetDevice) {
		lcudaSetDevice = (cudaError_t (*) (int )) dlsym(RTLD_NEXT, "cudaSetDevice");
		tracer._kernel_map[(void *) lcudaSetDevice] = std::string("cudaSetDevice");
	}
	assert(lcudaSetDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSetDevice(device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSetDevice);
	}
	return res;
}

cudaError_t cudaGetDevice(int * device)
{
	static cudaError_t (*lcudaGetDevice) (int *);
	if (!lcudaGetDevice) {
		lcudaGetDevice = (cudaError_t (*) (int *)) dlsym(RTLD_NEXT, "cudaGetDevice");
		tracer._kernel_map[(void *) lcudaGetDevice] = std::string("cudaGetDevice");
	}
	assert(lcudaGetDevice);
	cudaError_t res = 
		lcudaGetDevice(device);
	return res;
}

cudaError_t cudaSetValidDevices(int * device_arr, int  len)
{
	static cudaError_t (*lcudaSetValidDevices) (int *, int );
	if (!lcudaSetValidDevices) {
		lcudaSetValidDevices = (cudaError_t (*) (int *, int )) dlsym(RTLD_NEXT, "cudaSetValidDevices");
		tracer._kernel_map[(void *) lcudaSetValidDevices] = std::string("cudaSetValidDevices");
	}
	assert(lcudaSetValidDevices);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSetValidDevices(device_arr, len);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSetValidDevices);
	}
	return res;
}

cudaError_t cudaSetDeviceFlags(unsigned int  flags)
{
	static cudaError_t (*lcudaSetDeviceFlags) (unsigned int );
	if (!lcudaSetDeviceFlags) {
		lcudaSetDeviceFlags = (cudaError_t (*) (unsigned int )) dlsym(RTLD_NEXT, "cudaSetDeviceFlags");
		tracer._kernel_map[(void *) lcudaSetDeviceFlags] = std::string("cudaSetDeviceFlags");
	}
	assert(lcudaSetDeviceFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSetDeviceFlags(flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSetDeviceFlags);
	}
	return res;
}

cudaError_t cudaGetDeviceFlags(unsigned int * flags)
{
	static cudaError_t (*lcudaGetDeviceFlags) (unsigned int *);
	if (!lcudaGetDeviceFlags) {
		lcudaGetDeviceFlags = (cudaError_t (*) (unsigned int *)) dlsym(RTLD_NEXT, "cudaGetDeviceFlags");
		tracer._kernel_map[(void *) lcudaGetDeviceFlags] = std::string("cudaGetDeviceFlags");
	}
	assert(lcudaGetDeviceFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetDeviceFlags(flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetDeviceFlags);
	}
	return res;
}

cudaError_t cudaStreamCreate(cudaStream_t * pStream)
{
	static cudaError_t (*lcudaStreamCreate) (cudaStream_t *);
	if (!lcudaStreamCreate) {
		lcudaStreamCreate = (cudaError_t (*) (cudaStream_t *)) dlsym(RTLD_NEXT, "cudaStreamCreate");
		tracer._kernel_map[(void *) lcudaStreamCreate] = std::string("cudaStreamCreate");
	}
	assert(lcudaStreamCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamCreate(pStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamCreate);
	}
	return res;
}

cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned int  flags)
{
	static cudaError_t (*lcudaStreamCreateWithFlags) (cudaStream_t *, unsigned int );
	if (!lcudaStreamCreateWithFlags) {
		lcudaStreamCreateWithFlags = (cudaError_t (*) (cudaStream_t *, unsigned int )) dlsym(RTLD_NEXT, "cudaStreamCreateWithFlags");
		tracer._kernel_map[(void *) lcudaStreamCreateWithFlags] = std::string("cudaStreamCreateWithFlags");
	}
	assert(lcudaStreamCreateWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamCreateWithFlags(pStream, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamCreateWithFlags);
	}
	return res;
}

cudaError_t cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned int  flags, int  priority)
{
	static cudaError_t (*lcudaStreamCreateWithPriority) (cudaStream_t *, unsigned int , int );
	if (!lcudaStreamCreateWithPriority) {
		lcudaStreamCreateWithPriority = (cudaError_t (*) (cudaStream_t *, unsigned int , int )) dlsym(RTLD_NEXT, "cudaStreamCreateWithPriority");
		tracer._kernel_map[(void *) lcudaStreamCreateWithPriority] = std::string("cudaStreamCreateWithPriority");
	}
	assert(lcudaStreamCreateWithPriority);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamCreateWithPriority(pStream, flags, priority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamCreateWithPriority);
	}
	return res;
}

cudaError_t cudaStreamGetPriority(cudaStream_t  hStream, int * priority)
{
	static cudaError_t (*lcudaStreamGetPriority) (cudaStream_t , int *);
	if (!lcudaStreamGetPriority) {
		lcudaStreamGetPriority = (cudaError_t (*) (cudaStream_t , int *)) dlsym(RTLD_NEXT, "cudaStreamGetPriority");
		tracer._kernel_map[(void *) lcudaStreamGetPriority] = std::string("cudaStreamGetPriority");
	}
	assert(lcudaStreamGetPriority);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamGetPriority(hStream, priority);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamGetPriority);
	}
	return res;
}

cudaError_t cudaStreamGetFlags(cudaStream_t  hStream, unsigned int * flags)
{
	static cudaError_t (*lcudaStreamGetFlags) (cudaStream_t , unsigned int *);
	if (!lcudaStreamGetFlags) {
		lcudaStreamGetFlags = (cudaError_t (*) (cudaStream_t , unsigned int *)) dlsym(RTLD_NEXT, "cudaStreamGetFlags");
		tracer._kernel_map[(void *) lcudaStreamGetFlags] = std::string("cudaStreamGetFlags");
	}
	assert(lcudaStreamGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamGetFlags(hStream, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamGetFlags);
	}
	return res;
}

cudaError_t cudaStreamGetId(cudaStream_t  hStream, unsigned long long * streamId)
{
	static cudaError_t (*lcudaStreamGetId) (cudaStream_t , unsigned long long *);
	if (!lcudaStreamGetId) {
		lcudaStreamGetId = (cudaError_t (*) (cudaStream_t , unsigned long long *)) dlsym(RTLD_NEXT, "cudaStreamGetId");
		tracer._kernel_map[(void *) lcudaStreamGetId] = std::string("cudaStreamGetId");
	}
	assert(lcudaStreamGetId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamGetId(hStream, streamId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamGetId);
	}
	return res;
}

cudaError_t cudaCtxResetPersistingL2Cache()
{
	static cudaError_t (*lcudaCtxResetPersistingL2Cache) ();
	if (!lcudaCtxResetPersistingL2Cache) {
		lcudaCtxResetPersistingL2Cache = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaCtxResetPersistingL2Cache");
		tracer._kernel_map[(void *) lcudaCtxResetPersistingL2Cache] = std::string("cudaCtxResetPersistingL2Cache");
	}
	assert(lcudaCtxResetPersistingL2Cache);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaCtxResetPersistingL2Cache();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaCtxResetPersistingL2Cache);
	}
	return res;
}

cudaError_t cudaStreamCopyAttributes(cudaStream_t  dst, cudaStream_t  src)
{
	static cudaError_t (*lcudaStreamCopyAttributes) (cudaStream_t , cudaStream_t );
	if (!lcudaStreamCopyAttributes) {
		lcudaStreamCopyAttributes = (cudaError_t (*) (cudaStream_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaStreamCopyAttributes");
		tracer._kernel_map[(void *) lcudaStreamCopyAttributes] = std::string("cudaStreamCopyAttributes");
	}
	assert(lcudaStreamCopyAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamCopyAttributes(dst, src);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamCopyAttributes);
	}
	return res;
}

cudaError_t cudaStreamGetAttribute(cudaStream_t  hStream, cudaLaunchAttributeID  attr, cudaLaunchAttributeValue * value_out)
{
	static cudaError_t (*lcudaStreamGetAttribute) (cudaStream_t , cudaLaunchAttributeID , cudaLaunchAttributeValue *);
	if (!lcudaStreamGetAttribute) {
		lcudaStreamGetAttribute = (cudaError_t (*) (cudaStream_t , cudaLaunchAttributeID , cudaLaunchAttributeValue *)) dlsym(RTLD_NEXT, "cudaStreamGetAttribute");
		tracer._kernel_map[(void *) lcudaStreamGetAttribute] = std::string("cudaStreamGetAttribute");
	}
	assert(lcudaStreamGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamGetAttribute(hStream, attr, value_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamGetAttribute);
	}
	return res;
}

cudaError_t cudaStreamSetAttribute(cudaStream_t  hStream, cudaLaunchAttributeID  attr, const cudaLaunchAttributeValue * value)
{
	static cudaError_t (*lcudaStreamSetAttribute) (cudaStream_t , cudaLaunchAttributeID , const cudaLaunchAttributeValue *);
	if (!lcudaStreamSetAttribute) {
		lcudaStreamSetAttribute = (cudaError_t (*) (cudaStream_t , cudaLaunchAttributeID , const cudaLaunchAttributeValue *)) dlsym(RTLD_NEXT, "cudaStreamSetAttribute");
		tracer._kernel_map[(void *) lcudaStreamSetAttribute] = std::string("cudaStreamSetAttribute");
	}
	assert(lcudaStreamSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamSetAttribute(hStream, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamSetAttribute);
	}
	return res;
}

cudaError_t cudaStreamDestroy(cudaStream_t  stream)
{
	static cudaError_t (*lcudaStreamDestroy) (cudaStream_t );
	if (!lcudaStreamDestroy) {
		lcudaStreamDestroy = (cudaError_t (*) (cudaStream_t )) dlsym(RTLD_NEXT, "cudaStreamDestroy");
		tracer._kernel_map[(void *) lcudaStreamDestroy] = std::string("cudaStreamDestroy");
	}
	assert(lcudaStreamDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamDestroy(stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamDestroy);
	}
	return res;
}

cudaError_t cudaStreamWaitEvent(cudaStream_t  stream, cudaEvent_t  event, unsigned int  flags)
{
	static cudaError_t (*lcudaStreamWaitEvent) (cudaStream_t , cudaEvent_t , unsigned int );
	if (!lcudaStreamWaitEvent) {
		lcudaStreamWaitEvent = (cudaError_t (*) (cudaStream_t , cudaEvent_t , unsigned int )) dlsym(RTLD_NEXT, "cudaStreamWaitEvent");
		tracer._kernel_map[(void *) lcudaStreamWaitEvent] = std::string("cudaStreamWaitEvent");
	}
	assert(lcudaStreamWaitEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamWaitEvent(stream, event, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamWaitEvent);
	}
	return res;
}

cudaError_t cudaStreamAddCallback(cudaStream_t  stream, cudaStreamCallback_t  callback, void * userData, unsigned int  flags)
{
	static cudaError_t (*lcudaStreamAddCallback) (cudaStream_t , cudaStreamCallback_t , void *, unsigned int );
	if (!lcudaStreamAddCallback) {
		lcudaStreamAddCallback = (cudaError_t (*) (cudaStream_t , cudaStreamCallback_t , void *, unsigned int )) dlsym(RTLD_NEXT, "cudaStreamAddCallback");
		tracer._kernel_map[(void *) lcudaStreamAddCallback] = std::string("cudaStreamAddCallback");
	}
	assert(lcudaStreamAddCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamAddCallback(stream, callback, userData, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamAddCallback);
	}
	return res;
}


cudaError_t cudaStreamSynchronize(cudaStream_t  stream)
{
	static cudaError_t (*lcudaStreamSynchronize) (cudaStream_t );
	if (!lcudaStreamSynchronize) {
		lcudaStreamSynchronize = (cudaError_t (*) (cudaStream_t )) dlsym(RTLD_NEXT, "cudaStreamSynchronize");
		tracer._kernel_map[(void *) lcudaStreamSynchronize] = std::string("cudaStreamSynchronize");
	}
	assert(lcudaStreamSynchronize);

    // Only matters when collecting CPU trace
    
	cudaError_t res = lcudaStreamSynchronize(stream);
    

    

	return res;
}


cudaError_t cudaStreamQuery(cudaStream_t  stream)
{
	static cudaError_t (*lcudaStreamQuery) (cudaStream_t );
	if (!lcudaStreamQuery) {
		lcudaStreamQuery = (cudaError_t (*) (cudaStream_t )) dlsym(RTLD_NEXT, "cudaStreamQuery");
		tracer._kernel_map[(void *) lcudaStreamQuery] = std::string("cudaStreamQuery");
	}
	assert(lcudaStreamQuery);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamQuery(stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamQuery);
	}
	return res;
}

cudaError_t cudaStreamAttachMemAsync(cudaStream_t  stream, void * devPtr, size_t  length, unsigned int  flags)
{
	static cudaError_t (*lcudaStreamAttachMemAsync) (cudaStream_t , void *, size_t , unsigned int );
	if (!lcudaStreamAttachMemAsync) {
		lcudaStreamAttachMemAsync = (cudaError_t (*) (cudaStream_t , void *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaStreamAttachMemAsync");
		tracer._kernel_map[(void *) lcudaStreamAttachMemAsync] = std::string("cudaStreamAttachMemAsync");
	}
	assert(lcudaStreamAttachMemAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamAttachMemAsync(stream, devPtr, length, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamAttachMemAsync);
	}
	return res;
}

cudaError_t cudaStreamBeginCapture(cudaStream_t  stream, enum cudaStreamCaptureMode  mode)
{
	static cudaError_t (*lcudaStreamBeginCapture) (cudaStream_t , enum cudaStreamCaptureMode );
	if (!lcudaStreamBeginCapture) {
		lcudaStreamBeginCapture = (cudaError_t (*) (cudaStream_t , enum cudaStreamCaptureMode )) dlsym(RTLD_NEXT, "cudaStreamBeginCapture");
		tracer._kernel_map[(void *) lcudaStreamBeginCapture] = std::string("cudaStreamBeginCapture");
	}
	assert(lcudaStreamBeginCapture);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamBeginCapture(stream, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamBeginCapture);
	}
	return res;
}

cudaError_t cudaThreadExchangeStreamCaptureMode(enum cudaStreamCaptureMode * mode)
{
	static cudaError_t (*lcudaThreadExchangeStreamCaptureMode) (enum cudaStreamCaptureMode *);
	if (!lcudaThreadExchangeStreamCaptureMode) {
		lcudaThreadExchangeStreamCaptureMode = (cudaError_t (*) (enum cudaStreamCaptureMode *)) dlsym(RTLD_NEXT, "cudaThreadExchangeStreamCaptureMode");
		tracer._kernel_map[(void *) lcudaThreadExchangeStreamCaptureMode] = std::string("cudaThreadExchangeStreamCaptureMode");
	}
	assert(lcudaThreadExchangeStreamCaptureMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaThreadExchangeStreamCaptureMode(mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaThreadExchangeStreamCaptureMode);
	}
	return res;
}

cudaError_t cudaStreamEndCapture(cudaStream_t  stream, cudaGraph_t * pGraph)
{
	static cudaError_t (*lcudaStreamEndCapture) (cudaStream_t , cudaGraph_t *);
	if (!lcudaStreamEndCapture) {
		lcudaStreamEndCapture = (cudaError_t (*) (cudaStream_t , cudaGraph_t *)) dlsym(RTLD_NEXT, "cudaStreamEndCapture");
		tracer._kernel_map[(void *) lcudaStreamEndCapture] = std::string("cudaStreamEndCapture");
	}
	assert(lcudaStreamEndCapture);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamEndCapture(stream, pGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamEndCapture);
	}
	return res;
}

cudaError_t cudaStreamIsCapturing(cudaStream_t  stream, enum cudaStreamCaptureStatus * pCaptureStatus)
{
	static cudaError_t (*lcudaStreamIsCapturing) (cudaStream_t , enum cudaStreamCaptureStatus *);
	if (!lcudaStreamIsCapturing) {
		lcudaStreamIsCapturing = (cudaError_t (*) (cudaStream_t , enum cudaStreamCaptureStatus *)) dlsym(RTLD_NEXT, "cudaStreamIsCapturing");
		tracer._kernel_map[(void *) lcudaStreamIsCapturing] = std::string("cudaStreamIsCapturing");
	}
	assert(lcudaStreamIsCapturing);
	cudaError_t res = 
		lcudaStreamIsCapturing(stream, pCaptureStatus);
	return res;
}

cudaError_t cudaStreamGetCaptureInfo_v2(cudaStream_t  stream, enum cudaStreamCaptureStatus * captureStatus_out, unsigned long long * id_out, cudaGraph_t * graph_out, const cudaGraphNode_t ** dependencies_out, size_t * numDependencies_out)
{
	static cudaError_t (*lcudaStreamGetCaptureInfo_v2) (cudaStream_t , enum cudaStreamCaptureStatus *, unsigned long long *, cudaGraph_t *, const cudaGraphNode_t **, size_t *);
	if (!lcudaStreamGetCaptureInfo_v2) {
		lcudaStreamGetCaptureInfo_v2 = (cudaError_t (*) (cudaStream_t , enum cudaStreamCaptureStatus *, unsigned long long *, cudaGraph_t *, const cudaGraphNode_t **, size_t *)) dlsym(RTLD_NEXT, "cudaStreamGetCaptureInfo_v2");
		tracer._kernel_map[(void *) lcudaStreamGetCaptureInfo_v2] = std::string("cudaStreamGetCaptureInfo_v2");
	}
	assert(lcudaStreamGetCaptureInfo_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamGetCaptureInfo_v2(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamGetCaptureInfo_v2);
	}
	return res;
}

cudaError_t cudaStreamUpdateCaptureDependencies(cudaStream_t  stream, cudaGraphNode_t * dependencies, size_t  numDependencies, unsigned int  flags)
{
	static cudaError_t (*lcudaStreamUpdateCaptureDependencies) (cudaStream_t , cudaGraphNode_t *, size_t , unsigned int );
	if (!lcudaStreamUpdateCaptureDependencies) {
		lcudaStreamUpdateCaptureDependencies = (cudaError_t (*) (cudaStream_t , cudaGraphNode_t *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaStreamUpdateCaptureDependencies");
		tracer._kernel_map[(void *) lcudaStreamUpdateCaptureDependencies] = std::string("cudaStreamUpdateCaptureDependencies");
	}
	assert(lcudaStreamUpdateCaptureDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaStreamUpdateCaptureDependencies(stream, dependencies, numDependencies, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaStreamUpdateCaptureDependencies);
	}
	return res;
}

cudaError_t cudaEventCreate(cudaEvent_t * event)
{
	static cudaError_t (*lcudaEventCreate) (cudaEvent_t *);
	if (!lcudaEventCreate) {
		lcudaEventCreate = (cudaError_t (*) (cudaEvent_t *)) dlsym(RTLD_NEXT, "cudaEventCreate");
		tracer._kernel_map[(void *) lcudaEventCreate] = std::string("cudaEventCreate");
	}
	assert(lcudaEventCreate);
	cudaError_t res = 
		lcudaEventCreate(event);
	return res;
}

cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned int  flags)
{
	static cudaError_t (*lcudaEventCreateWithFlags) (cudaEvent_t *, unsigned int );
	if (!lcudaEventCreateWithFlags) {
		lcudaEventCreateWithFlags = (cudaError_t (*) (cudaEvent_t *, unsigned int )) dlsym(RTLD_NEXT, "cudaEventCreateWithFlags");
		tracer._kernel_map[(void *) lcudaEventCreateWithFlags] = std::string("cudaEventCreateWithFlags");
	}
	assert(lcudaEventCreateWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaEventCreateWithFlags(event, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaEventCreateWithFlags);
	}
	return res;
}

cudaError_t cudaEventRecord(cudaEvent_t  event, cudaStream_t  stream)
{
	static cudaError_t (*lcudaEventRecord) (cudaEvent_t , cudaStream_t );
	if (!lcudaEventRecord) {
		lcudaEventRecord = (cudaError_t (*) (cudaEvent_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaEventRecord");
		tracer._kernel_map[(void *) lcudaEventRecord] = std::string("cudaEventRecord");
	}
	assert(lcudaEventRecord);
	cudaError_t res = 
		lcudaEventRecord(event, stream);
	return res;
}

cudaError_t cudaEventRecordWithFlags(cudaEvent_t  event, cudaStream_t  stream, unsigned int  flags)
{
	static cudaError_t (*lcudaEventRecordWithFlags) (cudaEvent_t , cudaStream_t , unsigned int );
	if (!lcudaEventRecordWithFlags) {
		lcudaEventRecordWithFlags = (cudaError_t (*) (cudaEvent_t , cudaStream_t , unsigned int )) dlsym(RTLD_NEXT, "cudaEventRecordWithFlags");
		tracer._kernel_map[(void *) lcudaEventRecordWithFlags] = std::string("cudaEventRecordWithFlags");
	}
	assert(lcudaEventRecordWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaEventRecordWithFlags(event, stream, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaEventRecordWithFlags);
	}
	return res;
}

cudaError_t cudaEventQuery(cudaEvent_t  event)
{
	static cudaError_t (*lcudaEventQuery) (cudaEvent_t );
	if (!lcudaEventQuery) {
		lcudaEventQuery = (cudaError_t (*) (cudaEvent_t )) dlsym(RTLD_NEXT, "cudaEventQuery");
		tracer._kernel_map[(void *) lcudaEventQuery] = std::string("cudaEventQuery");
	}
	assert(lcudaEventQuery);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaEventQuery(event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaEventQuery);
	}
	return res;
}

cudaError_t cudaEventSynchronize(cudaEvent_t  event)
{
	static cudaError_t (*lcudaEventSynchronize) (cudaEvent_t );
	if (!lcudaEventSynchronize) {
		lcudaEventSynchronize = (cudaError_t (*) (cudaEvent_t )) dlsym(RTLD_NEXT, "cudaEventSynchronize");
		tracer._kernel_map[(void *) lcudaEventSynchronize] = std::string("cudaEventSynchronize");
	}
	assert(lcudaEventSynchronize);
	cudaError_t res = 
		lcudaEventSynchronize(event);
	return res;
}

cudaError_t cudaEventDestroy(cudaEvent_t  event)
{
	static cudaError_t (*lcudaEventDestroy) (cudaEvent_t );
	if (!lcudaEventDestroy) {
		lcudaEventDestroy = (cudaError_t (*) (cudaEvent_t )) dlsym(RTLD_NEXT, "cudaEventDestroy");
		tracer._kernel_map[(void *) lcudaEventDestroy] = std::string("cudaEventDestroy");
	}
	assert(lcudaEventDestroy);
	cudaError_t res = 
		lcudaEventDestroy(event);
	return res;
}

cudaError_t cudaEventElapsedTime(float * ms, cudaEvent_t  start, cudaEvent_t  end)
{
	static cudaError_t (*lcudaEventElapsedTime) (float *, cudaEvent_t , cudaEvent_t );
	if (!lcudaEventElapsedTime) {
		lcudaEventElapsedTime = (cudaError_t (*) (float *, cudaEvent_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaEventElapsedTime");
		tracer._kernel_map[(void *) lcudaEventElapsedTime] = std::string("cudaEventElapsedTime");
	}
	assert(lcudaEventElapsedTime);
	cudaError_t res = 
		lcudaEventElapsedTime(ms, start, end);
	return res;
}

cudaError_t cudaImportExternalMemory(cudaExternalMemory_t * extMem_out, const struct cudaExternalMemoryHandleDesc * memHandleDesc)
{
	static cudaError_t (*lcudaImportExternalMemory) (cudaExternalMemory_t *, const struct cudaExternalMemoryHandleDesc *);
	if (!lcudaImportExternalMemory) {
		lcudaImportExternalMemory = (cudaError_t (*) (cudaExternalMemory_t *, const struct cudaExternalMemoryHandleDesc *)) dlsym(RTLD_NEXT, "cudaImportExternalMemory");
		tracer._kernel_map[(void *) lcudaImportExternalMemory] = std::string("cudaImportExternalMemory");
	}
	assert(lcudaImportExternalMemory);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaImportExternalMemory(extMem_out, memHandleDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaImportExternalMemory);
	}
	return res;
}

cudaError_t cudaExternalMemoryGetMappedBuffer(void ** devPtr, cudaExternalMemory_t  extMem, const struct cudaExternalMemoryBufferDesc * bufferDesc)
{
	static cudaError_t (*lcudaExternalMemoryGetMappedBuffer) (void **, cudaExternalMemory_t , const struct cudaExternalMemoryBufferDesc *);
	if (!lcudaExternalMemoryGetMappedBuffer) {
		lcudaExternalMemoryGetMappedBuffer = (cudaError_t (*) (void **, cudaExternalMemory_t , const struct cudaExternalMemoryBufferDesc *)) dlsym(RTLD_NEXT, "cudaExternalMemoryGetMappedBuffer");
		tracer._kernel_map[(void *) lcudaExternalMemoryGetMappedBuffer] = std::string("cudaExternalMemoryGetMappedBuffer");
	}
	assert(lcudaExternalMemoryGetMappedBuffer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaExternalMemoryGetMappedBuffer(devPtr, extMem, bufferDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaExternalMemoryGetMappedBuffer);
	}
	return res;
}

cudaError_t cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t * mipmap, cudaExternalMemory_t  extMem, const struct cudaExternalMemoryMipmappedArrayDesc * mipmapDesc)
{
	static cudaError_t (*lcudaExternalMemoryGetMappedMipmappedArray) (cudaMipmappedArray_t *, cudaExternalMemory_t , const struct cudaExternalMemoryMipmappedArrayDesc *);
	if (!lcudaExternalMemoryGetMappedMipmappedArray) {
		lcudaExternalMemoryGetMappedMipmappedArray = (cudaError_t (*) (cudaMipmappedArray_t *, cudaExternalMemory_t , const struct cudaExternalMemoryMipmappedArrayDesc *)) dlsym(RTLD_NEXT, "cudaExternalMemoryGetMappedMipmappedArray");
		tracer._kernel_map[(void *) lcudaExternalMemoryGetMappedMipmappedArray] = std::string("cudaExternalMemoryGetMappedMipmappedArray");
	}
	assert(lcudaExternalMemoryGetMappedMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaExternalMemoryGetMappedMipmappedArray(mipmap, extMem, mipmapDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaExternalMemoryGetMappedMipmappedArray);
	}
	return res;
}

cudaError_t cudaDestroyExternalMemory(cudaExternalMemory_t  extMem)
{
	static cudaError_t (*lcudaDestroyExternalMemory) (cudaExternalMemory_t );
	if (!lcudaDestroyExternalMemory) {
		lcudaDestroyExternalMemory = (cudaError_t (*) (cudaExternalMemory_t )) dlsym(RTLD_NEXT, "cudaDestroyExternalMemory");
		tracer._kernel_map[(void *) lcudaDestroyExternalMemory] = std::string("cudaDestroyExternalMemory");
	}
	assert(lcudaDestroyExternalMemory);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDestroyExternalMemory(extMem);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDestroyExternalMemory);
	}
	return res;
}

cudaError_t cudaImportExternalSemaphore(cudaExternalSemaphore_t * extSem_out, const struct cudaExternalSemaphoreHandleDesc * semHandleDesc)
{
	static cudaError_t (*lcudaImportExternalSemaphore) (cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreHandleDesc *);
	if (!lcudaImportExternalSemaphore) {
		lcudaImportExternalSemaphore = (cudaError_t (*) (cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreHandleDesc *)) dlsym(RTLD_NEXT, "cudaImportExternalSemaphore");
		tracer._kernel_map[(void *) lcudaImportExternalSemaphore] = std::string("cudaImportExternalSemaphore");
	}
	assert(lcudaImportExternalSemaphore);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaImportExternalSemaphore(extSem_out, semHandleDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaImportExternalSemaphore);
	}
	return res;
}

cudaError_t cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const struct cudaExternalSemaphoreSignalParams * paramsArray, unsigned int  numExtSems, cudaStream_t  stream)
{
	static cudaError_t (*lcudaSignalExternalSemaphoresAsync_v2) (const cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreSignalParams *, unsigned int , cudaStream_t );
	if (!lcudaSignalExternalSemaphoresAsync_v2) {
		lcudaSignalExternalSemaphoresAsync_v2 = (cudaError_t (*) (const cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreSignalParams *, unsigned int , cudaStream_t )) dlsym(RTLD_NEXT, "cudaSignalExternalSemaphoresAsync_v2");
		tracer._kernel_map[(void *) lcudaSignalExternalSemaphoresAsync_v2] = std::string("cudaSignalExternalSemaphoresAsync_v2");
	}
	assert(lcudaSignalExternalSemaphoresAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSignalExternalSemaphoresAsync_v2(extSemArray, paramsArray, numExtSems, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSignalExternalSemaphoresAsync_v2);
	}
	return res;
}

cudaError_t cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const struct cudaExternalSemaphoreWaitParams * paramsArray, unsigned int  numExtSems, cudaStream_t  stream)
{
	static cudaError_t (*lcudaWaitExternalSemaphoresAsync_v2) (const cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreWaitParams *, unsigned int , cudaStream_t );
	if (!lcudaWaitExternalSemaphoresAsync_v2) {
		lcudaWaitExternalSemaphoresAsync_v2 = (cudaError_t (*) (const cudaExternalSemaphore_t *, const struct cudaExternalSemaphoreWaitParams *, unsigned int , cudaStream_t )) dlsym(RTLD_NEXT, "cudaWaitExternalSemaphoresAsync_v2");
		tracer._kernel_map[(void *) lcudaWaitExternalSemaphoresAsync_v2] = std::string("cudaWaitExternalSemaphoresAsync_v2");
	}
	assert(lcudaWaitExternalSemaphoresAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaWaitExternalSemaphoresAsync_v2(extSemArray, paramsArray, numExtSems, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaWaitExternalSemaphoresAsync_v2);
	}
	return res;
}

cudaError_t cudaDestroyExternalSemaphore(cudaExternalSemaphore_t  extSem)
{
	static cudaError_t (*lcudaDestroyExternalSemaphore) (cudaExternalSemaphore_t );
	if (!lcudaDestroyExternalSemaphore) {
		lcudaDestroyExternalSemaphore = (cudaError_t (*) (cudaExternalSemaphore_t )) dlsym(RTLD_NEXT, "cudaDestroyExternalSemaphore");
		tracer._kernel_map[(void *) lcudaDestroyExternalSemaphore] = std::string("cudaDestroyExternalSemaphore");
	}
	assert(lcudaDestroyExternalSemaphore);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDestroyExternalSemaphore(extSem);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDestroyExternalSemaphore);
	}
	return res;
}


cudaError_t cudaLaunchKernel(const void * func, dim3  gridDim, dim3  blockDim, void ** args, size_t  sharedMem, cudaStream_t  stream)
{
    static cudaError_t (*lcudaLaunchKernel) (const void *, dim3 , dim3 , void **, size_t , cudaStream_t );
    if (!lcudaLaunchKernel) {
        lcudaLaunchKernel = (cudaError_t (*) (const void *, dim3 , dim3 , void **, size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaLaunchKernel");
    }
    assert(lcudaLaunchKernel);

    
    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }

    cudaError_t err = lcudaLaunchKernel(func, gridDim, blockDim, args, sharedMem, stream);
    
    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }


    if (tracer.profile_start) {
        tracer._kernel_seq.push_back(func);
    }

    return err;
}
        

cudaError_t cudaLaunchKernelExC(const cudaLaunchConfig_t * config, const void * func, void ** args)
{
	static cudaError_t (*lcudaLaunchKernelExC) (const cudaLaunchConfig_t *, const void *, void **);
	if (!lcudaLaunchKernelExC) {
		lcudaLaunchKernelExC = (cudaError_t (*) (const cudaLaunchConfig_t *, const void *, void **)) dlsym(RTLD_NEXT, "cudaLaunchKernelExC");
		tracer._kernel_map[(void *) lcudaLaunchKernelExC] = std::string("cudaLaunchKernelExC");
	}
	assert(lcudaLaunchKernelExC);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaLaunchKernelExC(config, func, args);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaLaunchKernelExC);
	}
	return res;
}

cudaError_t cudaLaunchCooperativeKernel(const void * func, dim3  gridDim, dim3  blockDim, void ** args, size_t  sharedMem, cudaStream_t  stream)
{
	static cudaError_t (*lcudaLaunchCooperativeKernel) (const void *, dim3 , dim3 , void **, size_t , cudaStream_t );
	if (!lcudaLaunchCooperativeKernel) {
		lcudaLaunchCooperativeKernel = (cudaError_t (*) (const void *, dim3 , dim3 , void **, size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaLaunchCooperativeKernel");
		tracer._kernel_map[(void *) lcudaLaunchCooperativeKernel] = std::string("cudaLaunchCooperativeKernel");
	}
	assert(lcudaLaunchCooperativeKernel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaLaunchCooperativeKernel(func, gridDim, blockDim, args, sharedMem, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaLaunchCooperativeKernel);
	}
	return res;
}

cudaError_t cudaLaunchCooperativeKernelMultiDevice(struct cudaLaunchParams * launchParamsList, unsigned int  numDevices, unsigned int  flags)
{
	static cudaError_t (*lcudaLaunchCooperativeKernelMultiDevice) (struct cudaLaunchParams *, unsigned int , unsigned int );
	if (!lcudaLaunchCooperativeKernelMultiDevice) {
		lcudaLaunchCooperativeKernelMultiDevice = (cudaError_t (*) (struct cudaLaunchParams *, unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaLaunchCooperativeKernelMultiDevice");
		tracer._kernel_map[(void *) lcudaLaunchCooperativeKernelMultiDevice] = std::string("cudaLaunchCooperativeKernelMultiDevice");
	}
	assert(lcudaLaunchCooperativeKernelMultiDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaLaunchCooperativeKernelMultiDevice(launchParamsList, numDevices, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaLaunchCooperativeKernelMultiDevice);
	}
	return res;
}

cudaError_t cudaFuncSetCacheConfig(const void * func, enum cudaFuncCache  cacheConfig)
{
	static cudaError_t (*lcudaFuncSetCacheConfig) (const void *, enum cudaFuncCache );
	if (!lcudaFuncSetCacheConfig) {
		lcudaFuncSetCacheConfig = (cudaError_t (*) (const void *, enum cudaFuncCache )) dlsym(RTLD_NEXT, "cudaFuncSetCacheConfig");
		tracer._kernel_map[(void *) lcudaFuncSetCacheConfig] = std::string("cudaFuncSetCacheConfig");
	}
	assert(lcudaFuncSetCacheConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFuncSetCacheConfig(func, cacheConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFuncSetCacheConfig);
	}
	return res;
}

cudaError_t cudaFuncSetSharedMemConfig(const void * func, enum cudaSharedMemConfig  config)
{
	static cudaError_t (*lcudaFuncSetSharedMemConfig) (const void *, enum cudaSharedMemConfig );
	if (!lcudaFuncSetSharedMemConfig) {
		lcudaFuncSetSharedMemConfig = (cudaError_t (*) (const void *, enum cudaSharedMemConfig )) dlsym(RTLD_NEXT, "cudaFuncSetSharedMemConfig");
		tracer._kernel_map[(void *) lcudaFuncSetSharedMemConfig] = std::string("cudaFuncSetSharedMemConfig");
	}
	assert(lcudaFuncSetSharedMemConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFuncSetSharedMemConfig(func, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFuncSetSharedMemConfig);
	}
	return res;
}

cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes * attr, const void * func)
{
	static cudaError_t (*lcudaFuncGetAttributes) (struct cudaFuncAttributes *, const void *);
	if (!lcudaFuncGetAttributes) {
		lcudaFuncGetAttributes = (cudaError_t (*) (struct cudaFuncAttributes *, const void *)) dlsym(RTLD_NEXT, "cudaFuncGetAttributes");
		tracer._kernel_map[(void *) lcudaFuncGetAttributes] = std::string("cudaFuncGetAttributes");
	}
	assert(lcudaFuncGetAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFuncGetAttributes(attr, func);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFuncGetAttributes);
	}
	return res;
}

cudaError_t cudaFuncSetAttribute(const void * func, enum cudaFuncAttribute  attr, int  value)
{
	static cudaError_t (*lcudaFuncSetAttribute) (const void *, enum cudaFuncAttribute , int );
	if (!lcudaFuncSetAttribute) {
		lcudaFuncSetAttribute = (cudaError_t (*) (const void *, enum cudaFuncAttribute , int )) dlsym(RTLD_NEXT, "cudaFuncSetAttribute");
		tracer._kernel_map[(void *) lcudaFuncSetAttribute] = std::string("cudaFuncSetAttribute");
	}
	assert(lcudaFuncSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFuncSetAttribute(func, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFuncSetAttribute);
	}
	return res;
}

cudaError_t cudaSetDoubleForDevice(double * d)
{
	static cudaError_t (*lcudaSetDoubleForDevice) (double *);
	if (!lcudaSetDoubleForDevice) {
		lcudaSetDoubleForDevice = (cudaError_t (*) (double *)) dlsym(RTLD_NEXT, "cudaSetDoubleForDevice");
		tracer._kernel_map[(void *) lcudaSetDoubleForDevice] = std::string("cudaSetDoubleForDevice");
	}
	assert(lcudaSetDoubleForDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSetDoubleForDevice(d);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSetDoubleForDevice);
	}
	return res;
}

cudaError_t cudaSetDoubleForHost(double * d)
{
	static cudaError_t (*lcudaSetDoubleForHost) (double *);
	if (!lcudaSetDoubleForHost) {
		lcudaSetDoubleForHost = (cudaError_t (*) (double *)) dlsym(RTLD_NEXT, "cudaSetDoubleForHost");
		tracer._kernel_map[(void *) lcudaSetDoubleForHost] = std::string("cudaSetDoubleForHost");
	}
	assert(lcudaSetDoubleForHost);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaSetDoubleForHost(d);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaSetDoubleForHost);
	}
	return res;
}

cudaError_t cudaLaunchHostFunc(cudaStream_t  stream, cudaHostFn_t  fn, void * userData)
{
	static cudaError_t (*lcudaLaunchHostFunc) (cudaStream_t , cudaHostFn_t , void *);
	if (!lcudaLaunchHostFunc) {
		lcudaLaunchHostFunc = (cudaError_t (*) (cudaStream_t , cudaHostFn_t , void *)) dlsym(RTLD_NEXT, "cudaLaunchHostFunc");
		tracer._kernel_map[(void *) lcudaLaunchHostFunc] = std::string("cudaLaunchHostFunc");
	}
	assert(lcudaLaunchHostFunc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaLaunchHostFunc(stream, fn, userData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaLaunchHostFunc);
	}
	return res;
}

cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int  blockSize, size_t  dynamicSMemSize)
{
	static cudaError_t (*lcudaOccupancyMaxActiveBlocksPerMultiprocessor) (int *, const void *, int , size_t );
	if (!lcudaOccupancyMaxActiveBlocksPerMultiprocessor) {
		lcudaOccupancyMaxActiveBlocksPerMultiprocessor = (cudaError_t (*) (int *, const void *, int , size_t )) dlsym(RTLD_NEXT, "cudaOccupancyMaxActiveBlocksPerMultiprocessor");
		tracer._kernel_map[(void *) lcudaOccupancyMaxActiveBlocksPerMultiprocessor] = std::string("cudaOccupancyMaxActiveBlocksPerMultiprocessor");
	}
	assert(lcudaOccupancyMaxActiveBlocksPerMultiprocessor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks, func, blockSize, dynamicSMemSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaOccupancyMaxActiveBlocksPerMultiprocessor);
	}
	return res;
}

cudaError_t cudaOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, const void * func, int  numBlocks, int  blockSize)
{
	static cudaError_t (*lcudaOccupancyAvailableDynamicSMemPerBlock) (size_t *, const void *, int , int );
	if (!lcudaOccupancyAvailableDynamicSMemPerBlock) {
		lcudaOccupancyAvailableDynamicSMemPerBlock = (cudaError_t (*) (size_t *, const void *, int , int )) dlsym(RTLD_NEXT, "cudaOccupancyAvailableDynamicSMemPerBlock");
		tracer._kernel_map[(void *) lcudaOccupancyAvailableDynamicSMemPerBlock] = std::string("cudaOccupancyAvailableDynamicSMemPerBlock");
	}
	assert(lcudaOccupancyAvailableDynamicSMemPerBlock);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, func, numBlocks, blockSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaOccupancyAvailableDynamicSMemPerBlock);
	}
	return res;
}

cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int  blockSize, size_t  dynamicSMemSize, unsigned int  flags)
{
	static cudaError_t (*lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) (int *, const void *, int , size_t , unsigned int );
	if (!lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) {
		lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = (cudaError_t (*) (int *, const void *, int , size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags");
		tracer._kernel_map[(void *) lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags] = std::string("cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags");
	}
	assert(lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, func, blockSize, dynamicSMemSize, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags);
	}
	return res;
}

cudaError_t cudaOccupancyMaxPotentialClusterSize(int * clusterSize, const void * func, const cudaLaunchConfig_t * launchConfig)
{
	static cudaError_t (*lcudaOccupancyMaxPotentialClusterSize) (int *, const void *, const cudaLaunchConfig_t *);
	if (!lcudaOccupancyMaxPotentialClusterSize) {
		lcudaOccupancyMaxPotentialClusterSize = (cudaError_t (*) (int *, const void *, const cudaLaunchConfig_t *)) dlsym(RTLD_NEXT, "cudaOccupancyMaxPotentialClusterSize");
		tracer._kernel_map[(void *) lcudaOccupancyMaxPotentialClusterSize] = std::string("cudaOccupancyMaxPotentialClusterSize");
	}
	assert(lcudaOccupancyMaxPotentialClusterSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaOccupancyMaxPotentialClusterSize(clusterSize, func, launchConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaOccupancyMaxPotentialClusterSize);
	}
	return res;
}

cudaError_t cudaOccupancyMaxActiveClusters(int * numClusters, const void * func, const cudaLaunchConfig_t * launchConfig)
{
	static cudaError_t (*lcudaOccupancyMaxActiveClusters) (int *, const void *, const cudaLaunchConfig_t *);
	if (!lcudaOccupancyMaxActiveClusters) {
		lcudaOccupancyMaxActiveClusters = (cudaError_t (*) (int *, const void *, const cudaLaunchConfig_t *)) dlsym(RTLD_NEXT, "cudaOccupancyMaxActiveClusters");
		tracer._kernel_map[(void *) lcudaOccupancyMaxActiveClusters] = std::string("cudaOccupancyMaxActiveClusters");
	}
	assert(lcudaOccupancyMaxActiveClusters);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaOccupancyMaxActiveClusters(numClusters, func, launchConfig);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaOccupancyMaxActiveClusters);
	}
	return res;
}

cudaError_t cudaMallocManaged(void ** devPtr, size_t  size, unsigned int  flags)
{
	static cudaError_t (*lcudaMallocManaged) (void **, size_t , unsigned int );
	if (!lcudaMallocManaged) {
		lcudaMallocManaged = (cudaError_t (*) (void **, size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaMallocManaged");
		tracer._kernel_map[(void *) lcudaMallocManaged] = std::string("cudaMallocManaged");
	}
	assert(lcudaMallocManaged);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocManaged(devPtr, size, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocManaged);
	}
	return res;
}

cudaError_t cudaMalloc(void ** devPtr, size_t  size)
{
	static cudaError_t (*lcudaMalloc) (void **, size_t );
	if (!lcudaMalloc) {
		lcudaMalloc = (cudaError_t (*) (void **, size_t )) dlsym(RTLD_NEXT, "cudaMalloc");
		tracer._kernel_map[(void *) lcudaMalloc] = std::string("cudaMalloc");
	}
	assert(lcudaMalloc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMalloc(devPtr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMalloc);
	}
	return res;
}

cudaError_t cudaMallocHost(void ** ptr, size_t  size)
{
	static cudaError_t (*lcudaMallocHost) (void **, size_t );
	if (!lcudaMallocHost) {
		lcudaMallocHost = (cudaError_t (*) (void **, size_t )) dlsym(RTLD_NEXT, "cudaMallocHost");
		tracer._kernel_map[(void *) lcudaMallocHost] = std::string("cudaMallocHost");
	}
	assert(lcudaMallocHost);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocHost(ptr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocHost);
	}
	return res;
}

cudaError_t cudaMallocPitch(void ** devPtr, size_t * pitch, size_t  width, size_t  height)
{
	static cudaError_t (*lcudaMallocPitch) (void **, size_t *, size_t , size_t );
	if (!lcudaMallocPitch) {
		lcudaMallocPitch = (cudaError_t (*) (void **, size_t *, size_t , size_t )) dlsym(RTLD_NEXT, "cudaMallocPitch");
		tracer._kernel_map[(void *) lcudaMallocPitch] = std::string("cudaMallocPitch");
	}
	assert(lcudaMallocPitch);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocPitch(devPtr, pitch, width, height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocPitch);
	}
	return res;
}

cudaError_t cudaMallocArray(cudaArray_t * array, const struct cudaChannelFormatDesc * desc, size_t  width, size_t  height, unsigned int  flags)
{
	static cudaError_t (*lcudaMallocArray) (cudaArray_t *, const struct cudaChannelFormatDesc *, size_t , size_t , unsigned int );
	if (!lcudaMallocArray) {
		lcudaMallocArray = (cudaError_t (*) (cudaArray_t *, const struct cudaChannelFormatDesc *, size_t , size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaMallocArray");
		tracer._kernel_map[(void *) lcudaMallocArray] = std::string("cudaMallocArray");
	}
	assert(lcudaMallocArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocArray(array, desc, width, height, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocArray);
	}
	return res;
}

cudaError_t cudaFree(void * devPtr)
{
	static cudaError_t (*lcudaFree) (void *);
	if (!lcudaFree) {
		lcudaFree = (cudaError_t (*) (void *)) dlsym(RTLD_NEXT, "cudaFree");
		tracer._kernel_map[(void *) lcudaFree] = std::string("cudaFree");
	}
	assert(lcudaFree);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFree(devPtr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFree);
	}
	return res;
}

cudaError_t cudaFreeHost(void * ptr)
{
	static cudaError_t (*lcudaFreeHost) (void *);
	if (!lcudaFreeHost) {
		lcudaFreeHost = (cudaError_t (*) (void *)) dlsym(RTLD_NEXT, "cudaFreeHost");
		tracer._kernel_map[(void *) lcudaFreeHost] = std::string("cudaFreeHost");
	}
	assert(lcudaFreeHost);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFreeHost(ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFreeHost);
	}
	return res;
}

cudaError_t cudaFreeArray(cudaArray_t  array)
{
	static cudaError_t (*lcudaFreeArray) (cudaArray_t );
	if (!lcudaFreeArray) {
		lcudaFreeArray = (cudaError_t (*) (cudaArray_t )) dlsym(RTLD_NEXT, "cudaFreeArray");
		tracer._kernel_map[(void *) lcudaFreeArray] = std::string("cudaFreeArray");
	}
	assert(lcudaFreeArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFreeArray(array);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFreeArray);
	}
	return res;
}

cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t  mipmappedArray)
{
	static cudaError_t (*lcudaFreeMipmappedArray) (cudaMipmappedArray_t );
	if (!lcudaFreeMipmappedArray) {
		lcudaFreeMipmappedArray = (cudaError_t (*) (cudaMipmappedArray_t )) dlsym(RTLD_NEXT, "cudaFreeMipmappedArray");
		tracer._kernel_map[(void *) lcudaFreeMipmappedArray] = std::string("cudaFreeMipmappedArray");
	}
	assert(lcudaFreeMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFreeMipmappedArray(mipmappedArray);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFreeMipmappedArray);
	}
	return res;
}

cudaError_t cudaHostAlloc(void ** pHost, size_t  size, unsigned int  flags)
{
	static cudaError_t (*lcudaHostAlloc) (void **, size_t , unsigned int );
	if (!lcudaHostAlloc) {
		lcudaHostAlloc = (cudaError_t (*) (void **, size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaHostAlloc");
		tracer._kernel_map[(void *) lcudaHostAlloc] = std::string("cudaHostAlloc");
	}
	assert(lcudaHostAlloc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaHostAlloc(pHost, size, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaHostAlloc);
	}
	return res;
}

cudaError_t cudaHostRegister(void * ptr, size_t  size, unsigned int  flags)
{
	static cudaError_t (*lcudaHostRegister) (void *, size_t , unsigned int );
	if (!lcudaHostRegister) {
		lcudaHostRegister = (cudaError_t (*) (void *, size_t , unsigned int )) dlsym(RTLD_NEXT, "cudaHostRegister");
		tracer._kernel_map[(void *) lcudaHostRegister] = std::string("cudaHostRegister");
	}
	assert(lcudaHostRegister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaHostRegister(ptr, size, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaHostRegister);
	}
	return res;
}

cudaError_t cudaHostUnregister(void * ptr)
{
	static cudaError_t (*lcudaHostUnregister) (void *);
	if (!lcudaHostUnregister) {
		lcudaHostUnregister = (cudaError_t (*) (void *)) dlsym(RTLD_NEXT, "cudaHostUnregister");
		tracer._kernel_map[(void *) lcudaHostUnregister] = std::string("cudaHostUnregister");
	}
	assert(lcudaHostUnregister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaHostUnregister(ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaHostUnregister);
	}
	return res;
}

cudaError_t cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned int  flags)
{
	static cudaError_t (*lcudaHostGetDevicePointer) (void **, void *, unsigned int );
	if (!lcudaHostGetDevicePointer) {
		lcudaHostGetDevicePointer = (cudaError_t (*) (void **, void *, unsigned int )) dlsym(RTLD_NEXT, "cudaHostGetDevicePointer");
		tracer._kernel_map[(void *) lcudaHostGetDevicePointer] = std::string("cudaHostGetDevicePointer");
	}
	assert(lcudaHostGetDevicePointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaHostGetDevicePointer(pDevice, pHost, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaHostGetDevicePointer);
	}
	return res;
}

cudaError_t cudaHostGetFlags(unsigned int * pFlags, void * pHost)
{
	static cudaError_t (*lcudaHostGetFlags) (unsigned int *, void *);
	if (!lcudaHostGetFlags) {
		lcudaHostGetFlags = (cudaError_t (*) (unsigned int *, void *)) dlsym(RTLD_NEXT, "cudaHostGetFlags");
		tracer._kernel_map[(void *) lcudaHostGetFlags] = std::string("cudaHostGetFlags");
	}
	assert(lcudaHostGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaHostGetFlags(pFlags, pHost);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaHostGetFlags);
	}
	return res;
}

cudaError_t cudaMalloc3D(struct cudaPitchedPtr*  pitchedDevPtr, struct cudaExtent  extent)
{
	static cudaError_t (*lcudaMalloc3D) (struct cudaPitchedPtr* , struct cudaExtent );
	if (!lcudaMalloc3D) {
		lcudaMalloc3D = (cudaError_t (*) (struct cudaPitchedPtr* , struct cudaExtent )) dlsym(RTLD_NEXT, "cudaMalloc3D");
		tracer._kernel_map[(void *) lcudaMalloc3D] = std::string("cudaMalloc3D");
	}
	assert(lcudaMalloc3D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMalloc3D(pitchedDevPtr, extent);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMalloc3D);
	}
	return res;
}

cudaError_t cudaMalloc3DArray(cudaArray_t * array, const struct cudaChannelFormatDesc*  desc, struct cudaExtent  extent, unsigned int  flags)
{
	static cudaError_t (*lcudaMalloc3DArray) (cudaArray_t *, const struct cudaChannelFormatDesc* , struct cudaExtent , unsigned int );
	if (!lcudaMalloc3DArray) {
		lcudaMalloc3DArray = (cudaError_t (*) (cudaArray_t *, const struct cudaChannelFormatDesc* , struct cudaExtent , unsigned int )) dlsym(RTLD_NEXT, "cudaMalloc3DArray");
		tracer._kernel_map[(void *) lcudaMalloc3DArray] = std::string("cudaMalloc3DArray");
	}
	assert(lcudaMalloc3DArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMalloc3DArray(array, desc, extent, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMalloc3DArray);
	}
	return res;
}

cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const struct cudaChannelFormatDesc*  desc, struct cudaExtent  extent, unsigned int  numLevels, unsigned int  flags)
{
	static cudaError_t (*lcudaMallocMipmappedArray) (cudaMipmappedArray_t *, const struct cudaChannelFormatDesc* , struct cudaExtent , unsigned int , unsigned int );
	if (!lcudaMallocMipmappedArray) {
		lcudaMallocMipmappedArray = (cudaError_t (*) (cudaMipmappedArray_t *, const struct cudaChannelFormatDesc* , struct cudaExtent , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaMallocMipmappedArray");
		tracer._kernel_map[(void *) lcudaMallocMipmappedArray] = std::string("cudaMallocMipmappedArray");
	}
	assert(lcudaMallocMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocMipmappedArray(mipmappedArray, desc, extent, numLevels, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocMipmappedArray);
	}
	return res;
}

cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t  mipmappedArray, unsigned int  level)
{
	static cudaError_t (*lcudaGetMipmappedArrayLevel) (cudaArray_t *, cudaMipmappedArray_const_t , unsigned int );
	if (!lcudaGetMipmappedArrayLevel) {
		lcudaGetMipmappedArrayLevel = (cudaError_t (*) (cudaArray_t *, cudaMipmappedArray_const_t , unsigned int )) dlsym(RTLD_NEXT, "cudaGetMipmappedArrayLevel");
		tracer._kernel_map[(void *) lcudaGetMipmappedArrayLevel] = std::string("cudaGetMipmappedArrayLevel");
	}
	assert(lcudaGetMipmappedArrayLevel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetMipmappedArrayLevel(levelArray, mipmappedArray, level);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetMipmappedArrayLevel);
	}
	return res;
}

cudaError_t cudaMemcpy3D(const struct cudaMemcpy3DParms * p)
{
	static cudaError_t (*lcudaMemcpy3D) (const struct cudaMemcpy3DParms *);
	if (!lcudaMemcpy3D) {
		lcudaMemcpy3D = (cudaError_t (*) (const struct cudaMemcpy3DParms *)) dlsym(RTLD_NEXT, "cudaMemcpy3D");
		tracer._kernel_map[(void *) lcudaMemcpy3D] = std::string("cudaMemcpy3D");
	}
	assert(lcudaMemcpy3D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy3D(p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy3D);
	}
	return res;
}

cudaError_t cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms * p)
{
	static cudaError_t (*lcudaMemcpy3DPeer) (const struct cudaMemcpy3DPeerParms *);
	if (!lcudaMemcpy3DPeer) {
		lcudaMemcpy3DPeer = (cudaError_t (*) (const struct cudaMemcpy3DPeerParms *)) dlsym(RTLD_NEXT, "cudaMemcpy3DPeer");
		tracer._kernel_map[(void *) lcudaMemcpy3DPeer] = std::string("cudaMemcpy3DPeer");
	}
	assert(lcudaMemcpy3DPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy3DPeer(p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy3DPeer);
	}
	return res;
}

cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms * p, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpy3DAsync) (const struct cudaMemcpy3DParms *, cudaStream_t );
	if (!lcudaMemcpy3DAsync) {
		lcudaMemcpy3DAsync = (cudaError_t (*) (const struct cudaMemcpy3DParms *, cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpy3DAsync");
		tracer._kernel_map[(void *) lcudaMemcpy3DAsync] = std::string("cudaMemcpy3DAsync");
	}
	assert(lcudaMemcpy3DAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy3DAsync(p, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy3DAsync);
	}
	return res;
}

cudaError_t cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms * p, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpy3DPeerAsync) (const struct cudaMemcpy3DPeerParms *, cudaStream_t );
	if (!lcudaMemcpy3DPeerAsync) {
		lcudaMemcpy3DPeerAsync = (cudaError_t (*) (const struct cudaMemcpy3DPeerParms *, cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpy3DPeerAsync");
		tracer._kernel_map[(void *) lcudaMemcpy3DPeerAsync] = std::string("cudaMemcpy3DPeerAsync");
	}
	assert(lcudaMemcpy3DPeerAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy3DPeerAsync(p, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy3DPeerAsync);
	}
	return res;
}

cudaError_t cudaMemGetInfo(size_t * free, size_t * total)
{
	static cudaError_t (*lcudaMemGetInfo) (size_t *, size_t *);
	if (!lcudaMemGetInfo) {
		lcudaMemGetInfo = (cudaError_t (*) (size_t *, size_t *)) dlsym(RTLD_NEXT, "cudaMemGetInfo");
		tracer._kernel_map[(void *) lcudaMemGetInfo] = std::string("cudaMemGetInfo");
	}
	assert(lcudaMemGetInfo);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemGetInfo(free, total);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemGetInfo);
	}
	return res;
}

cudaError_t cudaArrayGetInfo(struct cudaChannelFormatDesc * desc, struct cudaExtent * extent, unsigned int * flags, cudaArray_t  array)
{
	static cudaError_t (*lcudaArrayGetInfo) (struct cudaChannelFormatDesc *, struct cudaExtent *, unsigned int *, cudaArray_t );
	if (!lcudaArrayGetInfo) {
		lcudaArrayGetInfo = (cudaError_t (*) (struct cudaChannelFormatDesc *, struct cudaExtent *, unsigned int *, cudaArray_t )) dlsym(RTLD_NEXT, "cudaArrayGetInfo");
		tracer._kernel_map[(void *) lcudaArrayGetInfo] = std::string("cudaArrayGetInfo");
	}
	assert(lcudaArrayGetInfo);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaArrayGetInfo(desc, extent, flags, array);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaArrayGetInfo);
	}
	return res;
}

cudaError_t cudaArrayGetPlane(cudaArray_t * pPlaneArray, cudaArray_t  hArray, unsigned int  planeIdx)
{
	static cudaError_t (*lcudaArrayGetPlane) (cudaArray_t *, cudaArray_t , unsigned int );
	if (!lcudaArrayGetPlane) {
		lcudaArrayGetPlane = (cudaError_t (*) (cudaArray_t *, cudaArray_t , unsigned int )) dlsym(RTLD_NEXT, "cudaArrayGetPlane");
		tracer._kernel_map[(void *) lcudaArrayGetPlane] = std::string("cudaArrayGetPlane");
	}
	assert(lcudaArrayGetPlane);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaArrayGetPlane(pPlaneArray, hArray, planeIdx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaArrayGetPlane);
	}
	return res;
}

cudaError_t cudaArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements * memoryRequirements, cudaArray_t  array, int  device)
{
	static cudaError_t (*lcudaArrayGetMemoryRequirements) (struct cudaArrayMemoryRequirements *, cudaArray_t , int );
	if (!lcudaArrayGetMemoryRequirements) {
		lcudaArrayGetMemoryRequirements = (cudaError_t (*) (struct cudaArrayMemoryRequirements *, cudaArray_t , int )) dlsym(RTLD_NEXT, "cudaArrayGetMemoryRequirements");
		tracer._kernel_map[(void *) lcudaArrayGetMemoryRequirements] = std::string("cudaArrayGetMemoryRequirements");
	}
	assert(lcudaArrayGetMemoryRequirements);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaArrayGetMemoryRequirements(memoryRequirements, array, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaArrayGetMemoryRequirements);
	}
	return res;
}

cudaError_t cudaMipmappedArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements * memoryRequirements, cudaMipmappedArray_t  mipmap, int  device)
{
	static cudaError_t (*lcudaMipmappedArrayGetMemoryRequirements) (struct cudaArrayMemoryRequirements *, cudaMipmappedArray_t , int );
	if (!lcudaMipmappedArrayGetMemoryRequirements) {
		lcudaMipmappedArrayGetMemoryRequirements = (cudaError_t (*) (struct cudaArrayMemoryRequirements *, cudaMipmappedArray_t , int )) dlsym(RTLD_NEXT, "cudaMipmappedArrayGetMemoryRequirements");
		tracer._kernel_map[(void *) lcudaMipmappedArrayGetMemoryRequirements] = std::string("cudaMipmappedArrayGetMemoryRequirements");
	}
	assert(lcudaMipmappedArrayGetMemoryRequirements);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMipmappedArrayGetMemoryRequirements(memoryRequirements, mipmap, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMipmappedArrayGetMemoryRequirements);
	}
	return res;
}

cudaError_t cudaArrayGetSparseProperties(struct cudaArraySparseProperties * sparseProperties, cudaArray_t  array)
{
	static cudaError_t (*lcudaArrayGetSparseProperties) (struct cudaArraySparseProperties *, cudaArray_t );
	if (!lcudaArrayGetSparseProperties) {
		lcudaArrayGetSparseProperties = (cudaError_t (*) (struct cudaArraySparseProperties *, cudaArray_t )) dlsym(RTLD_NEXT, "cudaArrayGetSparseProperties");
		tracer._kernel_map[(void *) lcudaArrayGetSparseProperties] = std::string("cudaArrayGetSparseProperties");
	}
	assert(lcudaArrayGetSparseProperties);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaArrayGetSparseProperties(sparseProperties, array);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaArrayGetSparseProperties);
	}
	return res;
}

cudaError_t cudaMipmappedArrayGetSparseProperties(struct cudaArraySparseProperties * sparseProperties, cudaMipmappedArray_t  mipmap)
{
	static cudaError_t (*lcudaMipmappedArrayGetSparseProperties) (struct cudaArraySparseProperties *, cudaMipmappedArray_t );
	if (!lcudaMipmappedArrayGetSparseProperties) {
		lcudaMipmappedArrayGetSparseProperties = (cudaError_t (*) (struct cudaArraySparseProperties *, cudaMipmappedArray_t )) dlsym(RTLD_NEXT, "cudaMipmappedArrayGetSparseProperties");
		tracer._kernel_map[(void *) lcudaMipmappedArrayGetSparseProperties] = std::string("cudaMipmappedArrayGetSparseProperties");
	}
	assert(lcudaMipmappedArrayGetSparseProperties);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMipmappedArrayGetSparseProperties(sparseProperties, mipmap);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMipmappedArrayGetSparseProperties);
	}
	return res;
}

cudaError_t cudaMemcpy(void * dst, const void * src, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpy) (void *, const void *, size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpy) {
		lcudaMemcpy = (cudaError_t (*) (void *, const void *, size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpy");
		tracer._kernel_map[(void *) lcudaMemcpy] = std::string("cudaMemcpy");
	}
	assert(lcudaMemcpy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy(dst, src, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy);
	}
	return res;
}

cudaError_t cudaMemcpyPeer(void * dst, int  dstDevice, const void * src, int  srcDevice, size_t  count)
{
	static cudaError_t (*lcudaMemcpyPeer) (void *, int , const void *, int , size_t );
	if (!lcudaMemcpyPeer) {
		lcudaMemcpyPeer = (cudaError_t (*) (void *, int , const void *, int , size_t )) dlsym(RTLD_NEXT, "cudaMemcpyPeer");
		tracer._kernel_map[(void *) lcudaMemcpyPeer] = std::string("cudaMemcpyPeer");
	}
	assert(lcudaMemcpyPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyPeer(dst, dstDevice, src, srcDevice, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyPeer);
	}
	return res;
}

cudaError_t cudaMemcpy2D(void * dst, size_t  dpitch, const void * src, size_t  spitch, size_t  width, size_t  height, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpy2D) (void *, size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpy2D) {
		lcudaMemcpy2D = (cudaError_t (*) (void *, size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpy2D");
		tracer._kernel_map[(void *) lcudaMemcpy2D] = std::string("cudaMemcpy2D");
	}
	assert(lcudaMemcpy2D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2D(dst, dpitch, src, spitch, width, height, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2D);
	}
	return res;
}

cudaError_t cudaMemcpy2DToArray(cudaArray_t  dst, size_t  wOffset, size_t  hOffset, const void * src, size_t  spitch, size_t  width, size_t  height, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpy2DToArray) (cudaArray_t , size_t , size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpy2DToArray) {
		lcudaMemcpy2DToArray = (cudaError_t (*) (cudaArray_t , size_t , size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpy2DToArray");
		tracer._kernel_map[(void *) lcudaMemcpy2DToArray] = std::string("cudaMemcpy2DToArray");
	}
	assert(lcudaMemcpy2DToArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DToArray(dst, wOffset, hOffset, src, spitch, width, height, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DToArray);
	}
	return res;
}

cudaError_t cudaMemcpy2DFromArray(void * dst, size_t  dpitch, cudaArray_const_t  src, size_t  wOffset, size_t  hOffset, size_t  width, size_t  height, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpy2DFromArray) (void *, size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpy2DFromArray) {
		lcudaMemcpy2DFromArray = (cudaError_t (*) (void *, size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpy2DFromArray");
		tracer._kernel_map[(void *) lcudaMemcpy2DFromArray] = std::string("cudaMemcpy2DFromArray");
	}
	assert(lcudaMemcpy2DFromArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DFromArray(dst, dpitch, src, wOffset, hOffset, width, height, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DFromArray);
	}
	return res;
}

cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t  dst, size_t  wOffsetDst, size_t  hOffsetDst, cudaArray_const_t  src, size_t  wOffsetSrc, size_t  hOffsetSrc, size_t  width, size_t  height, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpy2DArrayToArray) (cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpy2DArrayToArray) {
		lcudaMemcpy2DArrayToArray = (cudaError_t (*) (cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpy2DArrayToArray");
		tracer._kernel_map[(void *) lcudaMemcpy2DArrayToArray] = std::string("cudaMemcpy2DArrayToArray");
	}
	assert(lcudaMemcpy2DArrayToArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DArrayToArray(dst, wOffsetDst, hOffsetDst, src, wOffsetSrc, hOffsetSrc, width, height, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DArrayToArray);
	}
	return res;
}

cudaError_t cudaMemcpyToSymbol(const void * symbol, const void * src, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpyToSymbol) (const void *, const void *, size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpyToSymbol) {
		lcudaMemcpyToSymbol = (cudaError_t (*) (const void *, const void *, size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpyToSymbol");
		tracer._kernel_map[(void *) lcudaMemcpyToSymbol] = std::string("cudaMemcpyToSymbol");
	}
	assert(lcudaMemcpyToSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyToSymbol(symbol, src, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyToSymbol);
	}
	return res;
}

cudaError_t cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpyFromSymbol) (void *, const void *, size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpyFromSymbol) {
		lcudaMemcpyFromSymbol = (cudaError_t (*) (void *, const void *, size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpyFromSymbol");
		tracer._kernel_map[(void *) lcudaMemcpyFromSymbol] = std::string("cudaMemcpyFromSymbol");
	}
	assert(lcudaMemcpyFromSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyFromSymbol(dst, symbol, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyFromSymbol);
	}
	return res;
}

cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t  count, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyAsync) (void *, const void *, size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpyAsync) {
		lcudaMemcpyAsync = (cudaError_t (*) (void *, const void *, size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyAsync");
		tracer._kernel_map[(void *) lcudaMemcpyAsync] = std::string("cudaMemcpyAsync");
	}
	assert(lcudaMemcpyAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyAsync(dst, src, count, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyAsync);
	}
	return res;
}

cudaError_t cudaMemcpyPeerAsync(void * dst, int  dstDevice, const void * src, int  srcDevice, size_t  count, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyPeerAsync) (void *, int , const void *, int , size_t , cudaStream_t );
	if (!lcudaMemcpyPeerAsync) {
		lcudaMemcpyPeerAsync = (cudaError_t (*) (void *, int , const void *, int , size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyPeerAsync");
		tracer._kernel_map[(void *) lcudaMemcpyPeerAsync] = std::string("cudaMemcpyPeerAsync");
	}
	assert(lcudaMemcpyPeerAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyPeerAsync(dst, dstDevice, src, srcDevice, count, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyPeerAsync);
	}
	return res;
}

cudaError_t cudaMemcpy2DAsync(void * dst, size_t  dpitch, const void * src, size_t  spitch, size_t  width, size_t  height, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpy2DAsync) (void *, size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpy2DAsync) {
		lcudaMemcpy2DAsync = (cudaError_t (*) (void *, size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpy2DAsync");
		tracer._kernel_map[(void *) lcudaMemcpy2DAsync] = std::string("cudaMemcpy2DAsync");
	}
	assert(lcudaMemcpy2DAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DAsync(dst, dpitch, src, spitch, width, height, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DAsync);
	}
	return res;
}

cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t  dst, size_t  wOffset, size_t  hOffset, const void * src, size_t  spitch, size_t  width, size_t  height, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpy2DToArrayAsync) (cudaArray_t , size_t , size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpy2DToArrayAsync) {
		lcudaMemcpy2DToArrayAsync = (cudaError_t (*) (cudaArray_t , size_t , size_t , const void *, size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpy2DToArrayAsync");
		tracer._kernel_map[(void *) lcudaMemcpy2DToArrayAsync] = std::string("cudaMemcpy2DToArrayAsync");
	}
	assert(lcudaMemcpy2DToArrayAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DToArrayAsync(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DToArrayAsync);
	}
	return res;
}

cudaError_t cudaMemcpy2DFromArrayAsync(void * dst, size_t  dpitch, cudaArray_const_t  src, size_t  wOffset, size_t  hOffset, size_t  width, size_t  height, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpy2DFromArrayAsync) (void *, size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpy2DFromArrayAsync) {
		lcudaMemcpy2DFromArrayAsync = (cudaError_t (*) (void *, size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpy2DFromArrayAsync");
		tracer._kernel_map[(void *) lcudaMemcpy2DFromArrayAsync] = std::string("cudaMemcpy2DFromArrayAsync");
	}
	assert(lcudaMemcpy2DFromArrayAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpy2DFromArrayAsync(dst, dpitch, src, wOffset, hOffset, width, height, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpy2DFromArrayAsync);
	}
	return res;
}

cudaError_t cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t  count, size_t  offset, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyToSymbolAsync) (const void *, const void *, size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpyToSymbolAsync) {
		lcudaMemcpyToSymbolAsync = (cudaError_t (*) (const void *, const void *, size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyToSymbolAsync");
		tracer._kernel_map[(void *) lcudaMemcpyToSymbolAsync] = std::string("cudaMemcpyToSymbolAsync");
	}
	assert(lcudaMemcpyToSymbolAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyToSymbolAsync(symbol, src, count, offset, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyToSymbolAsync);
	}
	return res;
}

cudaError_t cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t  count, size_t  offset, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyFromSymbolAsync) (void *, const void *, size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpyFromSymbolAsync) {
		lcudaMemcpyFromSymbolAsync = (cudaError_t (*) (void *, const void *, size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyFromSymbolAsync");
		tracer._kernel_map[(void *) lcudaMemcpyFromSymbolAsync] = std::string("cudaMemcpyFromSymbolAsync");
	}
	assert(lcudaMemcpyFromSymbolAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyFromSymbolAsync(dst, symbol, count, offset, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyFromSymbolAsync);
	}
	return res;
}

cudaError_t cudaMemset(void * devPtr, int  value, size_t  count)
{
	static cudaError_t (*lcudaMemset) (void *, int , size_t );
	if (!lcudaMemset) {
		lcudaMemset = (cudaError_t (*) (void *, int , size_t )) dlsym(RTLD_NEXT, "cudaMemset");
		tracer._kernel_map[(void *) lcudaMemset] = std::string("cudaMemset");
	}
	assert(lcudaMemset);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemset(devPtr, value, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemset);
	}
	return res;
}

cudaError_t cudaMemset2D(void * devPtr, size_t  pitch, int  value, size_t  width, size_t  height)
{
	static cudaError_t (*lcudaMemset2D) (void *, size_t , int , size_t , size_t );
	if (!lcudaMemset2D) {
		lcudaMemset2D = (cudaError_t (*) (void *, size_t , int , size_t , size_t )) dlsym(RTLD_NEXT, "cudaMemset2D");
		tracer._kernel_map[(void *) lcudaMemset2D] = std::string("cudaMemset2D");
	}
	assert(lcudaMemset2D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemset2D(devPtr, pitch, value, width, height);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemset2D);
	}
	return res;
}

cudaError_t cudaMemset3D(struct cudaPitchedPtr  pitchedDevPtr, int  value, struct cudaExtent  extent)
{
	static cudaError_t (*lcudaMemset3D) (struct cudaPitchedPtr , int , struct cudaExtent );
	if (!lcudaMemset3D) {
		lcudaMemset3D = (cudaError_t (*) (struct cudaPitchedPtr , int , struct cudaExtent )) dlsym(RTLD_NEXT, "cudaMemset3D");
		tracer._kernel_map[(void *) lcudaMemset3D] = std::string("cudaMemset3D");
	}
	assert(lcudaMemset3D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemset3D(pitchedDevPtr, value, extent);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemset3D);
	}
	return res;
}

cudaError_t cudaMemsetAsync(void * devPtr, int  value, size_t  count, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemsetAsync) (void *, int , size_t , cudaStream_t );
	if (!lcudaMemsetAsync) {
		lcudaMemsetAsync = (cudaError_t (*) (void *, int , size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemsetAsync");
		tracer._kernel_map[(void *) lcudaMemsetAsync] = std::string("cudaMemsetAsync");
	}
	assert(lcudaMemsetAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemsetAsync(devPtr, value, count, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemsetAsync);
	}
	return res;
}

cudaError_t cudaMemset2DAsync(void * devPtr, size_t  pitch, int  value, size_t  width, size_t  height, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemset2DAsync) (void *, size_t , int , size_t , size_t , cudaStream_t );
	if (!lcudaMemset2DAsync) {
		lcudaMemset2DAsync = (cudaError_t (*) (void *, size_t , int , size_t , size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemset2DAsync");
		tracer._kernel_map[(void *) lcudaMemset2DAsync] = std::string("cudaMemset2DAsync");
	}
	assert(lcudaMemset2DAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemset2DAsync(devPtr, pitch, value, width, height, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemset2DAsync);
	}
	return res;
}

cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr  pitchedDevPtr, int  value, struct cudaExtent  extent, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemset3DAsync) (struct cudaPitchedPtr , int , struct cudaExtent , cudaStream_t );
	if (!lcudaMemset3DAsync) {
		lcudaMemset3DAsync = (cudaError_t (*) (struct cudaPitchedPtr , int , struct cudaExtent , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemset3DAsync");
		tracer._kernel_map[(void *) lcudaMemset3DAsync] = std::string("cudaMemset3DAsync");
	}
	assert(lcudaMemset3DAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemset3DAsync(pitchedDevPtr, value, extent, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemset3DAsync);
	}
	return res;
}

cudaError_t cudaGetSymbolAddress(void ** devPtr, const void * symbol)
{
	static cudaError_t (*lcudaGetSymbolAddress) (void **, const void *);
	if (!lcudaGetSymbolAddress) {
		lcudaGetSymbolAddress = (cudaError_t (*) (void **, const void *)) dlsym(RTLD_NEXT, "cudaGetSymbolAddress");
		tracer._kernel_map[(void *) lcudaGetSymbolAddress] = std::string("cudaGetSymbolAddress");
	}
	assert(lcudaGetSymbolAddress);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetSymbolAddress(devPtr, symbol);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetSymbolAddress);
	}
	return res;
}

cudaError_t cudaGetSymbolSize(size_t * size, const void * symbol)
{
	static cudaError_t (*lcudaGetSymbolSize) (size_t *, const void *);
	if (!lcudaGetSymbolSize) {
		lcudaGetSymbolSize = (cudaError_t (*) (size_t *, const void *)) dlsym(RTLD_NEXT, "cudaGetSymbolSize");
		tracer._kernel_map[(void *) lcudaGetSymbolSize] = std::string("cudaGetSymbolSize");
	}
	assert(lcudaGetSymbolSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetSymbolSize(size, symbol);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetSymbolSize);
	}
	return res;
}

cudaError_t cudaMemPrefetchAsync(const void * devPtr, size_t  count, int  dstDevice, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemPrefetchAsync) (const void *, size_t , int , cudaStream_t );
	if (!lcudaMemPrefetchAsync) {
		lcudaMemPrefetchAsync = (cudaError_t (*) (const void *, size_t , int , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemPrefetchAsync");
		tracer._kernel_map[(void *) lcudaMemPrefetchAsync] = std::string("cudaMemPrefetchAsync");
	}
	assert(lcudaMemPrefetchAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPrefetchAsync(devPtr, count, dstDevice, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPrefetchAsync);
	}
	return res;
}

cudaError_t cudaMemPrefetchAsync_v2(const void * devPtr, size_t  count, struct cudaMemLocation  location, unsigned int  flags, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemPrefetchAsync_v2) (const void *, size_t , struct cudaMemLocation , unsigned int , cudaStream_t );
	if (!lcudaMemPrefetchAsync_v2) {
		lcudaMemPrefetchAsync_v2 = (cudaError_t (*) (const void *, size_t , struct cudaMemLocation , unsigned int , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemPrefetchAsync_v2");
		tracer._kernel_map[(void *) lcudaMemPrefetchAsync_v2] = std::string("cudaMemPrefetchAsync_v2");
	}
	assert(lcudaMemPrefetchAsync_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPrefetchAsync_v2(devPtr, count, location, flags, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPrefetchAsync_v2);
	}
	return res;
}

cudaError_t cudaMemAdvise(const void * devPtr, size_t  count, enum cudaMemoryAdvise  advice, int  device)
{
	static cudaError_t (*lcudaMemAdvise) (const void *, size_t , enum cudaMemoryAdvise , int );
	if (!lcudaMemAdvise) {
		lcudaMemAdvise = (cudaError_t (*) (const void *, size_t , enum cudaMemoryAdvise , int )) dlsym(RTLD_NEXT, "cudaMemAdvise");
		tracer._kernel_map[(void *) lcudaMemAdvise] = std::string("cudaMemAdvise");
	}
	assert(lcudaMemAdvise);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemAdvise(devPtr, count, advice, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemAdvise);
	}
	return res;
}

cudaError_t cudaMemAdvise_v2(const void * devPtr, size_t  count, enum cudaMemoryAdvise  advice, struct cudaMemLocation  location)
{
	static cudaError_t (*lcudaMemAdvise_v2) (const void *, size_t , enum cudaMemoryAdvise , struct cudaMemLocation );
	if (!lcudaMemAdvise_v2) {
		lcudaMemAdvise_v2 = (cudaError_t (*) (const void *, size_t , enum cudaMemoryAdvise , struct cudaMemLocation )) dlsym(RTLD_NEXT, "cudaMemAdvise_v2");
		tracer._kernel_map[(void *) lcudaMemAdvise_v2] = std::string("cudaMemAdvise_v2");
	}
	assert(lcudaMemAdvise_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemAdvise_v2(devPtr, count, advice, location);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemAdvise_v2);
	}
	return res;
}

cudaError_t cudaMemRangeGetAttribute(void * data, size_t  dataSize, enum cudaMemRangeAttribute  attribute, const void * devPtr, size_t  count)
{
	static cudaError_t (*lcudaMemRangeGetAttribute) (void *, size_t , enum cudaMemRangeAttribute , const void *, size_t );
	if (!lcudaMemRangeGetAttribute) {
		lcudaMemRangeGetAttribute = (cudaError_t (*) (void *, size_t , enum cudaMemRangeAttribute , const void *, size_t )) dlsym(RTLD_NEXT, "cudaMemRangeGetAttribute");
		tracer._kernel_map[(void *) lcudaMemRangeGetAttribute] = std::string("cudaMemRangeGetAttribute");
	}
	assert(lcudaMemRangeGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemRangeGetAttribute(data, dataSize, attribute, devPtr, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemRangeGetAttribute);
	}
	return res;
}

cudaError_t cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, enum cudaMemRangeAttribute * attributes, size_t  numAttributes, const void * devPtr, size_t  count)
{
	static cudaError_t (*lcudaMemRangeGetAttributes) (void **, size_t *, enum cudaMemRangeAttribute *, size_t , const void *, size_t );
	if (!lcudaMemRangeGetAttributes) {
		lcudaMemRangeGetAttributes = (cudaError_t (*) (void **, size_t *, enum cudaMemRangeAttribute *, size_t , const void *, size_t )) dlsym(RTLD_NEXT, "cudaMemRangeGetAttributes");
		tracer._kernel_map[(void *) lcudaMemRangeGetAttributes] = std::string("cudaMemRangeGetAttributes");
	}
	assert(lcudaMemRangeGetAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemRangeGetAttributes(data, dataSizes, attributes, numAttributes, devPtr, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemRangeGetAttributes);
	}
	return res;
}

cudaError_t cudaMemcpyToArray(cudaArray_t  dst, size_t  wOffset, size_t  hOffset, const void * src, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpyToArray) (cudaArray_t , size_t , size_t , const void *, size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpyToArray) {
		lcudaMemcpyToArray = (cudaError_t (*) (cudaArray_t , size_t , size_t , const void *, size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpyToArray");
		tracer._kernel_map[(void *) lcudaMemcpyToArray] = std::string("cudaMemcpyToArray");
	}
	assert(lcudaMemcpyToArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyToArray(dst, wOffset, hOffset, src, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyToArray);
	}
	return res;
}

cudaError_t cudaMemcpyFromArray(void * dst, cudaArray_const_t  src, size_t  wOffset, size_t  hOffset, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpyFromArray) (void *, cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpyFromArray) {
		lcudaMemcpyFromArray = (cudaError_t (*) (void *, cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpyFromArray");
		tracer._kernel_map[(void *) lcudaMemcpyFromArray] = std::string("cudaMemcpyFromArray");
	}
	assert(lcudaMemcpyFromArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyFromArray(dst, src, wOffset, hOffset, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyFromArray);
	}
	return res;
}

cudaError_t cudaMemcpyArrayToArray(cudaArray_t  dst, size_t  wOffsetDst, size_t  hOffsetDst, cudaArray_const_t  src, size_t  wOffsetSrc, size_t  hOffsetSrc, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaMemcpyArrayToArray) (cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaMemcpyArrayToArray) {
		lcudaMemcpyArrayToArray = (cudaError_t (*) (cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaMemcpyArrayToArray");
		tracer._kernel_map[(void *) lcudaMemcpyArrayToArray] = std::string("cudaMemcpyArrayToArray");
	}
	assert(lcudaMemcpyArrayToArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyArrayToArray(dst, wOffsetDst, hOffsetDst, src, wOffsetSrc, hOffsetSrc, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyArrayToArray);
	}
	return res;
}

cudaError_t cudaMemcpyToArrayAsync(cudaArray_t  dst, size_t  wOffset, size_t  hOffset, const void * src, size_t  count, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyToArrayAsync) (cudaArray_t , size_t , size_t , const void *, size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpyToArrayAsync) {
		lcudaMemcpyToArrayAsync = (cudaError_t (*) (cudaArray_t , size_t , size_t , const void *, size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyToArrayAsync");
		tracer._kernel_map[(void *) lcudaMemcpyToArrayAsync] = std::string("cudaMemcpyToArrayAsync");
	}
	assert(lcudaMemcpyToArrayAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyToArrayAsync(dst, wOffset, hOffset, src, count, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyToArrayAsync);
	}
	return res;
}

cudaError_t cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t  src, size_t  wOffset, size_t  hOffset, size_t  count, enum cudaMemcpyKind  kind, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMemcpyFromArrayAsync) (void *, cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t );
	if (!lcudaMemcpyFromArrayAsync) {
		lcudaMemcpyFromArrayAsync = (cudaError_t (*) (void *, cudaArray_const_t , size_t , size_t , size_t , enum cudaMemcpyKind , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMemcpyFromArrayAsync");
		tracer._kernel_map[(void *) lcudaMemcpyFromArrayAsync] = std::string("cudaMemcpyFromArrayAsync");
	}
	assert(lcudaMemcpyFromArrayAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemcpyFromArrayAsync(dst, src, wOffset, hOffset, count, kind, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemcpyFromArrayAsync);
	}
	return res;
}

cudaError_t cudaMallocAsync(void ** devPtr, size_t  size, cudaStream_t  hStream)
{
	static cudaError_t (*lcudaMallocAsync) (void **, size_t , cudaStream_t );
	if (!lcudaMallocAsync) {
		lcudaMallocAsync = (cudaError_t (*) (void **, size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMallocAsync");
		tracer._kernel_map[(void *) lcudaMallocAsync] = std::string("cudaMallocAsync");
	}
	assert(lcudaMallocAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocAsync(devPtr, size, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocAsync);
	}
	return res;
}

cudaError_t cudaFreeAsync(void * devPtr, cudaStream_t  hStream)
{
	static cudaError_t (*lcudaFreeAsync) (void *, cudaStream_t );
	if (!lcudaFreeAsync) {
		lcudaFreeAsync = (cudaError_t (*) (void *, cudaStream_t )) dlsym(RTLD_NEXT, "cudaFreeAsync");
		tracer._kernel_map[(void *) lcudaFreeAsync] = std::string("cudaFreeAsync");
	}
	assert(lcudaFreeAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaFreeAsync(devPtr, hStream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaFreeAsync);
	}
	return res;
}

cudaError_t cudaMemPoolTrimTo(cudaMemPool_t  memPool, size_t  minBytesToKeep)
{
	static cudaError_t (*lcudaMemPoolTrimTo) (cudaMemPool_t , size_t );
	if (!lcudaMemPoolTrimTo) {
		lcudaMemPoolTrimTo = (cudaError_t (*) (cudaMemPool_t , size_t )) dlsym(RTLD_NEXT, "cudaMemPoolTrimTo");
		tracer._kernel_map[(void *) lcudaMemPoolTrimTo] = std::string("cudaMemPoolTrimTo");
	}
	assert(lcudaMemPoolTrimTo);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolTrimTo(memPool, minBytesToKeep);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolTrimTo);
	}
	return res;
}

cudaError_t cudaMemPoolSetAttribute(cudaMemPool_t  memPool, enum cudaMemPoolAttr  attr, void * value)
{
	static cudaError_t (*lcudaMemPoolSetAttribute) (cudaMemPool_t , enum cudaMemPoolAttr , void *);
	if (!lcudaMemPoolSetAttribute) {
		lcudaMemPoolSetAttribute = (cudaError_t (*) (cudaMemPool_t , enum cudaMemPoolAttr , void *)) dlsym(RTLD_NEXT, "cudaMemPoolSetAttribute");
		tracer._kernel_map[(void *) lcudaMemPoolSetAttribute] = std::string("cudaMemPoolSetAttribute");
	}
	assert(lcudaMemPoolSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolSetAttribute(memPool, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolSetAttribute);
	}
	return res;
}

cudaError_t cudaMemPoolGetAttribute(cudaMemPool_t  memPool, enum cudaMemPoolAttr  attr, void * value)
{
	static cudaError_t (*lcudaMemPoolGetAttribute) (cudaMemPool_t , enum cudaMemPoolAttr , void *);
	if (!lcudaMemPoolGetAttribute) {
		lcudaMemPoolGetAttribute = (cudaError_t (*) (cudaMemPool_t , enum cudaMemPoolAttr , void *)) dlsym(RTLD_NEXT, "cudaMemPoolGetAttribute");
		tracer._kernel_map[(void *) lcudaMemPoolGetAttribute] = std::string("cudaMemPoolGetAttribute");
	}
	assert(lcudaMemPoolGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolGetAttribute(memPool, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolGetAttribute);
	}
	return res;
}

cudaError_t cudaMemPoolSetAccess(cudaMemPool_t  memPool, const struct cudaMemAccessDesc * descList, size_t  count)
{
	static cudaError_t (*lcudaMemPoolSetAccess) (cudaMemPool_t , const struct cudaMemAccessDesc *, size_t );
	if (!lcudaMemPoolSetAccess) {
		lcudaMemPoolSetAccess = (cudaError_t (*) (cudaMemPool_t , const struct cudaMemAccessDesc *, size_t )) dlsym(RTLD_NEXT, "cudaMemPoolSetAccess");
		tracer._kernel_map[(void *) lcudaMemPoolSetAccess] = std::string("cudaMemPoolSetAccess");
	}
	assert(lcudaMemPoolSetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolSetAccess(memPool, descList, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolSetAccess);
	}
	return res;
}

cudaError_t cudaMemPoolGetAccess(enum cudaMemAccessFlags * flags, cudaMemPool_t  memPool, struct cudaMemLocation * location)
{
	static cudaError_t (*lcudaMemPoolGetAccess) (enum cudaMemAccessFlags *, cudaMemPool_t , struct cudaMemLocation *);
	if (!lcudaMemPoolGetAccess) {
		lcudaMemPoolGetAccess = (cudaError_t (*) (enum cudaMemAccessFlags *, cudaMemPool_t , struct cudaMemLocation *)) dlsym(RTLD_NEXT, "cudaMemPoolGetAccess");
		tracer._kernel_map[(void *) lcudaMemPoolGetAccess] = std::string("cudaMemPoolGetAccess");
	}
	assert(lcudaMemPoolGetAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolGetAccess(flags, memPool, location);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolGetAccess);
	}
	return res;
}

cudaError_t cudaMemPoolCreate(cudaMemPool_t * memPool, const struct cudaMemPoolProps * poolProps)
{
	static cudaError_t (*lcudaMemPoolCreate) (cudaMemPool_t *, const struct cudaMemPoolProps *);
	if (!lcudaMemPoolCreate) {
		lcudaMemPoolCreate = (cudaError_t (*) (cudaMemPool_t *, const struct cudaMemPoolProps *)) dlsym(RTLD_NEXT, "cudaMemPoolCreate");
		tracer._kernel_map[(void *) lcudaMemPoolCreate] = std::string("cudaMemPoolCreate");
	}
	assert(lcudaMemPoolCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolCreate(memPool, poolProps);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolCreate);
	}
	return res;
}

cudaError_t cudaMemPoolDestroy(cudaMemPool_t  memPool)
{
	static cudaError_t (*lcudaMemPoolDestroy) (cudaMemPool_t );
	if (!lcudaMemPoolDestroy) {
		lcudaMemPoolDestroy = (cudaError_t (*) (cudaMemPool_t )) dlsym(RTLD_NEXT, "cudaMemPoolDestroy");
		tracer._kernel_map[(void *) lcudaMemPoolDestroy] = std::string("cudaMemPoolDestroy");
	}
	assert(lcudaMemPoolDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolDestroy(memPool);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolDestroy);
	}
	return res;
}

cudaError_t cudaMallocFromPoolAsync(void ** ptr, size_t  size, cudaMemPool_t  memPool, cudaStream_t  stream)
{
	static cudaError_t (*lcudaMallocFromPoolAsync) (void **, size_t , cudaMemPool_t , cudaStream_t );
	if (!lcudaMallocFromPoolAsync) {
		lcudaMallocFromPoolAsync = (cudaError_t (*) (void **, size_t , cudaMemPool_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaMallocFromPoolAsync");
		tracer._kernel_map[(void *) lcudaMallocFromPoolAsync] = std::string("cudaMallocFromPoolAsync");
	}
	assert(lcudaMallocFromPoolAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMallocFromPoolAsync(ptr, size, memPool, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMallocFromPoolAsync);
	}
	return res;
}

cudaError_t cudaMemPoolExportToShareableHandle(void * shareableHandle, cudaMemPool_t  memPool, enum cudaMemAllocationHandleType  handleType, unsigned int  flags)
{
	static cudaError_t (*lcudaMemPoolExportToShareableHandle) (void *, cudaMemPool_t , enum cudaMemAllocationHandleType , unsigned int );
	if (!lcudaMemPoolExportToShareableHandle) {
		lcudaMemPoolExportToShareableHandle = (cudaError_t (*) (void *, cudaMemPool_t , enum cudaMemAllocationHandleType , unsigned int )) dlsym(RTLD_NEXT, "cudaMemPoolExportToShareableHandle");
		tracer._kernel_map[(void *) lcudaMemPoolExportToShareableHandle] = std::string("cudaMemPoolExportToShareableHandle");
	}
	assert(lcudaMemPoolExportToShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolExportToShareableHandle(shareableHandle, memPool, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolExportToShareableHandle);
	}
	return res;
}

cudaError_t cudaMemPoolImportFromShareableHandle(cudaMemPool_t * memPool, void * shareableHandle, enum cudaMemAllocationHandleType  handleType, unsigned int  flags)
{
	static cudaError_t (*lcudaMemPoolImportFromShareableHandle) (cudaMemPool_t *, void *, enum cudaMemAllocationHandleType , unsigned int );
	if (!lcudaMemPoolImportFromShareableHandle) {
		lcudaMemPoolImportFromShareableHandle = (cudaError_t (*) (cudaMemPool_t *, void *, enum cudaMemAllocationHandleType , unsigned int )) dlsym(RTLD_NEXT, "cudaMemPoolImportFromShareableHandle");
		tracer._kernel_map[(void *) lcudaMemPoolImportFromShareableHandle] = std::string("cudaMemPoolImportFromShareableHandle");
	}
	assert(lcudaMemPoolImportFromShareableHandle);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolImportFromShareableHandle(memPool, shareableHandle, handleType, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolImportFromShareableHandle);
	}
	return res;
}

cudaError_t cudaMemPoolExportPointer(struct cudaMemPoolPtrExportData * exportData, void * ptr)
{
	static cudaError_t (*lcudaMemPoolExportPointer) (struct cudaMemPoolPtrExportData *, void *);
	if (!lcudaMemPoolExportPointer) {
		lcudaMemPoolExportPointer = (cudaError_t (*) (struct cudaMemPoolPtrExportData *, void *)) dlsym(RTLD_NEXT, "cudaMemPoolExportPointer");
		tracer._kernel_map[(void *) lcudaMemPoolExportPointer] = std::string("cudaMemPoolExportPointer");
	}
	assert(lcudaMemPoolExportPointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolExportPointer(exportData, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolExportPointer);
	}
	return res;
}

cudaError_t cudaMemPoolImportPointer(void ** ptr, cudaMemPool_t  memPool, struct cudaMemPoolPtrExportData * exportData)
{
	static cudaError_t (*lcudaMemPoolImportPointer) (void **, cudaMemPool_t , struct cudaMemPoolPtrExportData *);
	if (!lcudaMemPoolImportPointer) {
		lcudaMemPoolImportPointer = (cudaError_t (*) (void **, cudaMemPool_t , struct cudaMemPoolPtrExportData *)) dlsym(RTLD_NEXT, "cudaMemPoolImportPointer");
		tracer._kernel_map[(void *) lcudaMemPoolImportPointer] = std::string("cudaMemPoolImportPointer");
	}
	assert(lcudaMemPoolImportPointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaMemPoolImportPointer(ptr, memPool, exportData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaMemPoolImportPointer);
	}
	return res;
}

cudaError_t cudaPointerGetAttributes(struct cudaPointerAttributes * attributes, const void * ptr)
{
	static cudaError_t (*lcudaPointerGetAttributes) (struct cudaPointerAttributes *, const void *);
	if (!lcudaPointerGetAttributes) {
		lcudaPointerGetAttributes = (cudaError_t (*) (struct cudaPointerAttributes *, const void *)) dlsym(RTLD_NEXT, "cudaPointerGetAttributes");
		tracer._kernel_map[(void *) lcudaPointerGetAttributes] = std::string("cudaPointerGetAttributes");
	}
	assert(lcudaPointerGetAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaPointerGetAttributes(attributes, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaPointerGetAttributes);
	}
	return res;
}

cudaError_t cudaDeviceCanAccessPeer(int * canAccessPeer, int  device, int  peerDevice)
{
	static cudaError_t (*lcudaDeviceCanAccessPeer) (int *, int , int );
	if (!lcudaDeviceCanAccessPeer) {
		lcudaDeviceCanAccessPeer = (cudaError_t (*) (int *, int , int )) dlsym(RTLD_NEXT, "cudaDeviceCanAccessPeer");
		tracer._kernel_map[(void *) lcudaDeviceCanAccessPeer] = std::string("cudaDeviceCanAccessPeer");
	}
	assert(lcudaDeviceCanAccessPeer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceCanAccessPeer(canAccessPeer, device, peerDevice);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceCanAccessPeer);
	}
	return res;
}

cudaError_t cudaDeviceEnablePeerAccess(int  peerDevice, unsigned int  flags)
{
	static cudaError_t (*lcudaDeviceEnablePeerAccess) (int , unsigned int );
	if (!lcudaDeviceEnablePeerAccess) {
		lcudaDeviceEnablePeerAccess = (cudaError_t (*) (int , unsigned int )) dlsym(RTLD_NEXT, "cudaDeviceEnablePeerAccess");
		tracer._kernel_map[(void *) lcudaDeviceEnablePeerAccess] = std::string("cudaDeviceEnablePeerAccess");
	}
	assert(lcudaDeviceEnablePeerAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceEnablePeerAccess(peerDevice, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceEnablePeerAccess);
	}
	return res;
}

cudaError_t cudaDeviceDisablePeerAccess(int  peerDevice)
{
	static cudaError_t (*lcudaDeviceDisablePeerAccess) (int );
	if (!lcudaDeviceDisablePeerAccess) {
		lcudaDeviceDisablePeerAccess = (cudaError_t (*) (int )) dlsym(RTLD_NEXT, "cudaDeviceDisablePeerAccess");
		tracer._kernel_map[(void *) lcudaDeviceDisablePeerAccess] = std::string("cudaDeviceDisablePeerAccess");
	}
	assert(lcudaDeviceDisablePeerAccess);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceDisablePeerAccess(peerDevice);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceDisablePeerAccess);
	}
	return res;
}

cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t  resource)
{
	static cudaError_t (*lcudaGraphicsUnregisterResource) (cudaGraphicsResource_t );
	if (!lcudaGraphicsUnregisterResource) {
		lcudaGraphicsUnregisterResource = (cudaError_t (*) (cudaGraphicsResource_t )) dlsym(RTLD_NEXT, "cudaGraphicsUnregisterResource");
		tracer._kernel_map[(void *) lcudaGraphicsUnregisterResource] = std::string("cudaGraphicsUnregisterResource");
	}
	assert(lcudaGraphicsUnregisterResource);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsUnregisterResource(resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsUnregisterResource);
	}
	return res;
}

cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t  resource, unsigned int  flags)
{
	static cudaError_t (*lcudaGraphicsResourceSetMapFlags) (cudaGraphicsResource_t , unsigned int );
	if (!lcudaGraphicsResourceSetMapFlags) {
		lcudaGraphicsResourceSetMapFlags = (cudaError_t (*) (cudaGraphicsResource_t , unsigned int )) dlsym(RTLD_NEXT, "cudaGraphicsResourceSetMapFlags");
		tracer._kernel_map[(void *) lcudaGraphicsResourceSetMapFlags] = std::string("cudaGraphicsResourceSetMapFlags");
	}
	assert(lcudaGraphicsResourceSetMapFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsResourceSetMapFlags(resource, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsResourceSetMapFlags);
	}
	return res;
}

cudaError_t cudaGraphicsMapResources(int  count, cudaGraphicsResource_t * resources, cudaStream_t  stream)
{
	static cudaError_t (*lcudaGraphicsMapResources) (int , cudaGraphicsResource_t *, cudaStream_t );
	if (!lcudaGraphicsMapResources) {
		lcudaGraphicsMapResources = (cudaError_t (*) (int , cudaGraphicsResource_t *, cudaStream_t )) dlsym(RTLD_NEXT, "cudaGraphicsMapResources");
		tracer._kernel_map[(void *) lcudaGraphicsMapResources] = std::string("cudaGraphicsMapResources");
	}
	assert(lcudaGraphicsMapResources);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsMapResources(count, resources, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsMapResources);
	}
	return res;
}

cudaError_t cudaGraphicsUnmapResources(int  count, cudaGraphicsResource_t * resources, cudaStream_t  stream)
{
	static cudaError_t (*lcudaGraphicsUnmapResources) (int , cudaGraphicsResource_t *, cudaStream_t );
	if (!lcudaGraphicsUnmapResources) {
		lcudaGraphicsUnmapResources = (cudaError_t (*) (int , cudaGraphicsResource_t *, cudaStream_t )) dlsym(RTLD_NEXT, "cudaGraphicsUnmapResources");
		tracer._kernel_map[(void *) lcudaGraphicsUnmapResources] = std::string("cudaGraphicsUnmapResources");
	}
	assert(lcudaGraphicsUnmapResources);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsUnmapResources(count, resources, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsUnmapResources);
	}
	return res;
}

cudaError_t cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t  resource)
{
	static cudaError_t (*lcudaGraphicsResourceGetMappedPointer) (void **, size_t *, cudaGraphicsResource_t );
	if (!lcudaGraphicsResourceGetMappedPointer) {
		lcudaGraphicsResourceGetMappedPointer = (cudaError_t (*) (void **, size_t *, cudaGraphicsResource_t )) dlsym(RTLD_NEXT, "cudaGraphicsResourceGetMappedPointer");
		tracer._kernel_map[(void *) lcudaGraphicsResourceGetMappedPointer] = std::string("cudaGraphicsResourceGetMappedPointer");
	}
	assert(lcudaGraphicsResourceGetMappedPointer);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsResourceGetMappedPointer(devPtr, size, resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsResourceGetMappedPointer);
	}
	return res;
}

cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t  resource, unsigned int  arrayIndex, unsigned int  mipLevel)
{
	static cudaError_t (*lcudaGraphicsSubResourceGetMappedArray) (cudaArray_t *, cudaGraphicsResource_t , unsigned int , unsigned int );
	if (!lcudaGraphicsSubResourceGetMappedArray) {
		lcudaGraphicsSubResourceGetMappedArray = (cudaError_t (*) (cudaArray_t *, cudaGraphicsResource_t , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaGraphicsSubResourceGetMappedArray");
		tracer._kernel_map[(void *) lcudaGraphicsSubResourceGetMappedArray] = std::string("cudaGraphicsSubResourceGetMappedArray");
	}
	assert(lcudaGraphicsSubResourceGetMappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsSubResourceGetMappedArray(array, resource, arrayIndex, mipLevel);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsSubResourceGetMappedArray);
	}
	return res;
}

cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t  resource)
{
	static cudaError_t (*lcudaGraphicsResourceGetMappedMipmappedArray) (cudaMipmappedArray_t *, cudaGraphicsResource_t );
	if (!lcudaGraphicsResourceGetMappedMipmappedArray) {
		lcudaGraphicsResourceGetMappedMipmappedArray = (cudaError_t (*) (cudaMipmappedArray_t *, cudaGraphicsResource_t )) dlsym(RTLD_NEXT, "cudaGraphicsResourceGetMappedMipmappedArray");
		tracer._kernel_map[(void *) lcudaGraphicsResourceGetMappedMipmappedArray] = std::string("cudaGraphicsResourceGetMappedMipmappedArray");
	}
	assert(lcudaGraphicsResourceGetMappedMipmappedArray);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphicsResourceGetMappedMipmappedArray(mipmappedArray, resource);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphicsResourceGetMappedMipmappedArray);
	}
	return res;
}

cudaError_t cudaGetChannelDesc(struct cudaChannelFormatDesc * desc, cudaArray_const_t  array)
{
	static cudaError_t (*lcudaGetChannelDesc) (struct cudaChannelFormatDesc *, cudaArray_const_t );
	if (!lcudaGetChannelDesc) {
		lcudaGetChannelDesc = (cudaError_t (*) (struct cudaChannelFormatDesc *, cudaArray_const_t )) dlsym(RTLD_NEXT, "cudaGetChannelDesc");
		tracer._kernel_map[(void *) lcudaGetChannelDesc] = std::string("cudaGetChannelDesc");
	}
	assert(lcudaGetChannelDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetChannelDesc(desc, array);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetChannelDesc);
	}
	return res;
}

struct cudaChannelFormatDesc cudaCreateChannelDesc(int  x, int  y, int  z, int  w, enum cudaChannelFormatKind  f)
{
	static struct cudaChannelFormatDesc (*lcudaCreateChannelDesc) (int , int , int , int , enum cudaChannelFormatKind );
	if (!lcudaCreateChannelDesc) {
		lcudaCreateChannelDesc = (struct cudaChannelFormatDesc (*) (int , int , int , int , enum cudaChannelFormatKind )) dlsym(RTLD_NEXT, "cudaCreateChannelDesc");
		tracer._kernel_map[(void *) lcudaCreateChannelDesc] = std::string("cudaCreateChannelDesc");
	}
	assert(lcudaCreateChannelDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	struct cudaChannelFormatDesc res = 
		lcudaCreateChannelDesc(x, y, z, w, f);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaCreateChannelDesc);
	}
	return res;
}

cudaError_t cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const struct cudaResourceDesc * pResDesc, const struct cudaTextureDesc * pTexDesc, const struct cudaResourceViewDesc * pResViewDesc)
{
	static cudaError_t (*lcudaCreateTextureObject) (cudaTextureObject_t *, const struct cudaResourceDesc *, const struct cudaTextureDesc *, const struct cudaResourceViewDesc *);
	if (!lcudaCreateTextureObject) {
		lcudaCreateTextureObject = (cudaError_t (*) (cudaTextureObject_t *, const struct cudaResourceDesc *, const struct cudaTextureDesc *, const struct cudaResourceViewDesc *)) dlsym(RTLD_NEXT, "cudaCreateTextureObject");
		tracer._kernel_map[(void *) lcudaCreateTextureObject] = std::string("cudaCreateTextureObject");
	}
	assert(lcudaCreateTextureObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaCreateTextureObject(pTexObject, pResDesc, pTexDesc, pResViewDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaCreateTextureObject);
	}
	return res;
}

cudaError_t cudaDestroyTextureObject(cudaTextureObject_t  texObject)
{
	static cudaError_t (*lcudaDestroyTextureObject) (cudaTextureObject_t );
	if (!lcudaDestroyTextureObject) {
		lcudaDestroyTextureObject = (cudaError_t (*) (cudaTextureObject_t )) dlsym(RTLD_NEXT, "cudaDestroyTextureObject");
		tracer._kernel_map[(void *) lcudaDestroyTextureObject] = std::string("cudaDestroyTextureObject");
	}
	assert(lcudaDestroyTextureObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDestroyTextureObject(texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDestroyTextureObject);
	}
	return res;
}

cudaError_t cudaGetTextureObjectResourceDesc(struct cudaResourceDesc * pResDesc, cudaTextureObject_t  texObject)
{
	static cudaError_t (*lcudaGetTextureObjectResourceDesc) (struct cudaResourceDesc *, cudaTextureObject_t );
	if (!lcudaGetTextureObjectResourceDesc) {
		lcudaGetTextureObjectResourceDesc = (cudaError_t (*) (struct cudaResourceDesc *, cudaTextureObject_t )) dlsym(RTLD_NEXT, "cudaGetTextureObjectResourceDesc");
		tracer._kernel_map[(void *) lcudaGetTextureObjectResourceDesc] = std::string("cudaGetTextureObjectResourceDesc");
	}
	assert(lcudaGetTextureObjectResourceDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetTextureObjectResourceDesc(pResDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetTextureObjectResourceDesc);
	}
	return res;
}

cudaError_t cudaGetTextureObjectTextureDesc(struct cudaTextureDesc * pTexDesc, cudaTextureObject_t  texObject)
{
	static cudaError_t (*lcudaGetTextureObjectTextureDesc) (struct cudaTextureDesc *, cudaTextureObject_t );
	if (!lcudaGetTextureObjectTextureDesc) {
		lcudaGetTextureObjectTextureDesc = (cudaError_t (*) (struct cudaTextureDesc *, cudaTextureObject_t )) dlsym(RTLD_NEXT, "cudaGetTextureObjectTextureDesc");
		tracer._kernel_map[(void *) lcudaGetTextureObjectTextureDesc] = std::string("cudaGetTextureObjectTextureDesc");
	}
	assert(lcudaGetTextureObjectTextureDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetTextureObjectTextureDesc(pTexDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetTextureObjectTextureDesc);
	}
	return res;
}

cudaError_t cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t  texObject)
{
	static cudaError_t (*lcudaGetTextureObjectResourceViewDesc) (struct cudaResourceViewDesc *, cudaTextureObject_t );
	if (!lcudaGetTextureObjectResourceViewDesc) {
		lcudaGetTextureObjectResourceViewDesc = (cudaError_t (*) (struct cudaResourceViewDesc *, cudaTextureObject_t )) dlsym(RTLD_NEXT, "cudaGetTextureObjectResourceViewDesc");
		tracer._kernel_map[(void *) lcudaGetTextureObjectResourceViewDesc] = std::string("cudaGetTextureObjectResourceViewDesc");
	}
	assert(lcudaGetTextureObjectResourceViewDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetTextureObjectResourceViewDesc(pResViewDesc, texObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetTextureObjectResourceViewDesc);
	}
	return res;
}

cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const struct cudaResourceDesc * pResDesc)
{
	static cudaError_t (*lcudaCreateSurfaceObject) (cudaSurfaceObject_t *, const struct cudaResourceDesc *);
	if (!lcudaCreateSurfaceObject) {
		lcudaCreateSurfaceObject = (cudaError_t (*) (cudaSurfaceObject_t *, const struct cudaResourceDesc *)) dlsym(RTLD_NEXT, "cudaCreateSurfaceObject");
		tracer._kernel_map[(void *) lcudaCreateSurfaceObject] = std::string("cudaCreateSurfaceObject");
	}
	assert(lcudaCreateSurfaceObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaCreateSurfaceObject(pSurfObject, pResDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaCreateSurfaceObject);
	}
	return res;
}

cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t  surfObject)
{
	static cudaError_t (*lcudaDestroySurfaceObject) (cudaSurfaceObject_t );
	if (!lcudaDestroySurfaceObject) {
		lcudaDestroySurfaceObject = (cudaError_t (*) (cudaSurfaceObject_t )) dlsym(RTLD_NEXT, "cudaDestroySurfaceObject");
		tracer._kernel_map[(void *) lcudaDestroySurfaceObject] = std::string("cudaDestroySurfaceObject");
	}
	assert(lcudaDestroySurfaceObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDestroySurfaceObject(surfObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDestroySurfaceObject);
	}
	return res;
}

cudaError_t cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc * pResDesc, cudaSurfaceObject_t  surfObject)
{
	static cudaError_t (*lcudaGetSurfaceObjectResourceDesc) (struct cudaResourceDesc *, cudaSurfaceObject_t );
	if (!lcudaGetSurfaceObjectResourceDesc) {
		lcudaGetSurfaceObjectResourceDesc = (cudaError_t (*) (struct cudaResourceDesc *, cudaSurfaceObject_t )) dlsym(RTLD_NEXT, "cudaGetSurfaceObjectResourceDesc");
		tracer._kernel_map[(void *) lcudaGetSurfaceObjectResourceDesc] = std::string("cudaGetSurfaceObjectResourceDesc");
	}
	assert(lcudaGetSurfaceObjectResourceDesc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetSurfaceObjectResourceDesc(pResDesc, surfObject);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetSurfaceObjectResourceDesc);
	}
	return res;
}

cudaError_t cudaDriverGetVersion(int * driverVersion)
{
	static cudaError_t (*lcudaDriverGetVersion) (int *);
	if (!lcudaDriverGetVersion) {
		lcudaDriverGetVersion = (cudaError_t (*) (int *)) dlsym(RTLD_NEXT, "cudaDriverGetVersion");
		tracer._kernel_map[(void *) lcudaDriverGetVersion] = std::string("cudaDriverGetVersion");
	}
	assert(lcudaDriverGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDriverGetVersion(driverVersion);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDriverGetVersion);
	}
	return res;
}

cudaError_t cudaRuntimeGetVersion(int * runtimeVersion)
{
	static cudaError_t (*lcudaRuntimeGetVersion) (int *);
	if (!lcudaRuntimeGetVersion) {
		lcudaRuntimeGetVersion = (cudaError_t (*) (int *)) dlsym(RTLD_NEXT, "cudaRuntimeGetVersion");
		tracer._kernel_map[(void *) lcudaRuntimeGetVersion] = std::string("cudaRuntimeGetVersion");
	}
	assert(lcudaRuntimeGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaRuntimeGetVersion(runtimeVersion);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaRuntimeGetVersion);
	}
	return res;
}

cudaError_t cudaGraphCreate(cudaGraph_t * pGraph, unsigned int  flags)
{
	static cudaError_t (*lcudaGraphCreate) (cudaGraph_t *, unsigned int );
	if (!lcudaGraphCreate) {
		lcudaGraphCreate = (cudaError_t (*) (cudaGraph_t *, unsigned int )) dlsym(RTLD_NEXT, "cudaGraphCreate");
		tracer._kernel_map[(void *) lcudaGraphCreate] = std::string("cudaGraphCreate");
	}
	assert(lcudaGraphCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphCreate(pGraph, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphCreate);
	}
	return res;
}

cudaError_t cudaGraphAddKernelNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaKernelNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphAddKernelNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaKernelNodeParams *);
	if (!lcudaGraphAddKernelNode) {
		lcudaGraphAddKernelNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaKernelNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddKernelNode");
		tracer._kernel_map[(void *) lcudaGraphAddKernelNode] = std::string("cudaGraphAddKernelNode");
	}
	assert(lcudaGraphAddKernelNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddKernelNode(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddKernelNode);
	}
	return res;
}

cudaError_t cudaGraphKernelNodeGetParams(cudaGraphNode_t  node, struct cudaKernelNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphKernelNodeGetParams) (cudaGraphNode_t , struct cudaKernelNodeParams *);
	if (!lcudaGraphKernelNodeGetParams) {
		lcudaGraphKernelNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaKernelNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphKernelNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphKernelNodeGetParams] = std::string("cudaGraphKernelNodeGetParams");
	}
	assert(lcudaGraphKernelNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphKernelNodeGetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphKernelNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphKernelNodeSetParams(cudaGraphNode_t  node, const struct cudaKernelNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphKernelNodeSetParams) (cudaGraphNode_t , const struct cudaKernelNodeParams *);
	if (!lcudaGraphKernelNodeSetParams) {
		lcudaGraphKernelNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaKernelNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphKernelNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphKernelNodeSetParams] = std::string("cudaGraphKernelNodeSetParams");
	}
	assert(lcudaGraphKernelNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphKernelNodeSetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphKernelNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphKernelNodeCopyAttributes(cudaGraphNode_t  hSrc, cudaGraphNode_t  hDst)
{
	static cudaError_t (*lcudaGraphKernelNodeCopyAttributes) (cudaGraphNode_t , cudaGraphNode_t );
	if (!lcudaGraphKernelNodeCopyAttributes) {
		lcudaGraphKernelNodeCopyAttributes = (cudaError_t (*) (cudaGraphNode_t , cudaGraphNode_t )) dlsym(RTLD_NEXT, "cudaGraphKernelNodeCopyAttributes");
		tracer._kernel_map[(void *) lcudaGraphKernelNodeCopyAttributes] = std::string("cudaGraphKernelNodeCopyAttributes");
	}
	assert(lcudaGraphKernelNodeCopyAttributes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphKernelNodeCopyAttributes(hSrc, hDst);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphKernelNodeCopyAttributes);
	}
	return res;
}

cudaError_t cudaGraphKernelNodeGetAttribute(cudaGraphNode_t  hNode, cudaLaunchAttributeID  attr, cudaLaunchAttributeValue * value_out)
{
	static cudaError_t (*lcudaGraphKernelNodeGetAttribute) (cudaGraphNode_t , cudaLaunchAttributeID , cudaLaunchAttributeValue *);
	if (!lcudaGraphKernelNodeGetAttribute) {
		lcudaGraphKernelNodeGetAttribute = (cudaError_t (*) (cudaGraphNode_t , cudaLaunchAttributeID , cudaLaunchAttributeValue *)) dlsym(RTLD_NEXT, "cudaGraphKernelNodeGetAttribute");
		tracer._kernel_map[(void *) lcudaGraphKernelNodeGetAttribute] = std::string("cudaGraphKernelNodeGetAttribute");
	}
	assert(lcudaGraphKernelNodeGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphKernelNodeGetAttribute(hNode, attr, value_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphKernelNodeGetAttribute);
	}
	return res;
}

cudaError_t cudaGraphKernelNodeSetAttribute(cudaGraphNode_t  hNode, cudaLaunchAttributeID  attr, const cudaLaunchAttributeValue * value)
{
	static cudaError_t (*lcudaGraphKernelNodeSetAttribute) (cudaGraphNode_t , cudaLaunchAttributeID , const cudaLaunchAttributeValue *);
	if (!lcudaGraphKernelNodeSetAttribute) {
		lcudaGraphKernelNodeSetAttribute = (cudaError_t (*) (cudaGraphNode_t , cudaLaunchAttributeID , const cudaLaunchAttributeValue *)) dlsym(RTLD_NEXT, "cudaGraphKernelNodeSetAttribute");
		tracer._kernel_map[(void *) lcudaGraphKernelNodeSetAttribute] = std::string("cudaGraphKernelNodeSetAttribute");
	}
	assert(lcudaGraphKernelNodeSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphKernelNodeSetAttribute(hNode, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphKernelNodeSetAttribute);
	}
	return res;
}

cudaError_t cudaGraphAddMemcpyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaMemcpy3DParms * pCopyParams)
{
	static cudaError_t (*lcudaGraphAddMemcpyNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaMemcpy3DParms *);
	if (!lcudaGraphAddMemcpyNode) {
		lcudaGraphAddMemcpyNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaMemcpy3DParms *)) dlsym(RTLD_NEXT, "cudaGraphAddMemcpyNode");
		tracer._kernel_map[(void *) lcudaGraphAddMemcpyNode] = std::string("cudaGraphAddMemcpyNode");
	}
	assert(lcudaGraphAddMemcpyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemcpyNode(pGraphNode, graph, pDependencies, numDependencies, pCopyParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemcpyNode);
	}
	return res;
}

cudaError_t cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const void*  symbol, const void*  src, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphAddMemcpyNodeToSymbol) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphAddMemcpyNodeToSymbol) {
		lcudaGraphAddMemcpyNodeToSymbol = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphAddMemcpyNodeToSymbol");
		tracer._kernel_map[(void *) lcudaGraphAddMemcpyNodeToSymbol] = std::string("cudaGraphAddMemcpyNodeToSymbol");
	}
	assert(lcudaGraphAddMemcpyNodeToSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, symbol, src, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemcpyNodeToSymbol);
	}
	return res;
}

cudaError_t cudaGraphAddMemcpyNodeFromSymbol(cudaGraphNode_t*  pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t*  pDependencies, size_t  numDependencies, void*  dst, const void*  symbol, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphAddMemcpyNodeFromSymbol) (cudaGraphNode_t* , cudaGraph_t , const cudaGraphNode_t* , size_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphAddMemcpyNodeFromSymbol) {
		lcudaGraphAddMemcpyNodeFromSymbol = (cudaError_t (*) (cudaGraphNode_t* , cudaGraph_t , const cudaGraphNode_t* , size_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphAddMemcpyNodeFromSymbol");
		tracer._kernel_map[(void *) lcudaGraphAddMemcpyNodeFromSymbol] = std::string("cudaGraphAddMemcpyNodeFromSymbol");
	}
	assert(lcudaGraphAddMemcpyNodeFromSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, symbol, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemcpyNodeFromSymbol);
	}
	return res;
}

cudaError_t cudaGraphAddMemcpyNode1D(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, void*  dst, const void*  src, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphAddMemcpyNode1D) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , void* , const void* , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphAddMemcpyNode1D) {
		lcudaGraphAddMemcpyNode1D = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , void* , const void* , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphAddMemcpyNode1D");
		tracer._kernel_map[(void *) lcudaGraphAddMemcpyNode1D] = std::string("cudaGraphAddMemcpyNode1D");
	}
	assert(lcudaGraphAddMemcpyNode1D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemcpyNode1D(pGraphNode, graph, pDependencies, numDependencies, dst, src, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemcpyNode1D);
	}
	return res;
}

cudaError_t cudaGraphMemcpyNodeGetParams(cudaGraphNode_t  node, struct cudaMemcpy3DParms * pNodeParams)
{
	static cudaError_t (*lcudaGraphMemcpyNodeGetParams) (cudaGraphNode_t , struct cudaMemcpy3DParms *);
	if (!lcudaGraphMemcpyNodeGetParams) {
		lcudaGraphMemcpyNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaMemcpy3DParms *)) dlsym(RTLD_NEXT, "cudaGraphMemcpyNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphMemcpyNodeGetParams] = std::string("cudaGraphMemcpyNodeGetParams");
	}
	assert(lcudaGraphMemcpyNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemcpyNodeGetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemcpyNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphMemcpyNodeSetParams(cudaGraphNode_t  node, const struct cudaMemcpy3DParms * pNodeParams)
{
	static cudaError_t (*lcudaGraphMemcpyNodeSetParams) (cudaGraphNode_t , const struct cudaMemcpy3DParms *);
	if (!lcudaGraphMemcpyNodeSetParams) {
		lcudaGraphMemcpyNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaMemcpy3DParms *)) dlsym(RTLD_NEXT, "cudaGraphMemcpyNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphMemcpyNodeSetParams] = std::string("cudaGraphMemcpyNodeSetParams");
	}
	assert(lcudaGraphMemcpyNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemcpyNodeSetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemcpyNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t  node, const void*  symbol, const void*  src, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphMemcpyNodeSetParamsToSymbol) (cudaGraphNode_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphMemcpyNodeSetParamsToSymbol) {
		lcudaGraphMemcpyNodeSetParamsToSymbol = (cudaError_t (*) (cudaGraphNode_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphMemcpyNodeSetParamsToSymbol");
		tracer._kernel_map[(void *) lcudaGraphMemcpyNodeSetParamsToSymbol] = std::string("cudaGraphMemcpyNodeSetParamsToSymbol");
	}
	assert(lcudaGraphMemcpyNodeSetParamsToSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemcpyNodeSetParamsToSymbol(node, symbol, src, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemcpyNodeSetParamsToSymbol);
	}
	return res;
}

cudaError_t cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t  node, void*  dst, const void*  symbol, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphMemcpyNodeSetParamsFromSymbol) (cudaGraphNode_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphMemcpyNodeSetParamsFromSymbol) {
		lcudaGraphMemcpyNodeSetParamsFromSymbol = (cudaError_t (*) (cudaGraphNode_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphMemcpyNodeSetParamsFromSymbol");
		tracer._kernel_map[(void *) lcudaGraphMemcpyNodeSetParamsFromSymbol] = std::string("cudaGraphMemcpyNodeSetParamsFromSymbol");
	}
	assert(lcudaGraphMemcpyNodeSetParamsFromSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, symbol, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemcpyNodeSetParamsFromSymbol);
	}
	return res;
}

cudaError_t cudaGraphMemcpyNodeSetParams1D(cudaGraphNode_t  node, void*  dst, const void*  src, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphMemcpyNodeSetParams1D) (cudaGraphNode_t , void* , const void* , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphMemcpyNodeSetParams1D) {
		lcudaGraphMemcpyNodeSetParams1D = (cudaError_t (*) (cudaGraphNode_t , void* , const void* , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphMemcpyNodeSetParams1D");
		tracer._kernel_map[(void *) lcudaGraphMemcpyNodeSetParams1D] = std::string("cudaGraphMemcpyNodeSetParams1D");
	}
	assert(lcudaGraphMemcpyNodeSetParams1D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemcpyNodeSetParams1D(node, dst, src, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemcpyNodeSetParams1D);
	}
	return res;
}

cudaError_t cudaGraphAddMemsetNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaMemsetParams * pMemsetParams)
{
	static cudaError_t (*lcudaGraphAddMemsetNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaMemsetParams *);
	if (!lcudaGraphAddMemsetNode) {
		lcudaGraphAddMemsetNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaMemsetParams *)) dlsym(RTLD_NEXT, "cudaGraphAddMemsetNode");
		tracer._kernel_map[(void *) lcudaGraphAddMemsetNode] = std::string("cudaGraphAddMemsetNode");
	}
	assert(lcudaGraphAddMemsetNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemsetNode(pGraphNode, graph, pDependencies, numDependencies, pMemsetParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemsetNode);
	}
	return res;
}

cudaError_t cudaGraphMemsetNodeGetParams(cudaGraphNode_t  node, struct cudaMemsetParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphMemsetNodeGetParams) (cudaGraphNode_t , struct cudaMemsetParams *);
	if (!lcudaGraphMemsetNodeGetParams) {
		lcudaGraphMemsetNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaMemsetParams *)) dlsym(RTLD_NEXT, "cudaGraphMemsetNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphMemsetNodeGetParams] = std::string("cudaGraphMemsetNodeGetParams");
	}
	assert(lcudaGraphMemsetNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemsetNodeGetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemsetNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphMemsetNodeSetParams(cudaGraphNode_t  node, const struct cudaMemsetParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphMemsetNodeSetParams) (cudaGraphNode_t , const struct cudaMemsetParams *);
	if (!lcudaGraphMemsetNodeSetParams) {
		lcudaGraphMemsetNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaMemsetParams *)) dlsym(RTLD_NEXT, "cudaGraphMemsetNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphMemsetNodeSetParams] = std::string("cudaGraphMemsetNodeSetParams");
	}
	assert(lcudaGraphMemsetNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemsetNodeSetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemsetNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphAddHostNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaHostNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphAddHostNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaHostNodeParams *);
	if (!lcudaGraphAddHostNode) {
		lcudaGraphAddHostNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaHostNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddHostNode");
		tracer._kernel_map[(void *) lcudaGraphAddHostNode] = std::string("cudaGraphAddHostNode");
	}
	assert(lcudaGraphAddHostNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddHostNode(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddHostNode);
	}
	return res;
}

cudaError_t cudaGraphHostNodeGetParams(cudaGraphNode_t  node, struct cudaHostNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphHostNodeGetParams) (cudaGraphNode_t , struct cudaHostNodeParams *);
	if (!lcudaGraphHostNodeGetParams) {
		lcudaGraphHostNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaHostNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphHostNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphHostNodeGetParams] = std::string("cudaGraphHostNodeGetParams");
	}
	assert(lcudaGraphHostNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphHostNodeGetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphHostNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphHostNodeSetParams(cudaGraphNode_t  node, const struct cudaHostNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphHostNodeSetParams) (cudaGraphNode_t , const struct cudaHostNodeParams *);
	if (!lcudaGraphHostNodeSetParams) {
		lcudaGraphHostNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaHostNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphHostNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphHostNodeSetParams] = std::string("cudaGraphHostNodeSetParams");
	}
	assert(lcudaGraphHostNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphHostNodeSetParams(node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphHostNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphAddChildGraphNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, cudaGraph_t  childGraph)
{
	static cudaError_t (*lcudaGraphAddChildGraphNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaGraph_t );
	if (!lcudaGraphAddChildGraphNode) {
		lcudaGraphAddChildGraphNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaGraph_t )) dlsym(RTLD_NEXT, "cudaGraphAddChildGraphNode");
		tracer._kernel_map[(void *) lcudaGraphAddChildGraphNode] = std::string("cudaGraphAddChildGraphNode");
	}
	assert(lcudaGraphAddChildGraphNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddChildGraphNode(pGraphNode, graph, pDependencies, numDependencies, childGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddChildGraphNode);
	}
	return res;
}

cudaError_t cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t  node, cudaGraph_t * pGraph)
{
	static cudaError_t (*lcudaGraphChildGraphNodeGetGraph) (cudaGraphNode_t , cudaGraph_t *);
	if (!lcudaGraphChildGraphNodeGetGraph) {
		lcudaGraphChildGraphNodeGetGraph = (cudaError_t (*) (cudaGraphNode_t , cudaGraph_t *)) dlsym(RTLD_NEXT, "cudaGraphChildGraphNodeGetGraph");
		tracer._kernel_map[(void *) lcudaGraphChildGraphNodeGetGraph] = std::string("cudaGraphChildGraphNodeGetGraph");
	}
	assert(lcudaGraphChildGraphNodeGetGraph);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphChildGraphNodeGetGraph(node, pGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphChildGraphNodeGetGraph);
	}
	return res;
}

cudaError_t cudaGraphAddEmptyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies)
{
	static cudaError_t (*lcudaGraphAddEmptyNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t );
	if (!lcudaGraphAddEmptyNode) {
		lcudaGraphAddEmptyNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t )) dlsym(RTLD_NEXT, "cudaGraphAddEmptyNode");
		tracer._kernel_map[(void *) lcudaGraphAddEmptyNode] = std::string("cudaGraphAddEmptyNode");
	}
	assert(lcudaGraphAddEmptyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddEmptyNode(pGraphNode, graph, pDependencies, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddEmptyNode);
	}
	return res;
}

cudaError_t cudaGraphAddEventRecordNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphAddEventRecordNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaEvent_t );
	if (!lcudaGraphAddEventRecordNode) {
		lcudaGraphAddEventRecordNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphAddEventRecordNode");
		tracer._kernel_map[(void *) lcudaGraphAddEventRecordNode] = std::string("cudaGraphAddEventRecordNode");
	}
	assert(lcudaGraphAddEventRecordNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddEventRecordNode(pGraphNode, graph, pDependencies, numDependencies, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddEventRecordNode);
	}
	return res;
}

cudaError_t cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t  node, cudaEvent_t * event_out)
{
	static cudaError_t (*lcudaGraphEventRecordNodeGetEvent) (cudaGraphNode_t , cudaEvent_t *);
	if (!lcudaGraphEventRecordNodeGetEvent) {
		lcudaGraphEventRecordNodeGetEvent = (cudaError_t (*) (cudaGraphNode_t , cudaEvent_t *)) dlsym(RTLD_NEXT, "cudaGraphEventRecordNodeGetEvent");
		tracer._kernel_map[(void *) lcudaGraphEventRecordNodeGetEvent] = std::string("cudaGraphEventRecordNodeGetEvent");
	}
	assert(lcudaGraphEventRecordNodeGetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphEventRecordNodeGetEvent(node, event_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphEventRecordNodeGetEvent);
	}
	return res;
}

cudaError_t cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t  node, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphEventRecordNodeSetEvent) (cudaGraphNode_t , cudaEvent_t );
	if (!lcudaGraphEventRecordNodeSetEvent) {
		lcudaGraphEventRecordNodeSetEvent = (cudaError_t (*) (cudaGraphNode_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphEventRecordNodeSetEvent");
		tracer._kernel_map[(void *) lcudaGraphEventRecordNodeSetEvent] = std::string("cudaGraphEventRecordNodeSetEvent");
	}
	assert(lcudaGraphEventRecordNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphEventRecordNodeSetEvent(node, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphEventRecordNodeSetEvent);
	}
	return res;
}

cudaError_t cudaGraphAddEventWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphAddEventWaitNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaEvent_t );
	if (!lcudaGraphAddEventWaitNode) {
		lcudaGraphAddEventWaitNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphAddEventWaitNode");
		tracer._kernel_map[(void *) lcudaGraphAddEventWaitNode] = std::string("cudaGraphAddEventWaitNode");
	}
	assert(lcudaGraphAddEventWaitNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddEventWaitNode(pGraphNode, graph, pDependencies, numDependencies, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddEventWaitNode);
	}
	return res;
}

cudaError_t cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t  node, cudaEvent_t * event_out)
{
	static cudaError_t (*lcudaGraphEventWaitNodeGetEvent) (cudaGraphNode_t , cudaEvent_t *);
	if (!lcudaGraphEventWaitNodeGetEvent) {
		lcudaGraphEventWaitNodeGetEvent = (cudaError_t (*) (cudaGraphNode_t , cudaEvent_t *)) dlsym(RTLD_NEXT, "cudaGraphEventWaitNodeGetEvent");
		tracer._kernel_map[(void *) lcudaGraphEventWaitNodeGetEvent] = std::string("cudaGraphEventWaitNodeGetEvent");
	}
	assert(lcudaGraphEventWaitNodeGetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphEventWaitNodeGetEvent(node, event_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphEventWaitNodeGetEvent);
	}
	return res;
}

cudaError_t cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t  node, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphEventWaitNodeSetEvent) (cudaGraphNode_t , cudaEvent_t );
	if (!lcudaGraphEventWaitNodeSetEvent) {
		lcudaGraphEventWaitNodeSetEvent = (cudaError_t (*) (cudaGraphNode_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphEventWaitNodeSetEvent");
		tracer._kernel_map[(void *) lcudaGraphEventWaitNodeSetEvent] = std::string("cudaGraphEventWaitNodeSetEvent");
	}
	assert(lcudaGraphEventWaitNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphEventWaitNodeSetEvent(node, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphEventWaitNodeSetEvent);
	}
	return res;
}

cudaError_t cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaExternalSemaphoreSignalNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphAddExternalSemaphoresSignalNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaExternalSemaphoreSignalNodeParams *);
	if (!lcudaGraphAddExternalSemaphoresSignalNode) {
		lcudaGraphAddExternalSemaphoresSignalNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaExternalSemaphoreSignalNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddExternalSemaphoresSignalNode");
		tracer._kernel_map[(void *) lcudaGraphAddExternalSemaphoresSignalNode] = std::string("cudaGraphAddExternalSemaphoresSignalNode");
	}
	assert(lcudaGraphAddExternalSemaphoresSignalNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddExternalSemaphoresSignalNode(pGraphNode, graph, pDependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddExternalSemaphoresSignalNode);
	}
	return res;
}

cudaError_t cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t  hNode, struct cudaExternalSemaphoreSignalNodeParams * params_out)
{
	static cudaError_t (*lcudaGraphExternalSemaphoresSignalNodeGetParams) (cudaGraphNode_t , struct cudaExternalSemaphoreSignalNodeParams *);
	if (!lcudaGraphExternalSemaphoresSignalNodeGetParams) {
		lcudaGraphExternalSemaphoresSignalNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaExternalSemaphoreSignalNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExternalSemaphoresSignalNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphExternalSemaphoresSignalNodeGetParams] = std::string("cudaGraphExternalSemaphoresSignalNodeGetParams");
	}
	assert(lcudaGraphExternalSemaphoresSignalNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExternalSemaphoresSignalNodeGetParams(hNode, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExternalSemaphoresSignalNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t  hNode, const struct cudaExternalSemaphoreSignalNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphExternalSemaphoresSignalNodeSetParams) (cudaGraphNode_t , const struct cudaExternalSemaphoreSignalNodeParams *);
	if (!lcudaGraphExternalSemaphoresSignalNodeSetParams) {
		lcudaGraphExternalSemaphoresSignalNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaExternalSemaphoreSignalNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExternalSemaphoresSignalNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExternalSemaphoresSignalNodeSetParams] = std::string("cudaGraphExternalSemaphoresSignalNodeSetParams");
	}
	assert(lcudaGraphExternalSemaphoresSignalNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExternalSemaphoresSignalNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, const struct cudaExternalSemaphoreWaitNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphAddExternalSemaphoresWaitNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaExternalSemaphoreWaitNodeParams *);
	if (!lcudaGraphAddExternalSemaphoresWaitNode) {
		lcudaGraphAddExternalSemaphoresWaitNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , const struct cudaExternalSemaphoreWaitNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddExternalSemaphoresWaitNode");
		tracer._kernel_map[(void *) lcudaGraphAddExternalSemaphoresWaitNode] = std::string("cudaGraphAddExternalSemaphoresWaitNode");
	}
	assert(lcudaGraphAddExternalSemaphoresWaitNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddExternalSemaphoresWaitNode(pGraphNode, graph, pDependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddExternalSemaphoresWaitNode);
	}
	return res;
}

cudaError_t cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t  hNode, struct cudaExternalSemaphoreWaitNodeParams * params_out)
{
	static cudaError_t (*lcudaGraphExternalSemaphoresWaitNodeGetParams) (cudaGraphNode_t , struct cudaExternalSemaphoreWaitNodeParams *);
	if (!lcudaGraphExternalSemaphoresWaitNodeGetParams) {
		lcudaGraphExternalSemaphoresWaitNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaExternalSemaphoreWaitNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExternalSemaphoresWaitNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphExternalSemaphoresWaitNodeGetParams] = std::string("cudaGraphExternalSemaphoresWaitNodeGetParams");
	}
	assert(lcudaGraphExternalSemaphoresWaitNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExternalSemaphoresWaitNodeGetParams(hNode, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExternalSemaphoresWaitNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t  hNode, const struct cudaExternalSemaphoreWaitNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphExternalSemaphoresWaitNodeSetParams) (cudaGraphNode_t , const struct cudaExternalSemaphoreWaitNodeParams *);
	if (!lcudaGraphExternalSemaphoresWaitNodeSetParams) {
		lcudaGraphExternalSemaphoresWaitNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , const struct cudaExternalSemaphoreWaitNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExternalSemaphoresWaitNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExternalSemaphoresWaitNodeSetParams] = std::string("cudaGraphExternalSemaphoresWaitNodeSetParams");
	}
	assert(lcudaGraphExternalSemaphoresWaitNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExternalSemaphoresWaitNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphAddMemAllocNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, struct cudaMemAllocNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphAddMemAllocNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , struct cudaMemAllocNodeParams *);
	if (!lcudaGraphAddMemAllocNode) {
		lcudaGraphAddMemAllocNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , struct cudaMemAllocNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddMemAllocNode");
		tracer._kernel_map[(void *) lcudaGraphAddMemAllocNode] = std::string("cudaGraphAddMemAllocNode");
	}
	assert(lcudaGraphAddMemAllocNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemAllocNode(pGraphNode, graph, pDependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemAllocNode);
	}
	return res;
}

cudaError_t cudaGraphMemAllocNodeGetParams(cudaGraphNode_t  node, struct cudaMemAllocNodeParams * params_out)
{
	static cudaError_t (*lcudaGraphMemAllocNodeGetParams) (cudaGraphNode_t , struct cudaMemAllocNodeParams *);
	if (!lcudaGraphMemAllocNodeGetParams) {
		lcudaGraphMemAllocNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaMemAllocNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphMemAllocNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphMemAllocNodeGetParams] = std::string("cudaGraphMemAllocNodeGetParams");
	}
	assert(lcudaGraphMemAllocNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemAllocNodeGetParams(node, params_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemAllocNodeGetParams);
	}
	return res;
}

cudaError_t cudaGraphAddMemFreeNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, void * dptr)
{
	static cudaError_t (*lcudaGraphAddMemFreeNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , void *);
	if (!lcudaGraphAddMemFreeNode) {
		lcudaGraphAddMemFreeNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , void *)) dlsym(RTLD_NEXT, "cudaGraphAddMemFreeNode");
		tracer._kernel_map[(void *) lcudaGraphAddMemFreeNode] = std::string("cudaGraphAddMemFreeNode");
	}
	assert(lcudaGraphAddMemFreeNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddMemFreeNode(pGraphNode, graph, pDependencies, numDependencies, dptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddMemFreeNode);
	}
	return res;
}

cudaError_t cudaGraphMemFreeNodeGetParams(cudaGraphNode_t  node, void * dptr_out)
{
	static cudaError_t (*lcudaGraphMemFreeNodeGetParams) (cudaGraphNode_t , void *);
	if (!lcudaGraphMemFreeNodeGetParams) {
		lcudaGraphMemFreeNodeGetParams = (cudaError_t (*) (cudaGraphNode_t , void *)) dlsym(RTLD_NEXT, "cudaGraphMemFreeNodeGetParams");
		tracer._kernel_map[(void *) lcudaGraphMemFreeNodeGetParams] = std::string("cudaGraphMemFreeNodeGetParams");
	}
	assert(lcudaGraphMemFreeNodeGetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphMemFreeNodeGetParams(node, dptr_out);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphMemFreeNodeGetParams);
	}
	return res;
}

cudaError_t cudaDeviceGraphMemTrim(int  device)
{
	static cudaError_t (*lcudaDeviceGraphMemTrim) (int );
	if (!lcudaDeviceGraphMemTrim) {
		lcudaDeviceGraphMemTrim = (cudaError_t (*) (int )) dlsym(RTLD_NEXT, "cudaDeviceGraphMemTrim");
		tracer._kernel_map[(void *) lcudaDeviceGraphMemTrim] = std::string("cudaDeviceGraphMemTrim");
	}
	assert(lcudaDeviceGraphMemTrim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGraphMemTrim(device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGraphMemTrim);
	}
	return res;
}

cudaError_t cudaDeviceGetGraphMemAttribute(int  device, enum cudaGraphMemAttributeType  attr, void*  value)
{
	static cudaError_t (*lcudaDeviceGetGraphMemAttribute) (int , enum cudaGraphMemAttributeType , void* );
	if (!lcudaDeviceGetGraphMemAttribute) {
		lcudaDeviceGetGraphMemAttribute = (cudaError_t (*) (int , enum cudaGraphMemAttributeType , void* )) dlsym(RTLD_NEXT, "cudaDeviceGetGraphMemAttribute");
		tracer._kernel_map[(void *) lcudaDeviceGetGraphMemAttribute] = std::string("cudaDeviceGetGraphMemAttribute");
	}
	assert(lcudaDeviceGetGraphMemAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceGetGraphMemAttribute(device, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceGetGraphMemAttribute);
	}
	return res;
}

cudaError_t cudaDeviceSetGraphMemAttribute(int  device, enum cudaGraphMemAttributeType  attr, void*  value)
{
	static cudaError_t (*lcudaDeviceSetGraphMemAttribute) (int , enum cudaGraphMemAttributeType , void* );
	if (!lcudaDeviceSetGraphMemAttribute) {
		lcudaDeviceSetGraphMemAttribute = (cudaError_t (*) (int , enum cudaGraphMemAttributeType , void* )) dlsym(RTLD_NEXT, "cudaDeviceSetGraphMemAttribute");
		tracer._kernel_map[(void *) lcudaDeviceSetGraphMemAttribute] = std::string("cudaDeviceSetGraphMemAttribute");
	}
	assert(lcudaDeviceSetGraphMemAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaDeviceSetGraphMemAttribute(device, attr, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaDeviceSetGraphMemAttribute);
	}
	return res;
}

cudaError_t cudaGraphClone(cudaGraph_t * pGraphClone, cudaGraph_t  originalGraph)
{
	static cudaError_t (*lcudaGraphClone) (cudaGraph_t *, cudaGraph_t );
	if (!lcudaGraphClone) {
		lcudaGraphClone = (cudaError_t (*) (cudaGraph_t *, cudaGraph_t )) dlsym(RTLD_NEXT, "cudaGraphClone");
		tracer._kernel_map[(void *) lcudaGraphClone] = std::string("cudaGraphClone");
	}
	assert(lcudaGraphClone);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphClone(pGraphClone, originalGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphClone);
	}
	return res;
}

cudaError_t cudaGraphNodeFindInClone(cudaGraphNode_t * pNode, cudaGraphNode_t  originalNode, cudaGraph_t  clonedGraph)
{
	static cudaError_t (*lcudaGraphNodeFindInClone) (cudaGraphNode_t *, cudaGraphNode_t , cudaGraph_t );
	if (!lcudaGraphNodeFindInClone) {
		lcudaGraphNodeFindInClone = (cudaError_t (*) (cudaGraphNode_t *, cudaGraphNode_t , cudaGraph_t )) dlsym(RTLD_NEXT, "cudaGraphNodeFindInClone");
		tracer._kernel_map[(void *) lcudaGraphNodeFindInClone] = std::string("cudaGraphNodeFindInClone");
	}
	assert(lcudaGraphNodeFindInClone);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeFindInClone(pNode, originalNode, clonedGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeFindInClone);
	}
	return res;
}

cudaError_t cudaGraphNodeGetType(cudaGraphNode_t  node, enum cudaGraphNodeType * pType)
{
	static cudaError_t (*lcudaGraphNodeGetType) (cudaGraphNode_t , enum cudaGraphNodeType *);
	if (!lcudaGraphNodeGetType) {
		lcudaGraphNodeGetType = (cudaError_t (*) (cudaGraphNode_t , enum cudaGraphNodeType *)) dlsym(RTLD_NEXT, "cudaGraphNodeGetType");
		tracer._kernel_map[(void *) lcudaGraphNodeGetType] = std::string("cudaGraphNodeGetType");
	}
	assert(lcudaGraphNodeGetType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeGetType(node, pType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeGetType);
	}
	return res;
}

cudaError_t cudaGraphGetNodes(cudaGraph_t  graph, cudaGraphNode_t * nodes, size_t * numNodes)
{
	static cudaError_t (*lcudaGraphGetNodes) (cudaGraph_t , cudaGraphNode_t *, size_t *);
	if (!lcudaGraphGetNodes) {
		lcudaGraphGetNodes = (cudaError_t (*) (cudaGraph_t , cudaGraphNode_t *, size_t *)) dlsym(RTLD_NEXT, "cudaGraphGetNodes");
		tracer._kernel_map[(void *) lcudaGraphGetNodes] = std::string("cudaGraphGetNodes");
	}
	assert(lcudaGraphGetNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphGetNodes(graph, nodes, numNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphGetNodes);
	}
	return res;
}

cudaError_t cudaGraphGetRootNodes(cudaGraph_t  graph, cudaGraphNode_t * pRootNodes, size_t * pNumRootNodes)
{
	static cudaError_t (*lcudaGraphGetRootNodes) (cudaGraph_t , cudaGraphNode_t *, size_t *);
	if (!lcudaGraphGetRootNodes) {
		lcudaGraphGetRootNodes = (cudaError_t (*) (cudaGraph_t , cudaGraphNode_t *, size_t *)) dlsym(RTLD_NEXT, "cudaGraphGetRootNodes");
		tracer._kernel_map[(void *) lcudaGraphGetRootNodes] = std::string("cudaGraphGetRootNodes");
	}
	assert(lcudaGraphGetRootNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphGetRootNodes(graph, pRootNodes, pNumRootNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphGetRootNodes);
	}
	return res;
}

cudaError_t cudaGraphGetEdges(cudaGraph_t  graph, cudaGraphNode_t * from, cudaGraphNode_t * to, size_t * numEdges)
{
	static cudaError_t (*lcudaGraphGetEdges) (cudaGraph_t , cudaGraphNode_t *, cudaGraphNode_t *, size_t *);
	if (!lcudaGraphGetEdges) {
		lcudaGraphGetEdges = (cudaError_t (*) (cudaGraph_t , cudaGraphNode_t *, cudaGraphNode_t *, size_t *)) dlsym(RTLD_NEXT, "cudaGraphGetEdges");
		tracer._kernel_map[(void *) lcudaGraphGetEdges] = std::string("cudaGraphGetEdges");
	}
	assert(lcudaGraphGetEdges);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphGetEdges(graph, from, to, numEdges);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphGetEdges);
	}
	return res;
}

cudaError_t cudaGraphNodeGetDependencies(cudaGraphNode_t  node, cudaGraphNode_t * pDependencies, size_t * pNumDependencies)
{
	static cudaError_t (*lcudaGraphNodeGetDependencies) (cudaGraphNode_t , cudaGraphNode_t *, size_t *);
	if (!lcudaGraphNodeGetDependencies) {
		lcudaGraphNodeGetDependencies = (cudaError_t (*) (cudaGraphNode_t , cudaGraphNode_t *, size_t *)) dlsym(RTLD_NEXT, "cudaGraphNodeGetDependencies");
		tracer._kernel_map[(void *) lcudaGraphNodeGetDependencies] = std::string("cudaGraphNodeGetDependencies");
	}
	assert(lcudaGraphNodeGetDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeGetDependencies(node, pDependencies, pNumDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeGetDependencies);
	}
	return res;
}

cudaError_t cudaGraphNodeGetDependentNodes(cudaGraphNode_t  node, cudaGraphNode_t * pDependentNodes, size_t * pNumDependentNodes)
{
	static cudaError_t (*lcudaGraphNodeGetDependentNodes) (cudaGraphNode_t , cudaGraphNode_t *, size_t *);
	if (!lcudaGraphNodeGetDependentNodes) {
		lcudaGraphNodeGetDependentNodes = (cudaError_t (*) (cudaGraphNode_t , cudaGraphNode_t *, size_t *)) dlsym(RTLD_NEXT, "cudaGraphNodeGetDependentNodes");
		tracer._kernel_map[(void *) lcudaGraphNodeGetDependentNodes] = std::string("cudaGraphNodeGetDependentNodes");
	}
	assert(lcudaGraphNodeGetDependentNodes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeGetDependentNodes(node, pDependentNodes, pNumDependentNodes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeGetDependentNodes);
	}
	return res;
}

cudaError_t cudaGraphAddDependencies(cudaGraph_t  graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t  numDependencies)
{
	static cudaError_t (*lcudaGraphAddDependencies) (cudaGraph_t , const cudaGraphNode_t *, const cudaGraphNode_t *, size_t );
	if (!lcudaGraphAddDependencies) {
		lcudaGraphAddDependencies = (cudaError_t (*) (cudaGraph_t , const cudaGraphNode_t *, const cudaGraphNode_t *, size_t )) dlsym(RTLD_NEXT, "cudaGraphAddDependencies");
		tracer._kernel_map[(void *) lcudaGraphAddDependencies] = std::string("cudaGraphAddDependencies");
	}
	assert(lcudaGraphAddDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddDependencies(graph, from, to, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddDependencies);
	}
	return res;
}

cudaError_t cudaGraphRemoveDependencies(cudaGraph_t  graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t  numDependencies)
{
	static cudaError_t (*lcudaGraphRemoveDependencies) (cudaGraph_t , const cudaGraphNode_t *, const cudaGraphNode_t *, size_t );
	if (!lcudaGraphRemoveDependencies) {
		lcudaGraphRemoveDependencies = (cudaError_t (*) (cudaGraph_t , const cudaGraphNode_t *, const cudaGraphNode_t *, size_t )) dlsym(RTLD_NEXT, "cudaGraphRemoveDependencies");
		tracer._kernel_map[(void *) lcudaGraphRemoveDependencies] = std::string("cudaGraphRemoveDependencies");
	}
	assert(lcudaGraphRemoveDependencies);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphRemoveDependencies(graph, from, to, numDependencies);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphRemoveDependencies);
	}
	return res;
}

cudaError_t cudaGraphDestroyNode(cudaGraphNode_t  node)
{
	static cudaError_t (*lcudaGraphDestroyNode) (cudaGraphNode_t );
	if (!lcudaGraphDestroyNode) {
		lcudaGraphDestroyNode = (cudaError_t (*) (cudaGraphNode_t )) dlsym(RTLD_NEXT, "cudaGraphDestroyNode");
		tracer._kernel_map[(void *) lcudaGraphDestroyNode] = std::string("cudaGraphDestroyNode");
	}
	assert(lcudaGraphDestroyNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphDestroyNode(node);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphDestroyNode);
	}
	return res;
}

cudaError_t cudaGraphInstantiate(cudaGraphExec_t * pGraphExec, cudaGraph_t  graph, unsigned long long  flags)
{
	static cudaError_t (*lcudaGraphInstantiate) (cudaGraphExec_t *, cudaGraph_t , unsigned long long );
	if (!lcudaGraphInstantiate) {
		lcudaGraphInstantiate = (cudaError_t (*) (cudaGraphExec_t *, cudaGraph_t , unsigned long long )) dlsym(RTLD_NEXT, "cudaGraphInstantiate");
		tracer._kernel_map[(void *) lcudaGraphInstantiate] = std::string("cudaGraphInstantiate");
	}
	assert(lcudaGraphInstantiate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphInstantiate(pGraphExec, graph, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphInstantiate);
	}
	return res;
}

cudaError_t cudaGraphInstantiateWithFlags(cudaGraphExec_t * pGraphExec, cudaGraph_t  graph, unsigned long long  flags)
{
	static cudaError_t (*lcudaGraphInstantiateWithFlags) (cudaGraphExec_t *, cudaGraph_t , unsigned long long );
	if (!lcudaGraphInstantiateWithFlags) {
		lcudaGraphInstantiateWithFlags = (cudaError_t (*) (cudaGraphExec_t *, cudaGraph_t , unsigned long long )) dlsym(RTLD_NEXT, "cudaGraphInstantiateWithFlags");
		tracer._kernel_map[(void *) lcudaGraphInstantiateWithFlags] = std::string("cudaGraphInstantiateWithFlags");
	}
	assert(lcudaGraphInstantiateWithFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphInstantiateWithFlags(pGraphExec, graph, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphInstantiateWithFlags);
	}
	return res;
}

cudaError_t cudaGraphInstantiateWithParams(cudaGraphExec_t * pGraphExec, cudaGraph_t  graph, cudaGraphInstantiateParams * instantiateParams)
{
	static cudaError_t (*lcudaGraphInstantiateWithParams) (cudaGraphExec_t *, cudaGraph_t , cudaGraphInstantiateParams *);
	if (!lcudaGraphInstantiateWithParams) {
		lcudaGraphInstantiateWithParams = (cudaError_t (*) (cudaGraphExec_t *, cudaGraph_t , cudaGraphInstantiateParams *)) dlsym(RTLD_NEXT, "cudaGraphInstantiateWithParams");
		tracer._kernel_map[(void *) lcudaGraphInstantiateWithParams] = std::string("cudaGraphInstantiateWithParams");
	}
	assert(lcudaGraphInstantiateWithParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphInstantiateWithParams(pGraphExec, graph, instantiateParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphInstantiateWithParams);
	}
	return res;
}

cudaError_t cudaGraphExecGetFlags(cudaGraphExec_t  graphExec, unsigned long long * flags)
{
	static cudaError_t (*lcudaGraphExecGetFlags) (cudaGraphExec_t , unsigned long long *);
	if (!lcudaGraphExecGetFlags) {
		lcudaGraphExecGetFlags = (cudaError_t (*) (cudaGraphExec_t , unsigned long long *)) dlsym(RTLD_NEXT, "cudaGraphExecGetFlags");
		tracer._kernel_map[(void *) lcudaGraphExecGetFlags] = std::string("cudaGraphExecGetFlags");
	}
	assert(lcudaGraphExecGetFlags);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecGetFlags(graphExec, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecGetFlags);
	}
	return res;
}

cudaError_t cudaGraphExecKernelNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, const struct cudaKernelNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphExecKernelNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaKernelNodeParams *);
	if (!lcudaGraphExecKernelNodeSetParams) {
		lcudaGraphExecKernelNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaKernelNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExecKernelNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecKernelNodeSetParams] = std::string("cudaGraphExecKernelNodeSetParams");
	}
	assert(lcudaGraphExecKernelNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecKernelNodeSetParams(hGraphExec, node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecKernelNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, const struct cudaMemcpy3DParms * pNodeParams)
{
	static cudaError_t (*lcudaGraphExecMemcpyNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaMemcpy3DParms *);
	if (!lcudaGraphExecMemcpyNodeSetParams) {
		lcudaGraphExecMemcpyNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaMemcpy3DParms *)) dlsym(RTLD_NEXT, "cudaGraphExecMemcpyNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecMemcpyNodeSetParams] = std::string("cudaGraphExecMemcpyNodeSetParams");
	}
	assert(lcudaGraphExecMemcpyNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecMemcpyNodeSetParams(hGraphExec, node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecMemcpyNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, const void*  symbol, const void*  src, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphExecMemcpyNodeSetParamsToSymbol) (cudaGraphExec_t , cudaGraphNode_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphExecMemcpyNodeSetParamsToSymbol) {
		lcudaGraphExecMemcpyNodeSetParamsToSymbol = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphExecMemcpyNodeSetParamsToSymbol");
		tracer._kernel_map[(void *) lcudaGraphExecMemcpyNodeSetParamsToSymbol] = std::string("cudaGraphExecMemcpyNodeSetParamsToSymbol");
	}
	assert(lcudaGraphExecMemcpyNodeSetParamsToSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, symbol, src, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecMemcpyNodeSetParamsToSymbol);
	}
	return res;
}

cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, void*  dst, const void*  symbol, size_t  count, size_t  offset, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphExecMemcpyNodeSetParamsFromSymbol) (cudaGraphExec_t , cudaGraphNode_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphExecMemcpyNodeSetParamsFromSymbol) {
		lcudaGraphExecMemcpyNodeSetParamsFromSymbol = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , void* , const void* , size_t , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphExecMemcpyNodeSetParamsFromSymbol");
		tracer._kernel_map[(void *) lcudaGraphExecMemcpyNodeSetParamsFromSymbol] = std::string("cudaGraphExecMemcpyNodeSetParamsFromSymbol");
	}
	assert(lcudaGraphExecMemcpyNodeSetParamsFromSymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, symbol, count, offset, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecMemcpyNodeSetParamsFromSymbol);
	}
	return res;
}

cudaError_t cudaGraphExecMemcpyNodeSetParams1D(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, void*  dst, const void*  src, size_t  count, enum cudaMemcpyKind  kind)
{
	static cudaError_t (*lcudaGraphExecMemcpyNodeSetParams1D) (cudaGraphExec_t , cudaGraphNode_t , void* , const void* , size_t , enum cudaMemcpyKind );
	if (!lcudaGraphExecMemcpyNodeSetParams1D) {
		lcudaGraphExecMemcpyNodeSetParams1D = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , void* , const void* , size_t , enum cudaMemcpyKind )) dlsym(RTLD_NEXT, "cudaGraphExecMemcpyNodeSetParams1D");
		tracer._kernel_map[(void *) lcudaGraphExecMemcpyNodeSetParams1D] = std::string("cudaGraphExecMemcpyNodeSetParams1D");
	}
	assert(lcudaGraphExecMemcpyNodeSetParams1D);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecMemcpyNodeSetParams1D(hGraphExec, node, dst, src, count, kind);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecMemcpyNodeSetParams1D);
	}
	return res;
}

cudaError_t cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, const struct cudaMemsetParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphExecMemsetNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaMemsetParams *);
	if (!lcudaGraphExecMemsetNodeSetParams) {
		lcudaGraphExecMemsetNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaMemsetParams *)) dlsym(RTLD_NEXT, "cudaGraphExecMemsetNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecMemsetNodeSetParams] = std::string("cudaGraphExecMemsetNodeSetParams");
	}
	assert(lcudaGraphExecMemsetNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecMemsetNodeSetParams(hGraphExec, node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecMemsetNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecHostNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, const struct cudaHostNodeParams * pNodeParams)
{
	static cudaError_t (*lcudaGraphExecHostNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaHostNodeParams *);
	if (!lcudaGraphExecHostNodeSetParams) {
		lcudaGraphExecHostNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaHostNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExecHostNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecHostNodeSetParams] = std::string("cudaGraphExecHostNodeSetParams");
	}
	assert(lcudaGraphExecHostNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecHostNodeSetParams(hGraphExec, node, pNodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecHostNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  node, cudaGraph_t  childGraph)
{
	static cudaError_t (*lcudaGraphExecChildGraphNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , cudaGraph_t );
	if (!lcudaGraphExecChildGraphNodeSetParams) {
		lcudaGraphExecChildGraphNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , cudaGraph_t )) dlsym(RTLD_NEXT, "cudaGraphExecChildGraphNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecChildGraphNodeSetParams] = std::string("cudaGraphExecChildGraphNodeSetParams");
	}
	assert(lcudaGraphExecChildGraphNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecChildGraphNodeSetParams(hGraphExec, node, childGraph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecChildGraphNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphExecEventRecordNodeSetEvent) (cudaGraphExec_t , cudaGraphNode_t , cudaEvent_t );
	if (!lcudaGraphExecEventRecordNodeSetEvent) {
		lcudaGraphExecEventRecordNodeSetEvent = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphExecEventRecordNodeSetEvent");
		tracer._kernel_map[(void *) lcudaGraphExecEventRecordNodeSetEvent] = std::string("cudaGraphExecEventRecordNodeSetEvent");
	}
	assert(lcudaGraphExecEventRecordNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecEventRecordNodeSetEvent);
	}
	return res;
}

cudaError_t cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, cudaEvent_t  event)
{
	static cudaError_t (*lcudaGraphExecEventWaitNodeSetEvent) (cudaGraphExec_t , cudaGraphNode_t , cudaEvent_t );
	if (!lcudaGraphExecEventWaitNodeSetEvent) {
		lcudaGraphExecEventWaitNodeSetEvent = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , cudaEvent_t )) dlsym(RTLD_NEXT, "cudaGraphExecEventWaitNodeSetEvent");
		tracer._kernel_map[(void *) lcudaGraphExecEventWaitNodeSetEvent] = std::string("cudaGraphExecEventWaitNodeSetEvent");
	}
	assert(lcudaGraphExecEventWaitNodeSetEvent);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecEventWaitNodeSetEvent);
	}
	return res;
}

cudaError_t cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, const struct cudaExternalSemaphoreSignalNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphExecExternalSemaphoresSignalNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaExternalSemaphoreSignalNodeParams *);
	if (!lcudaGraphExecExternalSemaphoresSignalNodeSetParams) {
		lcudaGraphExecExternalSemaphoresSignalNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaExternalSemaphoreSignalNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExecExternalSemaphoresSignalNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecExternalSemaphoresSignalNodeSetParams] = std::string("cudaGraphExecExternalSemaphoresSignalNodeSetParams");
	}
	assert(lcudaGraphExecExternalSemaphoresSignalNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecExternalSemaphoresSignalNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, const struct cudaExternalSemaphoreWaitNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphExecExternalSemaphoresWaitNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaExternalSemaphoreWaitNodeParams *);
	if (!lcudaGraphExecExternalSemaphoresWaitNodeSetParams) {
		lcudaGraphExecExternalSemaphoresWaitNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , const struct cudaExternalSemaphoreWaitNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExecExternalSemaphoresWaitNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecExternalSemaphoresWaitNodeSetParams] = std::string("cudaGraphExecExternalSemaphoresWaitNodeSetParams");
	}
	assert(lcudaGraphExecExternalSemaphoresWaitNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecExternalSemaphoresWaitNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphNodeSetEnabled(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, unsigned int  isEnabled)
{
	static cudaError_t (*lcudaGraphNodeSetEnabled) (cudaGraphExec_t , cudaGraphNode_t , unsigned int );
	if (!lcudaGraphNodeSetEnabled) {
		lcudaGraphNodeSetEnabled = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , unsigned int )) dlsym(RTLD_NEXT, "cudaGraphNodeSetEnabled");
		tracer._kernel_map[(void *) lcudaGraphNodeSetEnabled] = std::string("cudaGraphNodeSetEnabled");
	}
	assert(lcudaGraphNodeSetEnabled);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeSetEnabled(hGraphExec, hNode, isEnabled);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeSetEnabled);
	}
	return res;
}

cudaError_t cudaGraphNodeGetEnabled(cudaGraphExec_t  hGraphExec, cudaGraphNode_t  hNode, unsigned int * isEnabled)
{
	static cudaError_t (*lcudaGraphNodeGetEnabled) (cudaGraphExec_t , cudaGraphNode_t , unsigned int *);
	if (!lcudaGraphNodeGetEnabled) {
		lcudaGraphNodeGetEnabled = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , unsigned int *)) dlsym(RTLD_NEXT, "cudaGraphNodeGetEnabled");
		tracer._kernel_map[(void *) lcudaGraphNodeGetEnabled] = std::string("cudaGraphNodeGetEnabled");
	}
	assert(lcudaGraphNodeGetEnabled);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeGetEnabled(hGraphExec, hNode, isEnabled);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeGetEnabled);
	}
	return res;
}

cudaError_t cudaGraphExecUpdate(cudaGraphExec_t  hGraphExec, cudaGraph_t  hGraph, cudaGraphExecUpdateResultInfo * resultInfo)
{
	static cudaError_t (*lcudaGraphExecUpdate) (cudaGraphExec_t , cudaGraph_t , cudaGraphExecUpdateResultInfo *);
	if (!lcudaGraphExecUpdate) {
		lcudaGraphExecUpdate = (cudaError_t (*) (cudaGraphExec_t , cudaGraph_t , cudaGraphExecUpdateResultInfo *)) dlsym(RTLD_NEXT, "cudaGraphExecUpdate");
		tracer._kernel_map[(void *) lcudaGraphExecUpdate] = std::string("cudaGraphExecUpdate");
	}
	assert(lcudaGraphExecUpdate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecUpdate(hGraphExec, hGraph, resultInfo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecUpdate);
	}
	return res;
}

cudaError_t cudaGraphUpload(cudaGraphExec_t  graphExec, cudaStream_t  stream)
{
	static cudaError_t (*lcudaGraphUpload) (cudaGraphExec_t , cudaStream_t );
	if (!lcudaGraphUpload) {
		lcudaGraphUpload = (cudaError_t (*) (cudaGraphExec_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaGraphUpload");
		tracer._kernel_map[(void *) lcudaGraphUpload] = std::string("cudaGraphUpload");
	}
	assert(lcudaGraphUpload);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphUpload(graphExec, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphUpload);
	}
	return res;
}

cudaError_t cudaGraphLaunch(cudaGraphExec_t  graphExec, cudaStream_t  stream)
{
	static cudaError_t (*lcudaGraphLaunch) (cudaGraphExec_t , cudaStream_t );
	if (!lcudaGraphLaunch) {
		lcudaGraphLaunch = (cudaError_t (*) (cudaGraphExec_t , cudaStream_t )) dlsym(RTLD_NEXT, "cudaGraphLaunch");
		tracer._kernel_map[(void *) lcudaGraphLaunch] = std::string("cudaGraphLaunch");
	}
	assert(lcudaGraphLaunch);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphLaunch(graphExec, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphLaunch);
	}
	return res;
}

cudaError_t cudaGraphExecDestroy(cudaGraphExec_t  graphExec)
{
	static cudaError_t (*lcudaGraphExecDestroy) (cudaGraphExec_t );
	if (!lcudaGraphExecDestroy) {
		lcudaGraphExecDestroy = (cudaError_t (*) (cudaGraphExec_t )) dlsym(RTLD_NEXT, "cudaGraphExecDestroy");
		tracer._kernel_map[(void *) lcudaGraphExecDestroy] = std::string("cudaGraphExecDestroy");
	}
	assert(lcudaGraphExecDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecDestroy(graphExec);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecDestroy);
	}
	return res;
}

cudaError_t cudaGraphDestroy(cudaGraph_t  graph)
{
	static cudaError_t (*lcudaGraphDestroy) (cudaGraph_t );
	if (!lcudaGraphDestroy) {
		lcudaGraphDestroy = (cudaError_t (*) (cudaGraph_t )) dlsym(RTLD_NEXT, "cudaGraphDestroy");
		tracer._kernel_map[(void *) lcudaGraphDestroy] = std::string("cudaGraphDestroy");
	}
	assert(lcudaGraphDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphDestroy(graph);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphDestroy);
	}
	return res;
}

cudaError_t cudaGraphDebugDotPrint(cudaGraph_t  graph, const char * path, unsigned int  flags)
{
	static cudaError_t (*lcudaGraphDebugDotPrint) (cudaGraph_t , const char *, unsigned int );
	if (!lcudaGraphDebugDotPrint) {
		lcudaGraphDebugDotPrint = (cudaError_t (*) (cudaGraph_t , const char *, unsigned int )) dlsym(RTLD_NEXT, "cudaGraphDebugDotPrint");
		tracer._kernel_map[(void *) lcudaGraphDebugDotPrint] = std::string("cudaGraphDebugDotPrint");
	}
	assert(lcudaGraphDebugDotPrint);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphDebugDotPrint(graph, path, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphDebugDotPrint);
	}
	return res;
}

cudaError_t cudaUserObjectCreate(cudaUserObject_t * object_out, void * ptr, cudaHostFn_t  destroy, unsigned int  initialRefcount, unsigned int  flags)
{
	static cudaError_t (*lcudaUserObjectCreate) (cudaUserObject_t *, void *, cudaHostFn_t , unsigned int , unsigned int );
	if (!lcudaUserObjectCreate) {
		lcudaUserObjectCreate = (cudaError_t (*) (cudaUserObject_t *, void *, cudaHostFn_t , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaUserObjectCreate");
		tracer._kernel_map[(void *) lcudaUserObjectCreate] = std::string("cudaUserObjectCreate");
	}
	assert(lcudaUserObjectCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaUserObjectCreate(object_out, ptr, destroy, initialRefcount, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaUserObjectCreate);
	}
	return res;
}

cudaError_t cudaUserObjectRetain(cudaUserObject_t  object, unsigned int  count)
{
	static cudaError_t (*lcudaUserObjectRetain) (cudaUserObject_t , unsigned int );
	if (!lcudaUserObjectRetain) {
		lcudaUserObjectRetain = (cudaError_t (*) (cudaUserObject_t , unsigned int )) dlsym(RTLD_NEXT, "cudaUserObjectRetain");
		tracer._kernel_map[(void *) lcudaUserObjectRetain] = std::string("cudaUserObjectRetain");
	}
	assert(lcudaUserObjectRetain);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaUserObjectRetain(object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaUserObjectRetain);
	}
	return res;
}

cudaError_t cudaUserObjectRelease(cudaUserObject_t  object, unsigned int  count)
{
	static cudaError_t (*lcudaUserObjectRelease) (cudaUserObject_t , unsigned int );
	if (!lcudaUserObjectRelease) {
		lcudaUserObjectRelease = (cudaError_t (*) (cudaUserObject_t , unsigned int )) dlsym(RTLD_NEXT, "cudaUserObjectRelease");
		tracer._kernel_map[(void *) lcudaUserObjectRelease] = std::string("cudaUserObjectRelease");
	}
	assert(lcudaUserObjectRelease);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaUserObjectRelease(object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaUserObjectRelease);
	}
	return res;
}

cudaError_t cudaGraphRetainUserObject(cudaGraph_t  graph, cudaUserObject_t  object, unsigned int  count, unsigned int  flags)
{
	static cudaError_t (*lcudaGraphRetainUserObject) (cudaGraph_t , cudaUserObject_t , unsigned int , unsigned int );
	if (!lcudaGraphRetainUserObject) {
		lcudaGraphRetainUserObject = (cudaError_t (*) (cudaGraph_t , cudaUserObject_t , unsigned int , unsigned int )) dlsym(RTLD_NEXT, "cudaGraphRetainUserObject");
		tracer._kernel_map[(void *) lcudaGraphRetainUserObject] = std::string("cudaGraphRetainUserObject");
	}
	assert(lcudaGraphRetainUserObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphRetainUserObject(graph, object, count, flags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphRetainUserObject);
	}
	return res;
}

cudaError_t cudaGraphReleaseUserObject(cudaGraph_t  graph, cudaUserObject_t  object, unsigned int  count)
{
	static cudaError_t (*lcudaGraphReleaseUserObject) (cudaGraph_t , cudaUserObject_t , unsigned int );
	if (!lcudaGraphReleaseUserObject) {
		lcudaGraphReleaseUserObject = (cudaError_t (*) (cudaGraph_t , cudaUserObject_t , unsigned int )) dlsym(RTLD_NEXT, "cudaGraphReleaseUserObject");
		tracer._kernel_map[(void *) lcudaGraphReleaseUserObject] = std::string("cudaGraphReleaseUserObject");
	}
	assert(lcudaGraphReleaseUserObject);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphReleaseUserObject(graph, object, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphReleaseUserObject);
	}
	return res;
}

cudaError_t cudaGraphAddNode(cudaGraphNode_t * pGraphNode, cudaGraph_t  graph, const cudaGraphNode_t * pDependencies, size_t  numDependencies, struct cudaGraphNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphAddNode) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , struct cudaGraphNodeParams *);
	if (!lcudaGraphAddNode) {
		lcudaGraphAddNode = (cudaError_t (*) (cudaGraphNode_t *, cudaGraph_t , const cudaGraphNode_t *, size_t , struct cudaGraphNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphAddNode");
		tracer._kernel_map[(void *) lcudaGraphAddNode] = std::string("cudaGraphAddNode");
	}
	assert(lcudaGraphAddNode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphAddNode(pGraphNode, graph, pDependencies, numDependencies, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphAddNode);
	}
	return res;
}

cudaError_t cudaGraphNodeSetParams(cudaGraphNode_t  node, struct cudaGraphNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphNodeSetParams) (cudaGraphNode_t , struct cudaGraphNodeParams *);
	if (!lcudaGraphNodeSetParams) {
		lcudaGraphNodeSetParams = (cudaError_t (*) (cudaGraphNode_t , struct cudaGraphNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphNodeSetParams] = std::string("cudaGraphNodeSetParams");
	}
	assert(lcudaGraphNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphNodeSetParams(node, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphNodeSetParams);
	}
	return res;
}

cudaError_t cudaGraphExecNodeSetParams(cudaGraphExec_t  graphExec, cudaGraphNode_t  node, struct cudaGraphNodeParams * nodeParams)
{
	static cudaError_t (*lcudaGraphExecNodeSetParams) (cudaGraphExec_t , cudaGraphNode_t , struct cudaGraphNodeParams *);
	if (!lcudaGraphExecNodeSetParams) {
		lcudaGraphExecNodeSetParams = (cudaError_t (*) (cudaGraphExec_t , cudaGraphNode_t , struct cudaGraphNodeParams *)) dlsym(RTLD_NEXT, "cudaGraphExecNodeSetParams");
		tracer._kernel_map[(void *) lcudaGraphExecNodeSetParams] = std::string("cudaGraphExecNodeSetParams");
	}
	assert(lcudaGraphExecNodeSetParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGraphExecNodeSetParams(graphExec, node, nodeParams);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGraphExecNodeSetParams);
	}
	return res;
}

cudaError_t cudaGetDriverEntryPoint(const char * symbol, void ** funcPtr, unsigned long long  flags, enum cudaDriverEntryPointQueryResult * driverStatus)
{
	static cudaError_t (*lcudaGetDriverEntryPoint) (const char *, void **, unsigned long long , enum cudaDriverEntryPointQueryResult *);
	if (!lcudaGetDriverEntryPoint) {
		lcudaGetDriverEntryPoint = (cudaError_t (*) (const char *, void **, unsigned long long , enum cudaDriverEntryPointQueryResult *)) dlsym(RTLD_NEXT, "cudaGetDriverEntryPoint");
		tracer._kernel_map[(void *) lcudaGetDriverEntryPoint] = std::string("cudaGetDriverEntryPoint");
	}
	assert(lcudaGetDriverEntryPoint);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetDriverEntryPoint(symbol, funcPtr, flags, driverStatus);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetDriverEntryPoint);
	}
	return res;
}

cudaError_t cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId)
{
	static cudaError_t (*lcudaGetExportTable) (const void **, const cudaUUID_t *);
	if (!lcudaGetExportTable) {
		lcudaGetExportTable = (cudaError_t (*) (const void **, const cudaUUID_t *)) dlsym(RTLD_NEXT, "cudaGetExportTable");
		tracer._kernel_map[(void *) lcudaGetExportTable] = std::string("cudaGetExportTable");
	}
	assert(lcudaGetExportTable);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetExportTable(ppExportTable, pExportTableId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetExportTable);
	}
	return res;
}

cudaError_t cudaGetFuncBySymbol(cudaFunction_t*  functionPtr, const void*  symbolPtr)
{
	static cudaError_t (*lcudaGetFuncBySymbol) (cudaFunction_t* , const void* );
	if (!lcudaGetFuncBySymbol) {
		lcudaGetFuncBySymbol = (cudaError_t (*) (cudaFunction_t* , const void* )) dlsym(RTLD_NEXT, "cudaGetFuncBySymbol");
		tracer._kernel_map[(void *) lcudaGetFuncBySymbol] = std::string("cudaGetFuncBySymbol");
	}
	assert(lcudaGetFuncBySymbol);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetFuncBySymbol(functionPtr, symbolPtr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetFuncBySymbol);
	}
	return res;
}

cudaError_t cudaGetKernel(cudaKernel_t * kernelPtr, const void * entryFuncAddr)
{
	static cudaError_t (*lcudaGetKernel) (cudaKernel_t *, const void *);
	if (!lcudaGetKernel) {
		lcudaGetKernel = (cudaError_t (*) (cudaKernel_t *, const void *)) dlsym(RTLD_NEXT, "cudaGetKernel");
		tracer._kernel_map[(void *) lcudaGetKernel] = std::string("cudaGetKernel");
	}
	assert(lcudaGetKernel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudaError_t res = 
		lcudaGetKernel(kernelPtr, entryFuncAddr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudaGetKernel);
	}
	return res;
}

size_t cudnnGetVersion()
{
	static size_t (*lcudnnGetVersion) ();
	if (!lcudnnGetVersion) {
		lcudnnGetVersion = (size_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnGetVersion");
		tracer._kernel_map[(void *) lcudnnGetVersion] = std::string("cudnnGetVersion");
	}
	assert(lcudnnGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcudnnGetVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetVersion);
	}
	return res;
}

size_t cudnnGetMaxDeviceVersion()
{
	static size_t (*lcudnnGetMaxDeviceVersion) ();
	if (!lcudnnGetMaxDeviceVersion) {
		lcudnnGetMaxDeviceVersion = (size_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnGetMaxDeviceVersion");
		tracer._kernel_map[(void *) lcudnnGetMaxDeviceVersion] = std::string("cudnnGetMaxDeviceVersion");
	}
	assert(lcudnnGetMaxDeviceVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcudnnGetMaxDeviceVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetMaxDeviceVersion);
	}
	return res;
}

size_t cudnnGetCudartVersion()
{
	static size_t (*lcudnnGetCudartVersion) ();
	if (!lcudnnGetCudartVersion) {
		lcudnnGetCudartVersion = (size_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnGetCudartVersion");
		tracer._kernel_map[(void *) lcudnnGetCudartVersion] = std::string("cudnnGetCudartVersion");
	}
	assert(lcudnnGetCudartVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcudnnGetCudartVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCudartVersion);
	}
	return res;
}

const char * cudnnGetErrorString(cudnnStatus_t  status)
{
	static const char * (*lcudnnGetErrorString) (cudnnStatus_t );
	if (!lcudnnGetErrorString) {
		lcudnnGetErrorString = (const char * (*) (cudnnStatus_t )) dlsym(tracer.cudnn_handle, "cudnnGetErrorString");
		tracer._kernel_map[(void *) lcudnnGetErrorString] = std::string("cudnnGetErrorString");
	}
	assert(lcudnnGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char * res = 
		lcudnnGetErrorString(status);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetErrorString);
	}
	return res;
}

cudnnStatus_t cudnnQueryRuntimeError(cudnnHandle_t  handle, cudnnStatus_t * rstatus, cudnnErrQueryMode_t  mode, cudnnRuntimeTag_t * tag)
{
	static cudnnStatus_t (*lcudnnQueryRuntimeError) (cudnnHandle_t , cudnnStatus_t *, cudnnErrQueryMode_t , cudnnRuntimeTag_t *);
	if (!lcudnnQueryRuntimeError) {
		lcudnnQueryRuntimeError = (cudnnStatus_t (*) (cudnnHandle_t , cudnnStatus_t *, cudnnErrQueryMode_t , cudnnRuntimeTag_t *)) dlsym(tracer.cudnn_handle, "cudnnQueryRuntimeError");
		tracer._kernel_map[(void *) lcudnnQueryRuntimeError] = std::string("cudnnQueryRuntimeError");
	}
	assert(lcudnnQueryRuntimeError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnQueryRuntimeError(handle, rstatus, mode, tag);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnQueryRuntimeError);
	}
	return res;
}

cudnnStatus_t cudnnGetProperty(libraryPropertyType  type, int * value)
{
	static cudnnStatus_t (*lcudnnGetProperty) (libraryPropertyType , int *);
	if (!lcudnnGetProperty) {
		lcudnnGetProperty = (cudnnStatus_t (*) (libraryPropertyType , int *)) dlsym(tracer.cudnn_handle, "cudnnGetProperty");
		tracer._kernel_map[(void *) lcudnnGetProperty] = std::string("cudnnGetProperty");
	}
	assert(lcudnnGetProperty);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetProperty(type, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetProperty);
	}
	return res;
}

cudnnStatus_t cudnnCreate(cudnnHandle_t * handle)
{
	static cudnnStatus_t (*lcudnnCreate) (cudnnHandle_t *);
	if (!lcudnnCreate) {
		lcudnnCreate = (cudnnStatus_t (*) (cudnnHandle_t *)) dlsym(tracer.cudnn_handle, "cudnnCreate");
		tracer._kernel_map[(void *) lcudnnCreate] = std::string("cudnnCreate");
	}
	assert(lcudnnCreate);
	cudnnStatus_t res = 
		lcudnnCreate(handle);
	return res;
}

cudnnStatus_t cudnnDestroy(cudnnHandle_t  handle)
{
	static cudnnStatus_t (*lcudnnDestroy) (cudnnHandle_t );
	if (!lcudnnDestroy) {
		lcudnnDestroy = (cudnnStatus_t (*) (cudnnHandle_t )) dlsym(tracer.cudnn_handle, "cudnnDestroy");
		tracer._kernel_map[(void *) lcudnnDestroy] = std::string("cudnnDestroy");
	}
	assert(lcudnnDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroy(handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroy);
	}
	return res;
}

cudnnStatus_t cudnnSetStream(cudnnHandle_t  handle, cudaStream_t  streamId)
{
	static cudnnStatus_t (*lcudnnSetStream) (cudnnHandle_t , cudaStream_t );
	if (!lcudnnSetStream) {
		lcudnnSetStream = (cudnnStatus_t (*) (cudnnHandle_t , cudaStream_t )) dlsym(tracer.cudnn_handle, "cudnnSetStream");
		tracer._kernel_map[(void *) lcudnnSetStream] = std::string("cudnnSetStream");
	}
	assert(lcudnnSetStream);
	cudnnStatus_t res = 
		lcudnnSetStream(handle, streamId);
	return res;
}

cudnnStatus_t cudnnGetStream(cudnnHandle_t  handle, cudaStream_t * streamId)
{
	static cudnnStatus_t (*lcudnnGetStream) (cudnnHandle_t , cudaStream_t *);
	if (!lcudnnGetStream) {
		lcudnnGetStream = (cudnnStatus_t (*) (cudnnHandle_t , cudaStream_t *)) dlsym(tracer.cudnn_handle, "cudnnGetStream");
		tracer._kernel_map[(void *) lcudnnGetStream] = std::string("cudnnGetStream");
	}
	assert(lcudnnGetStream);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetStream(handle, streamId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetStream);
	}
	return res;
}

cudnnStatus_t cudnnCreateTensorDescriptor(cudnnTensorDescriptor_t * tensorDesc)
{
	static cudnnStatus_t (*lcudnnCreateTensorDescriptor) (cudnnTensorDescriptor_t *);
	if (!lcudnnCreateTensorDescriptor) {
		lcudnnCreateTensorDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateTensorDescriptor] = std::string("cudnnCreateTensorDescriptor");
	}
	assert(lcudnnCreateTensorDescriptor);
	cudnnStatus_t res = 
		lcudnnCreateTensorDescriptor(tensorDesc);
	return res;
}

cudnnStatus_t cudnnSetTensor4dDescriptor(cudnnTensorDescriptor_t  tensorDesc, cudnnTensorFormat_t  format, cudnnDataType_t  dataType, int  n, int  c, int  h, int  w)
{
	static cudnnStatus_t (*lcudnnSetTensor4dDescriptor) (cudnnTensorDescriptor_t , cudnnTensorFormat_t , cudnnDataType_t , int , int , int , int );
	if (!lcudnnSetTensor4dDescriptor) {
		lcudnnSetTensor4dDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , cudnnTensorFormat_t , cudnnDataType_t , int , int , int , int )) dlsym(tracer.cudnn_handle, "cudnnSetTensor4dDescriptor");
		tracer._kernel_map[(void *) lcudnnSetTensor4dDescriptor] = std::string("cudnnSetTensor4dDescriptor");
	}
	assert(lcudnnSetTensor4dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetTensor4dDescriptor(tensorDesc, format, dataType, n, c, h, w);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetTensor4dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetTensor4dDescriptorEx(cudnnTensorDescriptor_t  tensorDesc, cudnnDataType_t  dataType, int  n, int  c, int  h, int  w, int  nStride, int  cStride, int  hStride, int  wStride)
{
	static cudnnStatus_t (*lcudnnSetTensor4dDescriptorEx) (cudnnTensorDescriptor_t , cudnnDataType_t , int , int , int , int , int , int , int , int );
	if (!lcudnnSetTensor4dDescriptorEx) {
		lcudnnSetTensor4dDescriptorEx = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , cudnnDataType_t , int , int , int , int , int , int , int , int )) dlsym(tracer.cudnn_handle, "cudnnSetTensor4dDescriptorEx");
		tracer._kernel_map[(void *) lcudnnSetTensor4dDescriptorEx] = std::string("cudnnSetTensor4dDescriptorEx");
	}
	assert(lcudnnSetTensor4dDescriptorEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetTensor4dDescriptorEx(tensorDesc, dataType, n, c, h, w, nStride, cStride, hStride, wStride);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetTensor4dDescriptorEx);
	}
	return res;
}

cudnnStatus_t cudnnGetTensor4dDescriptor(const cudnnTensorDescriptor_t  tensorDesc, cudnnDataType_t * dataType, int * n, int * c, int * h, int * w, int * nStride, int * cStride, int * hStride, int * wStride)
{
	static cudnnStatus_t (*lcudnnGetTensor4dDescriptor) (const cudnnTensorDescriptor_t , cudnnDataType_t *, int *, int *, int *, int *, int *, int *, int *, int *);
	if (!lcudnnGetTensor4dDescriptor) {
		lcudnnGetTensor4dDescriptor = (cudnnStatus_t (*) (const cudnnTensorDescriptor_t , cudnnDataType_t *, int *, int *, int *, int *, int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetTensor4dDescriptor");
		tracer._kernel_map[(void *) lcudnnGetTensor4dDescriptor] = std::string("cudnnGetTensor4dDescriptor");
	}
	assert(lcudnnGetTensor4dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetTensor4dDescriptor(tensorDesc, dataType, n, c, h, w, nStride, cStride, hStride, wStride);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetTensor4dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetTensorNdDescriptor(cudnnTensorDescriptor_t  tensorDesc, cudnnDataType_t  dataType, int  nbDims, const int  dimA[], const int  strideA[])
{
	static cudnnStatus_t (*lcudnnSetTensorNdDescriptor) (cudnnTensorDescriptor_t , cudnnDataType_t , int , const int [], const int []);
	if (!lcudnnSetTensorNdDescriptor) {
		lcudnnSetTensorNdDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , cudnnDataType_t , int , const int [], const int [])) dlsym(tracer.cudnn_handle, "cudnnSetTensorNdDescriptor");
		tracer._kernel_map[(void *) lcudnnSetTensorNdDescriptor] = std::string("cudnnSetTensorNdDescriptor");
	}
	assert(lcudnnSetTensorNdDescriptor);
	cudnnStatus_t res = 
		lcudnnSetTensorNdDescriptor(tensorDesc, dataType, nbDims, dimA, strideA);
	return res;
}

cudnnStatus_t cudnnSetTensorNdDescriptorEx(cudnnTensorDescriptor_t  tensorDesc, cudnnTensorFormat_t  format, cudnnDataType_t  dataType, int  nbDims, const int  dimA[])
{
	static cudnnStatus_t (*lcudnnSetTensorNdDescriptorEx) (cudnnTensorDescriptor_t , cudnnTensorFormat_t , cudnnDataType_t , int , const int []);
	if (!lcudnnSetTensorNdDescriptorEx) {
		lcudnnSetTensorNdDescriptorEx = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , cudnnTensorFormat_t , cudnnDataType_t , int , const int [])) dlsym(tracer.cudnn_handle, "cudnnSetTensorNdDescriptorEx");
		tracer._kernel_map[(void *) lcudnnSetTensorNdDescriptorEx] = std::string("cudnnSetTensorNdDescriptorEx");
	}
	assert(lcudnnSetTensorNdDescriptorEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetTensorNdDescriptorEx(tensorDesc, format, dataType, nbDims, dimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetTensorNdDescriptorEx);
	}
	return res;
}

cudnnStatus_t cudnnGetTensorNdDescriptor(const cudnnTensorDescriptor_t  tensorDesc, int  nbDimsRequested, cudnnDataType_t * dataType, int * nbDims, int  dimA[], int  strideA[])
{
	static cudnnStatus_t (*lcudnnGetTensorNdDescriptor) (const cudnnTensorDescriptor_t , int , cudnnDataType_t *, int *, int [], int []);
	if (!lcudnnGetTensorNdDescriptor) {
		lcudnnGetTensorNdDescriptor = (cudnnStatus_t (*) (const cudnnTensorDescriptor_t , int , cudnnDataType_t *, int *, int [], int [])) dlsym(tracer.cudnn_handle, "cudnnGetTensorNdDescriptor");
		tracer._kernel_map[(void *) lcudnnGetTensorNdDescriptor] = std::string("cudnnGetTensorNdDescriptor");
	}
	assert(lcudnnGetTensorNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetTensorNdDescriptor(tensorDesc, nbDimsRequested, dataType, nbDims, dimA, strideA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetTensorNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetTensorSizeInBytes(const cudnnTensorDescriptor_t  tensorDesc, size_t * size)
{
	static cudnnStatus_t (*lcudnnGetTensorSizeInBytes) (const cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnGetTensorSizeInBytes) {
		lcudnnGetTensorSizeInBytes = (cudnnStatus_t (*) (const cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetTensorSizeInBytes");
		tracer._kernel_map[(void *) lcudnnGetTensorSizeInBytes] = std::string("cudnnGetTensorSizeInBytes");
	}
	assert(lcudnnGetTensorSizeInBytes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetTensorSizeInBytes(tensorDesc, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetTensorSizeInBytes);
	}
	return res;
}

cudnnStatus_t cudnnDestroyTensorDescriptor(cudnnTensorDescriptor_t  tensorDesc)
{
	static cudnnStatus_t (*lcudnnDestroyTensorDescriptor) (cudnnTensorDescriptor_t );
	if (!lcudnnDestroyTensorDescriptor) {
		lcudnnDestroyTensorDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyTensorDescriptor] = std::string("cudnnDestroyTensorDescriptor");
	}
	assert(lcudnnDestroyTensorDescriptor);
	cudnnStatus_t res = 
		lcudnnDestroyTensorDescriptor(tensorDesc);
	return res;
}

cudnnStatus_t cudnnInitTransformDest(const cudnnTensorTransformDescriptor_t  transformDesc, const cudnnTensorDescriptor_t  srcDesc, cudnnTensorDescriptor_t  destDesc, size_t * destSizeInBytes)
{
	static cudnnStatus_t (*lcudnnInitTransformDest) (const cudnnTensorTransformDescriptor_t , const cudnnTensorDescriptor_t , cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnInitTransformDest) {
		lcudnnInitTransformDest = (cudnnStatus_t (*) (const cudnnTensorTransformDescriptor_t , const cudnnTensorDescriptor_t , cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnInitTransformDest");
		tracer._kernel_map[(void *) lcudnnInitTransformDest] = std::string("cudnnInitTransformDest");
	}
	assert(lcudnnInitTransformDest);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnInitTransformDest(transformDesc, srcDesc, destDesc, destSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnInitTransformDest);
	}
	return res;
}

cudnnStatus_t cudnnCreateTensorTransformDescriptor(cudnnTensorTransformDescriptor_t * transformDesc)
{
	static cudnnStatus_t (*lcudnnCreateTensorTransformDescriptor) (cudnnTensorTransformDescriptor_t *);
	if (!lcudnnCreateTensorTransformDescriptor) {
		lcudnnCreateTensorTransformDescriptor = (cudnnStatus_t (*) (cudnnTensorTransformDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateTensorTransformDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateTensorTransformDescriptor] = std::string("cudnnCreateTensorTransformDescriptor");
	}
	assert(lcudnnCreateTensorTransformDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateTensorTransformDescriptor(transformDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateTensorTransformDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetTensorTransformDescriptor(cudnnTensorTransformDescriptor_t  transformDesc, const uint32_t  nbDims, const cudnnTensorFormat_t  destFormat, const int32_t  padBeforeA[], const int32_t  padAfterA[], const uint32_t  foldA[], const cudnnFoldingDirection_t  direction)
{
	static cudnnStatus_t (*lcudnnSetTensorTransformDescriptor) (cudnnTensorTransformDescriptor_t , const uint32_t , const cudnnTensorFormat_t , const int32_t [], const int32_t [], const uint32_t [], const cudnnFoldingDirection_t );
	if (!lcudnnSetTensorTransformDescriptor) {
		lcudnnSetTensorTransformDescriptor = (cudnnStatus_t (*) (cudnnTensorTransformDescriptor_t , const uint32_t , const cudnnTensorFormat_t , const int32_t [], const int32_t [], const uint32_t [], const cudnnFoldingDirection_t )) dlsym(tracer.cudnn_handle, "cudnnSetTensorTransformDescriptor");
		tracer._kernel_map[(void *) lcudnnSetTensorTransformDescriptor] = std::string("cudnnSetTensorTransformDescriptor");
	}
	assert(lcudnnSetTensorTransformDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetTensorTransformDescriptor(transformDesc, nbDims, destFormat, padBeforeA, padAfterA, foldA, direction);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetTensorTransformDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetTensorTransformDescriptor(cudnnTensorTransformDescriptor_t  transformDesc, uint32_t  nbDimsRequested, cudnnTensorFormat_t * destFormat, int32_t  padBeforeA[], int32_t  padAfterA[], uint32_t  foldA[], cudnnFoldingDirection_t * direction)
{
	static cudnnStatus_t (*lcudnnGetTensorTransformDescriptor) (cudnnTensorTransformDescriptor_t , uint32_t , cudnnTensorFormat_t *, int32_t [], int32_t [], uint32_t [], cudnnFoldingDirection_t *);
	if (!lcudnnGetTensorTransformDescriptor) {
		lcudnnGetTensorTransformDescriptor = (cudnnStatus_t (*) (cudnnTensorTransformDescriptor_t , uint32_t , cudnnTensorFormat_t *, int32_t [], int32_t [], uint32_t [], cudnnFoldingDirection_t *)) dlsym(tracer.cudnn_handle, "cudnnGetTensorTransformDescriptor");
		tracer._kernel_map[(void *) lcudnnGetTensorTransformDescriptor] = std::string("cudnnGetTensorTransformDescriptor");
	}
	assert(lcudnnGetTensorTransformDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetTensorTransformDescriptor(transformDesc, nbDimsRequested, destFormat, padBeforeA, padAfterA, foldA, direction);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetTensorTransformDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyTensorTransformDescriptor(cudnnTensorTransformDescriptor_t  transformDesc)
{
	static cudnnStatus_t (*lcudnnDestroyTensorTransformDescriptor) (cudnnTensorTransformDescriptor_t );
	if (!lcudnnDestroyTensorTransformDescriptor) {
		lcudnnDestroyTensorTransformDescriptor = (cudnnStatus_t (*) (cudnnTensorTransformDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyTensorTransformDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyTensorTransformDescriptor] = std::string("cudnnDestroyTensorTransformDescriptor");
	}
	assert(lcudnnDestroyTensorTransformDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyTensorTransformDescriptor(transformDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyTensorTransformDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnTransformTensor(cudnnHandle_t  handle, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnTransformTensor) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnTransformTensor) {
		lcudnnTransformTensor = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnTransformTensor");
		tracer._kernel_map[(void *) lcudnnTransformTensor] = std::string("cudnnTransformTensor");
	}
	assert(lcudnnTransformTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnTransformTensor(handle, alpha, xDesc, x, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnTransformTensor);
	}
	return res;
}

cudnnStatus_t cudnnTransformTensorEx(cudnnHandle_t  handle, const cudnnTensorTransformDescriptor_t  transDesc, const void * alpha, const cudnnTensorDescriptor_t  srcDesc, const void * srcData, const void * beta, const cudnnTensorDescriptor_t  destDesc, void * destData)
{
	static cudnnStatus_t (*lcudnnTransformTensorEx) (cudnnHandle_t , const cudnnTensorTransformDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnTransformTensorEx) {
		lcudnnTransformTensorEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorTransformDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnTransformTensorEx");
		tracer._kernel_map[(void *) lcudnnTransformTensorEx] = std::string("cudnnTransformTensorEx");
	}
	assert(lcudnnTransformTensorEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnTransformTensorEx(handle, transDesc, alpha, srcDesc, srcData, beta, destDesc, destData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnTransformTensorEx);
	}
	return res;
}

cudnnStatus_t cudnnAddTensor(cudnnHandle_t  handle, const void * alpha, const cudnnTensorDescriptor_t  aDesc, const void * A, const void * beta, const cudnnTensorDescriptor_t  cDesc, void * C)
{
	static cudnnStatus_t (*lcudnnAddTensor) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnAddTensor) {
		lcudnnAddTensor = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnAddTensor");
		tracer._kernel_map[(void *) lcudnnAddTensor] = std::string("cudnnAddTensor");
	}
	assert(lcudnnAddTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnAddTensor(handle, alpha, aDesc, A, beta, cDesc, C);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnAddTensor);
	}
	return res;
}

cudnnStatus_t cudnnCreateOpTensorDescriptor(cudnnOpTensorDescriptor_t * opTensorDesc)
{
	static cudnnStatus_t (*lcudnnCreateOpTensorDescriptor) (cudnnOpTensorDescriptor_t *);
	if (!lcudnnCreateOpTensorDescriptor) {
		lcudnnCreateOpTensorDescriptor = (cudnnStatus_t (*) (cudnnOpTensorDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateOpTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateOpTensorDescriptor] = std::string("cudnnCreateOpTensorDescriptor");
	}
	assert(lcudnnCreateOpTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateOpTensorDescriptor(opTensorDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateOpTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetOpTensorDescriptor(cudnnOpTensorDescriptor_t  opTensorDesc, cudnnOpTensorOp_t  opTensorOp, cudnnDataType_t  opTensorCompType, cudnnNanPropagation_t  opTensorNanOpt)
{
	static cudnnStatus_t (*lcudnnSetOpTensorDescriptor) (cudnnOpTensorDescriptor_t , cudnnOpTensorOp_t , cudnnDataType_t , cudnnNanPropagation_t );
	if (!lcudnnSetOpTensorDescriptor) {
		lcudnnSetOpTensorDescriptor = (cudnnStatus_t (*) (cudnnOpTensorDescriptor_t , cudnnOpTensorOp_t , cudnnDataType_t , cudnnNanPropagation_t )) dlsym(tracer.cudnn_handle, "cudnnSetOpTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnSetOpTensorDescriptor] = std::string("cudnnSetOpTensorDescriptor");
	}
	assert(lcudnnSetOpTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetOpTensorDescriptor(opTensorDesc, opTensorOp, opTensorCompType, opTensorNanOpt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetOpTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetOpTensorDescriptor(const cudnnOpTensorDescriptor_t  opTensorDesc, cudnnOpTensorOp_t * opTensorOp, cudnnDataType_t * opTensorCompType, cudnnNanPropagation_t * opTensorNanOpt)
{
	static cudnnStatus_t (*lcudnnGetOpTensorDescriptor) (const cudnnOpTensorDescriptor_t , cudnnOpTensorOp_t *, cudnnDataType_t *, cudnnNanPropagation_t *);
	if (!lcudnnGetOpTensorDescriptor) {
		lcudnnGetOpTensorDescriptor = (cudnnStatus_t (*) (const cudnnOpTensorDescriptor_t , cudnnOpTensorOp_t *, cudnnDataType_t *, cudnnNanPropagation_t *)) dlsym(tracer.cudnn_handle, "cudnnGetOpTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnGetOpTensorDescriptor] = std::string("cudnnGetOpTensorDescriptor");
	}
	assert(lcudnnGetOpTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetOpTensorDescriptor(opTensorDesc, opTensorOp, opTensorCompType, opTensorNanOpt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetOpTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyOpTensorDescriptor(cudnnOpTensorDescriptor_t  opTensorDesc)
{
	static cudnnStatus_t (*lcudnnDestroyOpTensorDescriptor) (cudnnOpTensorDescriptor_t );
	if (!lcudnnDestroyOpTensorDescriptor) {
		lcudnnDestroyOpTensorDescriptor = (cudnnStatus_t (*) (cudnnOpTensorDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyOpTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyOpTensorDescriptor] = std::string("cudnnDestroyOpTensorDescriptor");
	}
	assert(lcudnnDestroyOpTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyOpTensorDescriptor(opTensorDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyOpTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnOpTensor(cudnnHandle_t  handle, const cudnnOpTensorDescriptor_t  opTensorDesc, const void * alpha1, const cudnnTensorDescriptor_t  aDesc, const void * A, const void * alpha2, const cudnnTensorDescriptor_t  bDesc, const void * B, const void * beta, const cudnnTensorDescriptor_t  cDesc, void * C)
{
	static cudnnStatus_t (*lcudnnOpTensor) (cudnnHandle_t , const cudnnOpTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnOpTensor) {
		lcudnnOpTensor = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnOpTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnOpTensor");
		tracer._kernel_map[(void *) lcudnnOpTensor] = std::string("cudnnOpTensor");
	}
	assert(lcudnnOpTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnOpTensor(handle, opTensorDesc, alpha1, aDesc, A, alpha2, bDesc, B, beta, cDesc, C);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnOpTensor);
	}
	return res;
}

cudnnStatus_t cudnnCreateReduceTensorDescriptor(cudnnReduceTensorDescriptor_t * reduceTensorDesc)
{
	static cudnnStatus_t (*lcudnnCreateReduceTensorDescriptor) (cudnnReduceTensorDescriptor_t *);
	if (!lcudnnCreateReduceTensorDescriptor) {
		lcudnnCreateReduceTensorDescriptor = (cudnnStatus_t (*) (cudnnReduceTensorDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateReduceTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateReduceTensorDescriptor] = std::string("cudnnCreateReduceTensorDescriptor");
	}
	assert(lcudnnCreateReduceTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateReduceTensorDescriptor(reduceTensorDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateReduceTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetReduceTensorDescriptor(cudnnReduceTensorDescriptor_t  reduceTensorDesc, cudnnReduceTensorOp_t  reduceTensorOp, cudnnDataType_t  reduceTensorCompType, cudnnNanPropagation_t  reduceTensorNanOpt, cudnnReduceTensorIndices_t  reduceTensorIndices, cudnnIndicesType_t  reduceTensorIndicesType)
{
	static cudnnStatus_t (*lcudnnSetReduceTensorDescriptor) (cudnnReduceTensorDescriptor_t , cudnnReduceTensorOp_t , cudnnDataType_t , cudnnNanPropagation_t , cudnnReduceTensorIndices_t , cudnnIndicesType_t );
	if (!lcudnnSetReduceTensorDescriptor) {
		lcudnnSetReduceTensorDescriptor = (cudnnStatus_t (*) (cudnnReduceTensorDescriptor_t , cudnnReduceTensorOp_t , cudnnDataType_t , cudnnNanPropagation_t , cudnnReduceTensorIndices_t , cudnnIndicesType_t )) dlsym(tracer.cudnn_handle, "cudnnSetReduceTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnSetReduceTensorDescriptor] = std::string("cudnnSetReduceTensorDescriptor");
	}
	assert(lcudnnSetReduceTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetReduceTensorDescriptor(reduceTensorDesc, reduceTensorOp, reduceTensorCompType, reduceTensorNanOpt, reduceTensorIndices, reduceTensorIndicesType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetReduceTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetReduceTensorDescriptor(const cudnnReduceTensorDescriptor_t  reduceTensorDesc, cudnnReduceTensorOp_t * reduceTensorOp, cudnnDataType_t * reduceTensorCompType, cudnnNanPropagation_t * reduceTensorNanOpt, cudnnReduceTensorIndices_t * reduceTensorIndices, cudnnIndicesType_t * reduceTensorIndicesType)
{
	static cudnnStatus_t (*lcudnnGetReduceTensorDescriptor) (const cudnnReduceTensorDescriptor_t , cudnnReduceTensorOp_t *, cudnnDataType_t *, cudnnNanPropagation_t *, cudnnReduceTensorIndices_t *, cudnnIndicesType_t *);
	if (!lcudnnGetReduceTensorDescriptor) {
		lcudnnGetReduceTensorDescriptor = (cudnnStatus_t (*) (const cudnnReduceTensorDescriptor_t , cudnnReduceTensorOp_t *, cudnnDataType_t *, cudnnNanPropagation_t *, cudnnReduceTensorIndices_t *, cudnnIndicesType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetReduceTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnGetReduceTensorDescriptor] = std::string("cudnnGetReduceTensorDescriptor");
	}
	assert(lcudnnGetReduceTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetReduceTensorDescriptor(reduceTensorDesc, reduceTensorOp, reduceTensorCompType, reduceTensorNanOpt, reduceTensorIndices, reduceTensorIndicesType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetReduceTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyReduceTensorDescriptor(cudnnReduceTensorDescriptor_t  reduceTensorDesc)
{
	static cudnnStatus_t (*lcudnnDestroyReduceTensorDescriptor) (cudnnReduceTensorDescriptor_t );
	if (!lcudnnDestroyReduceTensorDescriptor) {
		lcudnnDestroyReduceTensorDescriptor = (cudnnStatus_t (*) (cudnnReduceTensorDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyReduceTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyReduceTensorDescriptor] = std::string("cudnnDestroyReduceTensorDescriptor");
	}
	assert(lcudnnDestroyReduceTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyReduceTensorDescriptor(reduceTensorDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyReduceTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetReductionIndicesSize(cudnnHandle_t  handle, const cudnnReduceTensorDescriptor_t  reduceTensorDesc, const cudnnTensorDescriptor_t  aDesc, const cudnnTensorDescriptor_t  cDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetReductionIndicesSize) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnGetReductionIndicesSize) {
		lcudnnGetReductionIndicesSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetReductionIndicesSize");
		tracer._kernel_map[(void *) lcudnnGetReductionIndicesSize] = std::string("cudnnGetReductionIndicesSize");
	}
	assert(lcudnnGetReductionIndicesSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetReductionIndicesSize(handle, reduceTensorDesc, aDesc, cDesc, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetReductionIndicesSize);
	}
	return res;
}

cudnnStatus_t cudnnGetReductionWorkspaceSize(cudnnHandle_t  handle, const cudnnReduceTensorDescriptor_t  reduceTensorDesc, const cudnnTensorDescriptor_t  aDesc, const cudnnTensorDescriptor_t  cDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetReductionWorkspaceSize) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnGetReductionWorkspaceSize) {
		lcudnnGetReductionWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetReductionWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetReductionWorkspaceSize] = std::string("cudnnGetReductionWorkspaceSize");
	}
	assert(lcudnnGetReductionWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetReductionWorkspaceSize(handle, reduceTensorDesc, aDesc, cDesc, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetReductionWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnReduceTensor(cudnnHandle_t  handle, const cudnnReduceTensorDescriptor_t  reduceTensorDesc, void * indices, size_t  indicesSizeInBytes, void * workspace, size_t  workspaceSizeInBytes, const void * alpha, const cudnnTensorDescriptor_t  aDesc, const void * A, const void * beta, const cudnnTensorDescriptor_t  cDesc, void * C)
{
	static cudnnStatus_t (*lcudnnReduceTensor) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , void *, size_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnReduceTensor) {
		lcudnnReduceTensor = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnReduceTensorDescriptor_t , void *, size_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnReduceTensor");
		tracer._kernel_map[(void *) lcudnnReduceTensor] = std::string("cudnnReduceTensor");
	}
	assert(lcudnnReduceTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnReduceTensor(handle, reduceTensorDesc, indices, indicesSizeInBytes, workspace, workspaceSizeInBytes, alpha, aDesc, A, beta, cDesc, C);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnReduceTensor);
	}
	return res;
}

cudnnStatus_t cudnnSetTensor(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  yDesc, void * y, const void * valuePtr)
{
	static cudnnStatus_t (*lcudnnSetTensor) (cudnnHandle_t , const cudnnTensorDescriptor_t , void *, const void *);
	if (!lcudnnSetTensor) {
		lcudnnSetTensor = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , void *, const void *)) dlsym(tracer.cudnn_handle, "cudnnSetTensor");
		tracer._kernel_map[(void *) lcudnnSetTensor] = std::string("cudnnSetTensor");
	}
	assert(lcudnnSetTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetTensor(handle, yDesc, y, valuePtr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetTensor);
	}
	return res;
}

cudnnStatus_t cudnnScaleTensor(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  yDesc, void * y, const void * alpha)
{
	static cudnnStatus_t (*lcudnnScaleTensor) (cudnnHandle_t , const cudnnTensorDescriptor_t , void *, const void *);
	if (!lcudnnScaleTensor) {
		lcudnnScaleTensor = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , void *, const void *)) dlsym(tracer.cudnn_handle, "cudnnScaleTensor");
		tracer._kernel_map[(void *) lcudnnScaleTensor] = std::string("cudnnScaleTensor");
	}
	assert(lcudnnScaleTensor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnScaleTensor(handle, yDesc, y, alpha);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnScaleTensor);
	}
	return res;
}

cudnnStatus_t cudnnCreateFilterDescriptor(cudnnFilterDescriptor_t * filterDesc)
{
	static cudnnStatus_t (*lcudnnCreateFilterDescriptor) (cudnnFilterDescriptor_t *);
	if (!lcudnnCreateFilterDescriptor) {
		lcudnnCreateFilterDescriptor = (cudnnStatus_t (*) (cudnnFilterDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateFilterDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateFilterDescriptor] = std::string("cudnnCreateFilterDescriptor");
	}
	assert(lcudnnCreateFilterDescriptor);
	cudnnStatus_t res = 
		lcudnnCreateFilterDescriptor(filterDesc);
	return res;
}

cudnnStatus_t cudnnSetFilter4dDescriptor(cudnnFilterDescriptor_t  filterDesc, cudnnDataType_t  dataType, cudnnTensorFormat_t  format, int  k, int  c, int  h, int  w)
{
	static cudnnStatus_t (*lcudnnSetFilter4dDescriptor) (cudnnFilterDescriptor_t , cudnnDataType_t , cudnnTensorFormat_t , int , int , int , int );
	if (!lcudnnSetFilter4dDescriptor) {
		lcudnnSetFilter4dDescriptor = (cudnnStatus_t (*) (cudnnFilterDescriptor_t , cudnnDataType_t , cudnnTensorFormat_t , int , int , int , int )) dlsym(tracer.cudnn_handle, "cudnnSetFilter4dDescriptor");
		tracer._kernel_map[(void *) lcudnnSetFilter4dDescriptor] = std::string("cudnnSetFilter4dDescriptor");
	}
	assert(lcudnnSetFilter4dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetFilter4dDescriptor(filterDesc, dataType, format, k, c, h, w);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetFilter4dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetFilter4dDescriptor(const cudnnFilterDescriptor_t  filterDesc, cudnnDataType_t * dataType, cudnnTensorFormat_t * format, int * k, int * c, int * h, int * w)
{
	static cudnnStatus_t (*lcudnnGetFilter4dDescriptor) (const cudnnFilterDescriptor_t , cudnnDataType_t *, cudnnTensorFormat_t *, int *, int *, int *, int *);
	if (!lcudnnGetFilter4dDescriptor) {
		lcudnnGetFilter4dDescriptor = (cudnnStatus_t (*) (const cudnnFilterDescriptor_t , cudnnDataType_t *, cudnnTensorFormat_t *, int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetFilter4dDescriptor");
		tracer._kernel_map[(void *) lcudnnGetFilter4dDescriptor] = std::string("cudnnGetFilter4dDescriptor");
	}
	assert(lcudnnGetFilter4dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFilter4dDescriptor(filterDesc, dataType, format, k, c, h, w);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFilter4dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetFilterNdDescriptor(cudnnFilterDescriptor_t  filterDesc, cudnnDataType_t  dataType, cudnnTensorFormat_t  format, int  nbDims, const int  filterDimA[])
{
	static cudnnStatus_t (*lcudnnSetFilterNdDescriptor) (cudnnFilterDescriptor_t , cudnnDataType_t , cudnnTensorFormat_t , int , const int []);
	if (!lcudnnSetFilterNdDescriptor) {
		lcudnnSetFilterNdDescriptor = (cudnnStatus_t (*) (cudnnFilterDescriptor_t , cudnnDataType_t , cudnnTensorFormat_t , int , const int [])) dlsym(tracer.cudnn_handle, "cudnnSetFilterNdDescriptor");
		tracer._kernel_map[(void *) lcudnnSetFilterNdDescriptor] = std::string("cudnnSetFilterNdDescriptor");
	}
	assert(lcudnnSetFilterNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetFilterNdDescriptor(filterDesc, dataType, format, nbDims, filterDimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetFilterNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetFilterNdDescriptor(const cudnnFilterDescriptor_t  filterDesc, int  nbDimsRequested, cudnnDataType_t * dataType, cudnnTensorFormat_t * format, int * nbDims, int  filterDimA[])
{
	static cudnnStatus_t (*lcudnnGetFilterNdDescriptor) (const cudnnFilterDescriptor_t , int , cudnnDataType_t *, cudnnTensorFormat_t *, int *, int []);
	if (!lcudnnGetFilterNdDescriptor) {
		lcudnnGetFilterNdDescriptor = (cudnnStatus_t (*) (const cudnnFilterDescriptor_t , int , cudnnDataType_t *, cudnnTensorFormat_t *, int *, int [])) dlsym(tracer.cudnn_handle, "cudnnGetFilterNdDescriptor");
		tracer._kernel_map[(void *) lcudnnGetFilterNdDescriptor] = std::string("cudnnGetFilterNdDescriptor");
	}
	assert(lcudnnGetFilterNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFilterNdDescriptor(filterDesc, nbDimsRequested, dataType, format, nbDims, filterDimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFilterNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetFilterSizeInBytes(const cudnnFilterDescriptor_t  filterDesc, size_t * size)
{
	static cudnnStatus_t (*lcudnnGetFilterSizeInBytes) (const cudnnFilterDescriptor_t , size_t *);
	if (!lcudnnGetFilterSizeInBytes) {
		lcudnnGetFilterSizeInBytes = (cudnnStatus_t (*) (const cudnnFilterDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetFilterSizeInBytes");
		tracer._kernel_map[(void *) lcudnnGetFilterSizeInBytes] = std::string("cudnnGetFilterSizeInBytes");
	}
	assert(lcudnnGetFilterSizeInBytes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFilterSizeInBytes(filterDesc, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFilterSizeInBytes);
	}
	return res;
}

cudnnStatus_t cudnnTransformFilter(cudnnHandle_t  handle, const cudnnTensorTransformDescriptor_t  transDesc, const void * alpha, const cudnnFilterDescriptor_t  srcDesc, const void * srcData, const void * beta, const cudnnFilterDescriptor_t  destDesc, void * destData)
{
	static cudnnStatus_t (*lcudnnTransformFilter) (cudnnHandle_t , const cudnnTensorTransformDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const void *, const cudnnFilterDescriptor_t , void *);
	if (!lcudnnTransformFilter) {
		lcudnnTransformFilter = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorTransformDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const void *, const cudnnFilterDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnTransformFilter");
		tracer._kernel_map[(void *) lcudnnTransformFilter] = std::string("cudnnTransformFilter");
	}
	assert(lcudnnTransformFilter);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnTransformFilter(handle, transDesc, alpha, srcDesc, srcData, beta, destDesc, destData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnTransformFilter);
	}
	return res;
}

cudnnStatus_t cudnnDestroyFilterDescriptor(cudnnFilterDescriptor_t  filterDesc)
{
	static cudnnStatus_t (*lcudnnDestroyFilterDescriptor) (cudnnFilterDescriptor_t );
	if (!lcudnnDestroyFilterDescriptor) {
		lcudnnDestroyFilterDescriptor = (cudnnStatus_t (*) (cudnnFilterDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyFilterDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyFilterDescriptor] = std::string("cudnnDestroyFilterDescriptor");
	}
	assert(lcudnnDestroyFilterDescriptor);
	cudnnStatus_t res = 
		lcudnnDestroyFilterDescriptor(filterDesc);
	return res;
}

cudnnStatus_t cudnnSoftmaxForward(cudnnHandle_t  handle, cudnnSoftmaxAlgorithm_t  algo, cudnnSoftmaxMode_t  mode, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnSoftmaxForward) (cudnnHandle_t , cudnnSoftmaxAlgorithm_t , cudnnSoftmaxMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnSoftmaxForward) {
		lcudnnSoftmaxForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnSoftmaxAlgorithm_t , cudnnSoftmaxMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnSoftmaxForward");
		tracer._kernel_map[(void *) lcudnnSoftmaxForward] = std::string("cudnnSoftmaxForward");
	}
	assert(lcudnnSoftmaxForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSoftmaxForward(handle, algo, mode, alpha, xDesc, x, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSoftmaxForward);
	}
	return res;
}

cudnnStatus_t cudnnCreatePoolingDescriptor(cudnnPoolingDescriptor_t * poolingDesc)
{
	static cudnnStatus_t (*lcudnnCreatePoolingDescriptor) (cudnnPoolingDescriptor_t *);
	if (!lcudnnCreatePoolingDescriptor) {
		lcudnnCreatePoolingDescriptor = (cudnnStatus_t (*) (cudnnPoolingDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreatePoolingDescriptor");
		tracer._kernel_map[(void *) lcudnnCreatePoolingDescriptor] = std::string("cudnnCreatePoolingDescriptor");
	}
	assert(lcudnnCreatePoolingDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreatePoolingDescriptor(poolingDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreatePoolingDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetPooling2dDescriptor(cudnnPoolingDescriptor_t  poolingDesc, cudnnPoolingMode_t  mode, cudnnNanPropagation_t  maxpoolingNanOpt, int  windowHeight, int  windowWidth, int  verticalPadding, int  horizontalPadding, int  verticalStride, int  horizontalStride)
{
	static cudnnStatus_t (*lcudnnSetPooling2dDescriptor) (cudnnPoolingDescriptor_t , cudnnPoolingMode_t , cudnnNanPropagation_t , int , int , int , int , int , int );
	if (!lcudnnSetPooling2dDescriptor) {
		lcudnnSetPooling2dDescriptor = (cudnnStatus_t (*) (cudnnPoolingDescriptor_t , cudnnPoolingMode_t , cudnnNanPropagation_t , int , int , int , int , int , int )) dlsym(tracer.cudnn_handle, "cudnnSetPooling2dDescriptor");
		tracer._kernel_map[(void *) lcudnnSetPooling2dDescriptor] = std::string("cudnnSetPooling2dDescriptor");
	}
	assert(lcudnnSetPooling2dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetPooling2dDescriptor(poolingDesc, mode, maxpoolingNanOpt, windowHeight, windowWidth, verticalPadding, horizontalPadding, verticalStride, horizontalStride);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetPooling2dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetPooling2dDescriptor(const cudnnPoolingDescriptor_t  poolingDesc, cudnnPoolingMode_t * mode, cudnnNanPropagation_t * maxpoolingNanOpt, int * windowHeight, int * windowWidth, int * verticalPadding, int * horizontalPadding, int * verticalStride, int * horizontalStride)
{
	static cudnnStatus_t (*lcudnnGetPooling2dDescriptor) (const cudnnPoolingDescriptor_t , cudnnPoolingMode_t *, cudnnNanPropagation_t *, int *, int *, int *, int *, int *, int *);
	if (!lcudnnGetPooling2dDescriptor) {
		lcudnnGetPooling2dDescriptor = (cudnnStatus_t (*) (const cudnnPoolingDescriptor_t , cudnnPoolingMode_t *, cudnnNanPropagation_t *, int *, int *, int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetPooling2dDescriptor");
		tracer._kernel_map[(void *) lcudnnGetPooling2dDescriptor] = std::string("cudnnGetPooling2dDescriptor");
	}
	assert(lcudnnGetPooling2dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetPooling2dDescriptor(poolingDesc, mode, maxpoolingNanOpt, windowHeight, windowWidth, verticalPadding, horizontalPadding, verticalStride, horizontalStride);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetPooling2dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetPoolingNdDescriptor(cudnnPoolingDescriptor_t  poolingDesc, const cudnnPoolingMode_t  mode, const cudnnNanPropagation_t  maxpoolingNanOpt, int  nbDims, const int  windowDimA[], const int  paddingA[], const int  strideA[])
{
	static cudnnStatus_t (*lcudnnSetPoolingNdDescriptor) (cudnnPoolingDescriptor_t , const cudnnPoolingMode_t , const cudnnNanPropagation_t , int , const int [], const int [], const int []);
	if (!lcudnnSetPoolingNdDescriptor) {
		lcudnnSetPoolingNdDescriptor = (cudnnStatus_t (*) (cudnnPoolingDescriptor_t , const cudnnPoolingMode_t , const cudnnNanPropagation_t , int , const int [], const int [], const int [])) dlsym(tracer.cudnn_handle, "cudnnSetPoolingNdDescriptor");
		tracer._kernel_map[(void *) lcudnnSetPoolingNdDescriptor] = std::string("cudnnSetPoolingNdDescriptor");
	}
	assert(lcudnnSetPoolingNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetPoolingNdDescriptor(poolingDesc, mode, maxpoolingNanOpt, nbDims, windowDimA, paddingA, strideA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetPoolingNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetPoolingNdDescriptor(const cudnnPoolingDescriptor_t  poolingDesc, int  nbDimsRequested, cudnnPoolingMode_t * mode, cudnnNanPropagation_t * maxpoolingNanOpt, int * nbDims, int  windowDimA[], int  paddingA[], int  strideA[])
{
	static cudnnStatus_t (*lcudnnGetPoolingNdDescriptor) (const cudnnPoolingDescriptor_t , int , cudnnPoolingMode_t *, cudnnNanPropagation_t *, int *, int [], int [], int []);
	if (!lcudnnGetPoolingNdDescriptor) {
		lcudnnGetPoolingNdDescriptor = (cudnnStatus_t (*) (const cudnnPoolingDescriptor_t , int , cudnnPoolingMode_t *, cudnnNanPropagation_t *, int *, int [], int [], int [])) dlsym(tracer.cudnn_handle, "cudnnGetPoolingNdDescriptor");
		tracer._kernel_map[(void *) lcudnnGetPoolingNdDescriptor] = std::string("cudnnGetPoolingNdDescriptor");
	}
	assert(lcudnnGetPoolingNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetPoolingNdDescriptor(poolingDesc, nbDimsRequested, mode, maxpoolingNanOpt, nbDims, windowDimA, paddingA, strideA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetPoolingNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetPoolingNdForwardOutputDim(const cudnnPoolingDescriptor_t  poolingDesc, const cudnnTensorDescriptor_t  inputTensorDesc, int  nbDims, int  outputTensorDimA[])
{
	static cudnnStatus_t (*lcudnnGetPoolingNdForwardOutputDim) (const cudnnPoolingDescriptor_t , const cudnnTensorDescriptor_t , int , int []);
	if (!lcudnnGetPoolingNdForwardOutputDim) {
		lcudnnGetPoolingNdForwardOutputDim = (cudnnStatus_t (*) (const cudnnPoolingDescriptor_t , const cudnnTensorDescriptor_t , int , int [])) dlsym(tracer.cudnn_handle, "cudnnGetPoolingNdForwardOutputDim");
		tracer._kernel_map[(void *) lcudnnGetPoolingNdForwardOutputDim] = std::string("cudnnGetPoolingNdForwardOutputDim");
	}
	assert(lcudnnGetPoolingNdForwardOutputDim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetPoolingNdForwardOutputDim(poolingDesc, inputTensorDesc, nbDims, outputTensorDimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetPoolingNdForwardOutputDim);
	}
	return res;
}

cudnnStatus_t cudnnGetPooling2dForwardOutputDim(const cudnnPoolingDescriptor_t  poolingDesc, const cudnnTensorDescriptor_t  inputTensorDesc, int * n, int * c, int * h, int * w)
{
	static cudnnStatus_t (*lcudnnGetPooling2dForwardOutputDim) (const cudnnPoolingDescriptor_t , const cudnnTensorDescriptor_t , int *, int *, int *, int *);
	if (!lcudnnGetPooling2dForwardOutputDim) {
		lcudnnGetPooling2dForwardOutputDim = (cudnnStatus_t (*) (const cudnnPoolingDescriptor_t , const cudnnTensorDescriptor_t , int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetPooling2dForwardOutputDim");
		tracer._kernel_map[(void *) lcudnnGetPooling2dForwardOutputDim] = std::string("cudnnGetPooling2dForwardOutputDim");
	}
	assert(lcudnnGetPooling2dForwardOutputDim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetPooling2dForwardOutputDim(poolingDesc, inputTensorDesc, n, c, h, w);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetPooling2dForwardOutputDim);
	}
	return res;
}

cudnnStatus_t cudnnDestroyPoolingDescriptor(cudnnPoolingDescriptor_t  poolingDesc)
{
	static cudnnStatus_t (*lcudnnDestroyPoolingDescriptor) (cudnnPoolingDescriptor_t );
	if (!lcudnnDestroyPoolingDescriptor) {
		lcudnnDestroyPoolingDescriptor = (cudnnStatus_t (*) (cudnnPoolingDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyPoolingDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyPoolingDescriptor] = std::string("cudnnDestroyPoolingDescriptor");
	}
	assert(lcudnnDestroyPoolingDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyPoolingDescriptor(poolingDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyPoolingDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnPoolingForward(cudnnHandle_t  handle, const cudnnPoolingDescriptor_t  poolingDesc, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnPoolingForward) (cudnnHandle_t , const cudnnPoolingDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnPoolingForward) {
		lcudnnPoolingForward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnPoolingDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnPoolingForward");
		tracer._kernel_map[(void *) lcudnnPoolingForward] = std::string("cudnnPoolingForward");
	}
	assert(lcudnnPoolingForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnPoolingForward(handle, poolingDesc, alpha, xDesc, x, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnPoolingForward);
	}
	return res;
}

cudnnStatus_t cudnnCreateActivationDescriptor(cudnnActivationDescriptor_t * activationDesc)
{
	static cudnnStatus_t (*lcudnnCreateActivationDescriptor) (cudnnActivationDescriptor_t *);
	if (!lcudnnCreateActivationDescriptor) {
		lcudnnCreateActivationDescriptor = (cudnnStatus_t (*) (cudnnActivationDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateActivationDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateActivationDescriptor] = std::string("cudnnCreateActivationDescriptor");
	}
	assert(lcudnnCreateActivationDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateActivationDescriptor(activationDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateActivationDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetActivationDescriptor(cudnnActivationDescriptor_t  activationDesc, cudnnActivationMode_t  mode, cudnnNanPropagation_t  reluNanOpt, double  coef)
{
	static cudnnStatus_t (*lcudnnSetActivationDescriptor) (cudnnActivationDescriptor_t , cudnnActivationMode_t , cudnnNanPropagation_t , double );
	if (!lcudnnSetActivationDescriptor) {
		lcudnnSetActivationDescriptor = (cudnnStatus_t (*) (cudnnActivationDescriptor_t , cudnnActivationMode_t , cudnnNanPropagation_t , double )) dlsym(tracer.cudnn_handle, "cudnnSetActivationDescriptor");
		tracer._kernel_map[(void *) lcudnnSetActivationDescriptor] = std::string("cudnnSetActivationDescriptor");
	}
	assert(lcudnnSetActivationDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetActivationDescriptor(activationDesc, mode, reluNanOpt, coef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetActivationDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetActivationDescriptor(const cudnnActivationDescriptor_t  activationDesc, cudnnActivationMode_t * mode, cudnnNanPropagation_t * reluNanOpt, double * coef)
{
	static cudnnStatus_t (*lcudnnGetActivationDescriptor) (const cudnnActivationDescriptor_t , cudnnActivationMode_t *, cudnnNanPropagation_t *, double *);
	if (!lcudnnGetActivationDescriptor) {
		lcudnnGetActivationDescriptor = (cudnnStatus_t (*) (const cudnnActivationDescriptor_t , cudnnActivationMode_t *, cudnnNanPropagation_t *, double *)) dlsym(tracer.cudnn_handle, "cudnnGetActivationDescriptor");
		tracer._kernel_map[(void *) lcudnnGetActivationDescriptor] = std::string("cudnnGetActivationDescriptor");
	}
	assert(lcudnnGetActivationDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetActivationDescriptor(activationDesc, mode, reluNanOpt, coef);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetActivationDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetActivationDescriptorSwishBeta(cudnnActivationDescriptor_t  activationDesc, double  swish_beta)
{
	static cudnnStatus_t (*lcudnnSetActivationDescriptorSwishBeta) (cudnnActivationDescriptor_t , double );
	if (!lcudnnSetActivationDescriptorSwishBeta) {
		lcudnnSetActivationDescriptorSwishBeta = (cudnnStatus_t (*) (cudnnActivationDescriptor_t , double )) dlsym(tracer.cudnn_handle, "cudnnSetActivationDescriptorSwishBeta");
		tracer._kernel_map[(void *) lcudnnSetActivationDescriptorSwishBeta] = std::string("cudnnSetActivationDescriptorSwishBeta");
	}
	assert(lcudnnSetActivationDescriptorSwishBeta);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetActivationDescriptorSwishBeta(activationDesc, swish_beta);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetActivationDescriptorSwishBeta);
	}
	return res;
}

cudnnStatus_t cudnnGetActivationDescriptorSwishBeta(cudnnActivationDescriptor_t  activationDesc, double * swish_beta)
{
	static cudnnStatus_t (*lcudnnGetActivationDescriptorSwishBeta) (cudnnActivationDescriptor_t , double *);
	if (!lcudnnGetActivationDescriptorSwishBeta) {
		lcudnnGetActivationDescriptorSwishBeta = (cudnnStatus_t (*) (cudnnActivationDescriptor_t , double *)) dlsym(tracer.cudnn_handle, "cudnnGetActivationDescriptorSwishBeta");
		tracer._kernel_map[(void *) lcudnnGetActivationDescriptorSwishBeta] = std::string("cudnnGetActivationDescriptorSwishBeta");
	}
	assert(lcudnnGetActivationDescriptorSwishBeta);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetActivationDescriptorSwishBeta(activationDesc, swish_beta);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetActivationDescriptorSwishBeta);
	}
	return res;
}

cudnnStatus_t cudnnDestroyActivationDescriptor(cudnnActivationDescriptor_t  activationDesc)
{
	static cudnnStatus_t (*lcudnnDestroyActivationDescriptor) (cudnnActivationDescriptor_t );
	if (!lcudnnDestroyActivationDescriptor) {
		lcudnnDestroyActivationDescriptor = (cudnnStatus_t (*) (cudnnActivationDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyActivationDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyActivationDescriptor] = std::string("cudnnDestroyActivationDescriptor");
	}
	assert(lcudnnDestroyActivationDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyActivationDescriptor(activationDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyActivationDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnActivationForward(cudnnHandle_t  handle, cudnnActivationDescriptor_t  activationDesc, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnActivationForward) (cudnnHandle_t , cudnnActivationDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnActivationForward) {
		lcudnnActivationForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnActivationDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnActivationForward");
		tracer._kernel_map[(void *) lcudnnActivationForward] = std::string("cudnnActivationForward");
	}
	assert(lcudnnActivationForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnActivationForward(handle, activationDesc, alpha, xDesc, x, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnActivationForward);
	}
	return res;
}

cudnnStatus_t cudnnCreateLRNDescriptor(cudnnLRNDescriptor_t * normDesc)
{
	static cudnnStatus_t (*lcudnnCreateLRNDescriptor) (cudnnLRNDescriptor_t *);
	if (!lcudnnCreateLRNDescriptor) {
		lcudnnCreateLRNDescriptor = (cudnnStatus_t (*) (cudnnLRNDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateLRNDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateLRNDescriptor] = std::string("cudnnCreateLRNDescriptor");
	}
	assert(lcudnnCreateLRNDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateLRNDescriptor(normDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateLRNDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetLRNDescriptor(cudnnLRNDescriptor_t  normDesc, unsigned  lrnN, double  lrnAlpha, double  lrnBeta, double  lrnK)
{
	static cudnnStatus_t (*lcudnnSetLRNDescriptor) (cudnnLRNDescriptor_t , unsigned , double , double , double );
	if (!lcudnnSetLRNDescriptor) {
		lcudnnSetLRNDescriptor = (cudnnStatus_t (*) (cudnnLRNDescriptor_t , unsigned , double , double , double )) dlsym(tracer.cudnn_handle, "cudnnSetLRNDescriptor");
		tracer._kernel_map[(void *) lcudnnSetLRNDescriptor] = std::string("cudnnSetLRNDescriptor");
	}
	assert(lcudnnSetLRNDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetLRNDescriptor(normDesc, lrnN, lrnAlpha, lrnBeta, lrnK);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetLRNDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetLRNDescriptor(cudnnLRNDescriptor_t  normDesc, unsigned * lrnN, double * lrnAlpha, double * lrnBeta, double * lrnK)
{
	static cudnnStatus_t (*lcudnnGetLRNDescriptor) (cudnnLRNDescriptor_t , unsigned *, double *, double *, double *);
	if (!lcudnnGetLRNDescriptor) {
		lcudnnGetLRNDescriptor = (cudnnStatus_t (*) (cudnnLRNDescriptor_t , unsigned *, double *, double *, double *)) dlsym(tracer.cudnn_handle, "cudnnGetLRNDescriptor");
		tracer._kernel_map[(void *) lcudnnGetLRNDescriptor] = std::string("cudnnGetLRNDescriptor");
	}
	assert(lcudnnGetLRNDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetLRNDescriptor(normDesc, lrnN, lrnAlpha, lrnBeta, lrnK);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetLRNDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyLRNDescriptor(cudnnLRNDescriptor_t  lrnDesc)
{
	static cudnnStatus_t (*lcudnnDestroyLRNDescriptor) (cudnnLRNDescriptor_t );
	if (!lcudnnDestroyLRNDescriptor) {
		lcudnnDestroyLRNDescriptor = (cudnnStatus_t (*) (cudnnLRNDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyLRNDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyLRNDescriptor] = std::string("cudnnDestroyLRNDescriptor");
	}
	assert(lcudnnDestroyLRNDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyLRNDescriptor(lrnDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyLRNDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnLRNCrossChannelForward(cudnnHandle_t  handle, cudnnLRNDescriptor_t  normDesc, cudnnLRNMode_t  lrnMode, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnLRNCrossChannelForward) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnLRNMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnLRNCrossChannelForward) {
		lcudnnLRNCrossChannelForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnLRNMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnLRNCrossChannelForward");
		tracer._kernel_map[(void *) lcudnnLRNCrossChannelForward] = std::string("cudnnLRNCrossChannelForward");
	}
	assert(lcudnnLRNCrossChannelForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnLRNCrossChannelForward(handle, normDesc, lrnMode, alpha, xDesc, x, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnLRNCrossChannelForward);
	}
	return res;
}

cudnnStatus_t cudnnDivisiveNormalizationForward(cudnnHandle_t  handle, cudnnLRNDescriptor_t  normDesc, cudnnDivNormMode_t  mode, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * means, void * temp, void * temp2, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnDivisiveNormalizationForward) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnDivNormMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnDivisiveNormalizationForward) {
		lcudnnDivisiveNormalizationForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnDivNormMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnDivisiveNormalizationForward");
		tracer._kernel_map[(void *) lcudnnDivisiveNormalizationForward] = std::string("cudnnDivisiveNormalizationForward");
	}
	assert(lcudnnDivisiveNormalizationForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDivisiveNormalizationForward(handle, normDesc, mode, alpha, xDesc, x, means, temp, temp2, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDivisiveNormalizationForward);
	}
	return res;
}

cudnnStatus_t cudnnDeriveBNTensorDescriptor(cudnnTensorDescriptor_t  derivedBnDesc, const cudnnTensorDescriptor_t  xDesc, cudnnBatchNormMode_t  mode)
{
	static cudnnStatus_t (*lcudnnDeriveBNTensorDescriptor) (cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , cudnnBatchNormMode_t );
	if (!lcudnnDeriveBNTensorDescriptor) {
		lcudnnDeriveBNTensorDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , cudnnBatchNormMode_t )) dlsym(tracer.cudnn_handle, "cudnnDeriveBNTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnDeriveBNTensorDescriptor] = std::string("cudnnDeriveBNTensorDescriptor");
	}
	assert(lcudnnDeriveBNTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDeriveBNTensorDescriptor(derivedBnDesc, xDesc, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDeriveBNTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnBatchNormalizationForwardInference(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, const void * alpha, const void * beta, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  yDesc, void * y, const cudnnTensorDescriptor_t  bnScaleBiasMeanVarDesc, const void * bnScale, const void * bnBias, const void * estimatedMean, const void * estimatedVariance, double  epsilon)
{
	static cudnnStatus_t (*lcudnnBatchNormalizationForwardInference) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, const void *, double );
	if (!lcudnnBatchNormalizationForwardInference) {
		lcudnnBatchNormalizationForwardInference = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, const void *, double )) dlsym(tracer.cudnn_handle, "cudnnBatchNormalizationForwardInference");
		tracer._kernel_map[(void *) lcudnnBatchNormalizationForwardInference] = std::string("cudnnBatchNormalizationForwardInference");
	}
	assert(lcudnnBatchNormalizationForwardInference);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBatchNormalizationForwardInference(handle, mode, alpha, beta, xDesc, x, yDesc, y, bnScaleBiasMeanVarDesc, bnScale, bnBias, estimatedMean, estimatedVariance, epsilon);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBatchNormalizationForwardInference);
	}
	return res;
}

cudnnStatus_t cudnnDeriveNormTensorDescriptor(cudnnTensorDescriptor_t  derivedNormScaleBiasDesc, cudnnTensorDescriptor_t  derivedNormMeanVarDesc, const cudnnTensorDescriptor_t  xDesc, cudnnNormMode_t  mode, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnDeriveNormTensorDescriptor) (cudnnTensorDescriptor_t , cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , cudnnNormMode_t , int );
	if (!lcudnnDeriveNormTensorDescriptor) {
		lcudnnDeriveNormTensorDescriptor = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , cudnnNormMode_t , int )) dlsym(tracer.cudnn_handle, "cudnnDeriveNormTensorDescriptor");
		tracer._kernel_map[(void *) lcudnnDeriveNormTensorDescriptor] = std::string("cudnnDeriveNormTensorDescriptor");
	}
	assert(lcudnnDeriveNormTensorDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDeriveNormTensorDescriptor(derivedNormScaleBiasDesc, derivedNormMeanVarDesc, xDesc, mode, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDeriveNormTensorDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnNormalizationForwardInference(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const void * alpha, const void * beta, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  normScaleBiasDesc, const void * normScale, const void * normBias, const cudnnTensorDescriptor_t  normMeanVarDesc, const void * estimatedMean, const void * estimatedVariance, const cudnnTensorDescriptor_t  zDesc, const void * z, cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  yDesc, void * y, double  epsilon, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnNormalizationForwardInference) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , void *, double , int );
	if (!lcudnnNormalizationForwardInference) {
		lcudnnNormalizationForwardInference = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , void *, double , int )) dlsym(tracer.cudnn_handle, "cudnnNormalizationForwardInference");
		tracer._kernel_map[(void *) lcudnnNormalizationForwardInference] = std::string("cudnnNormalizationForwardInference");
	}
	assert(lcudnnNormalizationForwardInference);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnNormalizationForwardInference(handle, mode, normOps, algo, alpha, beta, xDesc, x, normScaleBiasDesc, normScale, normBias, normMeanVarDesc, estimatedMean, estimatedVariance, zDesc, z, activationDesc, yDesc, y, epsilon, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnNormalizationForwardInference);
	}
	return res;
}

cudnnStatus_t cudnnCreateSpatialTransformerDescriptor(cudnnSpatialTransformerDescriptor_t * stDesc)
{
	static cudnnStatus_t (*lcudnnCreateSpatialTransformerDescriptor) (cudnnSpatialTransformerDescriptor_t *);
	if (!lcudnnCreateSpatialTransformerDescriptor) {
		lcudnnCreateSpatialTransformerDescriptor = (cudnnStatus_t (*) (cudnnSpatialTransformerDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateSpatialTransformerDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateSpatialTransformerDescriptor] = std::string("cudnnCreateSpatialTransformerDescriptor");
	}
	assert(lcudnnCreateSpatialTransformerDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateSpatialTransformerDescriptor(stDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateSpatialTransformerDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetSpatialTransformerNdDescriptor(cudnnSpatialTransformerDescriptor_t  stDesc, cudnnSamplerType_t  samplerType, cudnnDataType_t  dataType, const int  nbDims, const int  dimA[])
{
	static cudnnStatus_t (*lcudnnSetSpatialTransformerNdDescriptor) (cudnnSpatialTransformerDescriptor_t , cudnnSamplerType_t , cudnnDataType_t , const int , const int []);
	if (!lcudnnSetSpatialTransformerNdDescriptor) {
		lcudnnSetSpatialTransformerNdDescriptor = (cudnnStatus_t (*) (cudnnSpatialTransformerDescriptor_t , cudnnSamplerType_t , cudnnDataType_t , const int , const int [])) dlsym(tracer.cudnn_handle, "cudnnSetSpatialTransformerNdDescriptor");
		tracer._kernel_map[(void *) lcudnnSetSpatialTransformerNdDescriptor] = std::string("cudnnSetSpatialTransformerNdDescriptor");
	}
	assert(lcudnnSetSpatialTransformerNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetSpatialTransformerNdDescriptor(stDesc, samplerType, dataType, nbDims, dimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetSpatialTransformerNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroySpatialTransformerDescriptor(cudnnSpatialTransformerDescriptor_t  stDesc)
{
	static cudnnStatus_t (*lcudnnDestroySpatialTransformerDescriptor) (cudnnSpatialTransformerDescriptor_t );
	if (!lcudnnDestroySpatialTransformerDescriptor) {
		lcudnnDestroySpatialTransformerDescriptor = (cudnnStatus_t (*) (cudnnSpatialTransformerDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroySpatialTransformerDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroySpatialTransformerDescriptor] = std::string("cudnnDestroySpatialTransformerDescriptor");
	}
	assert(lcudnnDestroySpatialTransformerDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroySpatialTransformerDescriptor(stDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroySpatialTransformerDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSpatialTfGridGeneratorForward(cudnnHandle_t  handle, const cudnnSpatialTransformerDescriptor_t  stDesc, const void * theta, void * grid)
{
	static cudnnStatus_t (*lcudnnSpatialTfGridGeneratorForward) (cudnnHandle_t , const cudnnSpatialTransformerDescriptor_t , const void *, void *);
	if (!lcudnnSpatialTfGridGeneratorForward) {
		lcudnnSpatialTfGridGeneratorForward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnSpatialTransformerDescriptor_t , const void *, void *)) dlsym(tracer.cudnn_handle, "cudnnSpatialTfGridGeneratorForward");
		tracer._kernel_map[(void *) lcudnnSpatialTfGridGeneratorForward] = std::string("cudnnSpatialTfGridGeneratorForward");
	}
	assert(lcudnnSpatialTfGridGeneratorForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSpatialTfGridGeneratorForward(handle, stDesc, theta, grid);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSpatialTfGridGeneratorForward);
	}
	return res;
}

cudnnStatus_t cudnnSpatialTfSamplerForward(cudnnHandle_t  handle, cudnnSpatialTransformerDescriptor_t  stDesc, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * grid, const void * beta, cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnSpatialTfSamplerForward) (cudnnHandle_t , cudnnSpatialTransformerDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, cudnnTensorDescriptor_t , void *);
	if (!lcudnnSpatialTfSamplerForward) {
		lcudnnSpatialTfSamplerForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnSpatialTransformerDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnSpatialTfSamplerForward");
		tracer._kernel_map[(void *) lcudnnSpatialTfSamplerForward] = std::string("cudnnSpatialTfSamplerForward");
	}
	assert(lcudnnSpatialTfSamplerForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSpatialTfSamplerForward(handle, stDesc, alpha, xDesc, x, grid, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSpatialTfSamplerForward);
	}
	return res;
}

cudnnStatus_t cudnnCreateDropoutDescriptor(cudnnDropoutDescriptor_t * dropoutDesc)
{
	static cudnnStatus_t (*lcudnnCreateDropoutDescriptor) (cudnnDropoutDescriptor_t *);
	if (!lcudnnCreateDropoutDescriptor) {
		lcudnnCreateDropoutDescriptor = (cudnnStatus_t (*) (cudnnDropoutDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateDropoutDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateDropoutDescriptor] = std::string("cudnnCreateDropoutDescriptor");
	}
	assert(lcudnnCreateDropoutDescriptor);
	cudnnStatus_t res = 
		lcudnnCreateDropoutDescriptor(dropoutDesc);
	return res;
}

cudnnStatus_t cudnnDestroyDropoutDescriptor(cudnnDropoutDescriptor_t  dropoutDesc)
{
	static cudnnStatus_t (*lcudnnDestroyDropoutDescriptor) (cudnnDropoutDescriptor_t );
	if (!lcudnnDestroyDropoutDescriptor) {
		lcudnnDestroyDropoutDescriptor = (cudnnStatus_t (*) (cudnnDropoutDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyDropoutDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyDropoutDescriptor] = std::string("cudnnDestroyDropoutDescriptor");
	}
	assert(lcudnnDestroyDropoutDescriptor);
	cudnnStatus_t res = 
		lcudnnDestroyDropoutDescriptor(dropoutDesc);
	return res;
}

cudnnStatus_t cudnnDropoutGetStatesSize(cudnnHandle_t  handle, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnDropoutGetStatesSize) (cudnnHandle_t , size_t *);
	if (!lcudnnDropoutGetStatesSize) {
		lcudnnDropoutGetStatesSize = (cudnnStatus_t (*) (cudnnHandle_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnDropoutGetStatesSize");
		tracer._kernel_map[(void *) lcudnnDropoutGetStatesSize] = std::string("cudnnDropoutGetStatesSize");
	}
	assert(lcudnnDropoutGetStatesSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDropoutGetStatesSize(handle, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDropoutGetStatesSize);
	}
	return res;
}

cudnnStatus_t cudnnDropoutGetReserveSpaceSize(cudnnTensorDescriptor_t  xdesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnDropoutGetReserveSpaceSize) (cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnDropoutGetReserveSpaceSize) {
		lcudnnDropoutGetReserveSpaceSize = (cudnnStatus_t (*) (cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnDropoutGetReserveSpaceSize");
		tracer._kernel_map[(void *) lcudnnDropoutGetReserveSpaceSize] = std::string("cudnnDropoutGetReserveSpaceSize");
	}
	assert(lcudnnDropoutGetReserveSpaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDropoutGetReserveSpaceSize(xdesc, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDropoutGetReserveSpaceSize);
	}
	return res;
}

cudnnStatus_t cudnnSetDropoutDescriptor(cudnnDropoutDescriptor_t  dropoutDesc, cudnnHandle_t  handle, float  dropout, void * states, size_t  stateSizeInBytes, unsigned long long  seed)
{
	static cudnnStatus_t (*lcudnnSetDropoutDescriptor) (cudnnDropoutDescriptor_t , cudnnHandle_t , float , void *, size_t , unsigned long long );
	if (!lcudnnSetDropoutDescriptor) {
		lcudnnSetDropoutDescriptor = (cudnnStatus_t (*) (cudnnDropoutDescriptor_t , cudnnHandle_t , float , void *, size_t , unsigned long long )) dlsym(tracer.cudnn_handle, "cudnnSetDropoutDescriptor");
		tracer._kernel_map[(void *) lcudnnSetDropoutDescriptor] = std::string("cudnnSetDropoutDescriptor");
	}
	assert(lcudnnSetDropoutDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetDropoutDescriptor(dropoutDesc, handle, dropout, states, stateSizeInBytes, seed);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetDropoutDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnRestoreDropoutDescriptor(cudnnDropoutDescriptor_t  dropoutDesc, cudnnHandle_t  handle, float  dropout, void * states, size_t  stateSizeInBytes, unsigned long long  seed)
{
	static cudnnStatus_t (*lcudnnRestoreDropoutDescriptor) (cudnnDropoutDescriptor_t , cudnnHandle_t , float , void *, size_t , unsigned long long );
	if (!lcudnnRestoreDropoutDescriptor) {
		lcudnnRestoreDropoutDescriptor = (cudnnStatus_t (*) (cudnnDropoutDescriptor_t , cudnnHandle_t , float , void *, size_t , unsigned long long )) dlsym(tracer.cudnn_handle, "cudnnRestoreDropoutDescriptor");
		tracer._kernel_map[(void *) lcudnnRestoreDropoutDescriptor] = std::string("cudnnRestoreDropoutDescriptor");
	}
	assert(lcudnnRestoreDropoutDescriptor);
	cudnnStatus_t res = 
		lcudnnRestoreDropoutDescriptor(dropoutDesc, handle, dropout, states, stateSizeInBytes, seed);
	return res;
}

cudnnStatus_t cudnnGetDropoutDescriptor(cudnnDropoutDescriptor_t  dropoutDesc, cudnnHandle_t  handle, float * dropout, void ** states, unsigned long long * seed)
{
	static cudnnStatus_t (*lcudnnGetDropoutDescriptor) (cudnnDropoutDescriptor_t , cudnnHandle_t , float *, void **, unsigned long long *);
	if (!lcudnnGetDropoutDescriptor) {
		lcudnnGetDropoutDescriptor = (cudnnStatus_t (*) (cudnnDropoutDescriptor_t , cudnnHandle_t , float *, void **, unsigned long long *)) dlsym(tracer.cudnn_handle, "cudnnGetDropoutDescriptor");
		tracer._kernel_map[(void *) lcudnnGetDropoutDescriptor] = std::string("cudnnGetDropoutDescriptor");
	}
	assert(lcudnnGetDropoutDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetDropoutDescriptor(dropoutDesc, handle, dropout, states, seed);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetDropoutDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDropoutForward(cudnnHandle_t  handle, const cudnnDropoutDescriptor_t  dropoutDesc, const cudnnTensorDescriptor_t  xdesc, const void * x, const cudnnTensorDescriptor_t  ydesc, void * y, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnDropoutForward) (cudnnHandle_t , const cudnnDropoutDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t );
	if (!lcudnnDropoutForward) {
		lcudnnDropoutForward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnDropoutDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnDropoutForward");
		tracer._kernel_map[(void *) lcudnnDropoutForward] = std::string("cudnnDropoutForward");
	}
	assert(lcudnnDropoutForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDropoutForward(handle, dropoutDesc, xdesc, x, ydesc, y, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDropoutForward);
	}
	return res;
}

cudnnStatus_t cudnnCreateAlgorithmDescriptor(cudnnAlgorithmDescriptor_t * algoDesc)
{
	static cudnnStatus_t (*lcudnnCreateAlgorithmDescriptor) (cudnnAlgorithmDescriptor_t *);
	if (!lcudnnCreateAlgorithmDescriptor) {
		lcudnnCreateAlgorithmDescriptor = (cudnnStatus_t (*) (cudnnAlgorithmDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateAlgorithmDescriptor] = std::string("cudnnCreateAlgorithmDescriptor");
	}
	assert(lcudnnCreateAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateAlgorithmDescriptor(algoDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetAlgorithmDescriptor(cudnnAlgorithmDescriptor_t  algoDesc, cudnnAlgorithm_t  algorithm)
{
	static cudnnStatus_t (*lcudnnSetAlgorithmDescriptor) (cudnnAlgorithmDescriptor_t , cudnnAlgorithm_t );
	if (!lcudnnSetAlgorithmDescriptor) {
		lcudnnSetAlgorithmDescriptor = (cudnnStatus_t (*) (cudnnAlgorithmDescriptor_t , cudnnAlgorithm_t )) dlsym(tracer.cudnn_handle, "cudnnSetAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnSetAlgorithmDescriptor] = std::string("cudnnSetAlgorithmDescriptor");
	}
	assert(lcudnnSetAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetAlgorithmDescriptor(algoDesc, algorithm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetAlgorithmDescriptor(const cudnnAlgorithmDescriptor_t  algoDesc, cudnnAlgorithm_t * algorithm)
{
	static cudnnStatus_t (*lcudnnGetAlgorithmDescriptor) (const cudnnAlgorithmDescriptor_t , cudnnAlgorithm_t *);
	if (!lcudnnGetAlgorithmDescriptor) {
		lcudnnGetAlgorithmDescriptor = (cudnnStatus_t (*) (const cudnnAlgorithmDescriptor_t , cudnnAlgorithm_t *)) dlsym(tracer.cudnn_handle, "cudnnGetAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnGetAlgorithmDescriptor] = std::string("cudnnGetAlgorithmDescriptor");
	}
	assert(lcudnnGetAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetAlgorithmDescriptor(algoDesc, algorithm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnCopyAlgorithmDescriptor(const cudnnAlgorithmDescriptor_t  src, cudnnAlgorithmDescriptor_t  dest)
{
	static cudnnStatus_t (*lcudnnCopyAlgorithmDescriptor) (const cudnnAlgorithmDescriptor_t , cudnnAlgorithmDescriptor_t );
	if (!lcudnnCopyAlgorithmDescriptor) {
		lcudnnCopyAlgorithmDescriptor = (cudnnStatus_t (*) (const cudnnAlgorithmDescriptor_t , cudnnAlgorithmDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnCopyAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnCopyAlgorithmDescriptor] = std::string("cudnnCopyAlgorithmDescriptor");
	}
	assert(lcudnnCopyAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCopyAlgorithmDescriptor(src, dest);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCopyAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyAlgorithmDescriptor(cudnnAlgorithmDescriptor_t  algoDesc)
{
	static cudnnStatus_t (*lcudnnDestroyAlgorithmDescriptor) (cudnnAlgorithmDescriptor_t );
	if (!lcudnnDestroyAlgorithmDescriptor) {
		lcudnnDestroyAlgorithmDescriptor = (cudnnStatus_t (*) (cudnnAlgorithmDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyAlgorithmDescriptor] = std::string("cudnnDestroyAlgorithmDescriptor");
	}
	assert(lcudnnDestroyAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyAlgorithmDescriptor(algoDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnCreateAlgorithmPerformance(cudnnAlgorithmPerformance_t * algoPerf, int  numberToCreate)
{
	static cudnnStatus_t (*lcudnnCreateAlgorithmPerformance) (cudnnAlgorithmPerformance_t *, int );
	if (!lcudnnCreateAlgorithmPerformance) {
		lcudnnCreateAlgorithmPerformance = (cudnnStatus_t (*) (cudnnAlgorithmPerformance_t *, int )) dlsym(tracer.cudnn_handle, "cudnnCreateAlgorithmPerformance");
		tracer._kernel_map[(void *) lcudnnCreateAlgorithmPerformance] = std::string("cudnnCreateAlgorithmPerformance");
	}
	assert(lcudnnCreateAlgorithmPerformance);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateAlgorithmPerformance(algoPerf, numberToCreate);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateAlgorithmPerformance);
	}
	return res;
}

cudnnStatus_t cudnnSetAlgorithmPerformance(cudnnAlgorithmPerformance_t  algoPerf, cudnnAlgorithmDescriptor_t  algoDesc, cudnnStatus_t  status, float  time, size_t  memory)
{
	static cudnnStatus_t (*lcudnnSetAlgorithmPerformance) (cudnnAlgorithmPerformance_t , cudnnAlgorithmDescriptor_t , cudnnStatus_t , float , size_t );
	if (!lcudnnSetAlgorithmPerformance) {
		lcudnnSetAlgorithmPerformance = (cudnnStatus_t (*) (cudnnAlgorithmPerformance_t , cudnnAlgorithmDescriptor_t , cudnnStatus_t , float , size_t )) dlsym(tracer.cudnn_handle, "cudnnSetAlgorithmPerformance");
		tracer._kernel_map[(void *) lcudnnSetAlgorithmPerformance] = std::string("cudnnSetAlgorithmPerformance");
	}
	assert(lcudnnSetAlgorithmPerformance);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetAlgorithmPerformance(algoPerf, algoDesc, status, time, memory);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetAlgorithmPerformance);
	}
	return res;
}

cudnnStatus_t cudnnGetAlgorithmPerformance(const cudnnAlgorithmPerformance_t  algoPerf, cudnnAlgorithmDescriptor_t * algoDesc, cudnnStatus_t * status, float * time, size_t * memory)
{
	static cudnnStatus_t (*lcudnnGetAlgorithmPerformance) (const cudnnAlgorithmPerformance_t , cudnnAlgorithmDescriptor_t *, cudnnStatus_t *, float *, size_t *);
	if (!lcudnnGetAlgorithmPerformance) {
		lcudnnGetAlgorithmPerformance = (cudnnStatus_t (*) (const cudnnAlgorithmPerformance_t , cudnnAlgorithmDescriptor_t *, cudnnStatus_t *, float *, size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetAlgorithmPerformance");
		tracer._kernel_map[(void *) lcudnnGetAlgorithmPerformance] = std::string("cudnnGetAlgorithmPerformance");
	}
	assert(lcudnnGetAlgorithmPerformance);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetAlgorithmPerformance(algoPerf, algoDesc, status, time, memory);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetAlgorithmPerformance);
	}
	return res;
}

cudnnStatus_t cudnnDestroyAlgorithmPerformance(cudnnAlgorithmPerformance_t * algoPerf, int  numberToDestroy)
{
	static cudnnStatus_t (*lcudnnDestroyAlgorithmPerformance) (cudnnAlgorithmPerformance_t *, int );
	if (!lcudnnDestroyAlgorithmPerformance) {
		lcudnnDestroyAlgorithmPerformance = (cudnnStatus_t (*) (cudnnAlgorithmPerformance_t *, int )) dlsym(tracer.cudnn_handle, "cudnnDestroyAlgorithmPerformance");
		tracer._kernel_map[(void *) lcudnnDestroyAlgorithmPerformance] = std::string("cudnnDestroyAlgorithmPerformance");
	}
	assert(lcudnnDestroyAlgorithmPerformance);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyAlgorithmPerformance(algoPerf, numberToDestroy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyAlgorithmPerformance);
	}
	return res;
}

cudnnStatus_t cudnnGetAlgorithmSpaceSize(cudnnHandle_t  handle, cudnnAlgorithmDescriptor_t  algoDesc, size_t * algoSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetAlgorithmSpaceSize) (cudnnHandle_t , cudnnAlgorithmDescriptor_t , size_t *);
	if (!lcudnnGetAlgorithmSpaceSize) {
		lcudnnGetAlgorithmSpaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnAlgorithmDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetAlgorithmSpaceSize");
		tracer._kernel_map[(void *) lcudnnGetAlgorithmSpaceSize] = std::string("cudnnGetAlgorithmSpaceSize");
	}
	assert(lcudnnGetAlgorithmSpaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetAlgorithmSpaceSize(handle, algoDesc, algoSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetAlgorithmSpaceSize);
	}
	return res;
}

cudnnStatus_t cudnnSaveAlgorithm(cudnnHandle_t  handle, cudnnAlgorithmDescriptor_t  algoDesc, void * algoSpace, size_t  algoSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnSaveAlgorithm) (cudnnHandle_t , cudnnAlgorithmDescriptor_t , void *, size_t );
	if (!lcudnnSaveAlgorithm) {
		lcudnnSaveAlgorithm = (cudnnStatus_t (*) (cudnnHandle_t , cudnnAlgorithmDescriptor_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnSaveAlgorithm");
		tracer._kernel_map[(void *) lcudnnSaveAlgorithm] = std::string("cudnnSaveAlgorithm");
	}
	assert(lcudnnSaveAlgorithm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSaveAlgorithm(handle, algoDesc, algoSpace, algoSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSaveAlgorithm);
	}
	return res;
}

cudnnStatus_t cudnnRestoreAlgorithm(cudnnHandle_t  handle, void * algoSpace, size_t  algoSpaceSizeInBytes, cudnnAlgorithmDescriptor_t  algoDesc)
{
	static cudnnStatus_t (*lcudnnRestoreAlgorithm) (cudnnHandle_t , void *, size_t , cudnnAlgorithmDescriptor_t );
	if (!lcudnnRestoreAlgorithm) {
		lcudnnRestoreAlgorithm = (cudnnStatus_t (*) (cudnnHandle_t , void *, size_t , cudnnAlgorithmDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnRestoreAlgorithm");
		tracer._kernel_map[(void *) lcudnnRestoreAlgorithm] = std::string("cudnnRestoreAlgorithm");
	}
	assert(lcudnnRestoreAlgorithm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRestoreAlgorithm(handle, algoSpace, algoSpaceSizeInBytes, algoDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRestoreAlgorithm);
	}
	return res;
}

cudnnStatus_t cudnnSetCallback(unsigned  mask, void * udata, cudnnCallback_t  fptr)
{
	static cudnnStatus_t (*lcudnnSetCallback) (unsigned , void *, cudnnCallback_t );
	if (!lcudnnSetCallback) {
		lcudnnSetCallback = (cudnnStatus_t (*) (unsigned , void *, cudnnCallback_t )) dlsym(tracer.cudnn_handle, "cudnnSetCallback");
		tracer._kernel_map[(void *) lcudnnSetCallback] = std::string("cudnnSetCallback");
	}
	assert(lcudnnSetCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetCallback(mask, udata, fptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetCallback);
	}
	return res;
}

cudnnStatus_t cudnnGetCallback(unsigned * mask, void ** udata, cudnnCallback_t * fptr)
{
	static cudnnStatus_t (*lcudnnGetCallback) (unsigned *, void **, cudnnCallback_t *);
	if (!lcudnnGetCallback) {
		lcudnnGetCallback = (cudnnStatus_t (*) (unsigned *, void **, cudnnCallback_t *)) dlsym(tracer.cudnn_handle, "cudnnGetCallback");
		tracer._kernel_map[(void *) lcudnnGetCallback] = std::string("cudnnGetCallback");
	}
	assert(lcudnnGetCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCallback(mask, udata, fptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCallback);
	}
	return res;
}

cudnnStatus_t cudnnOpsInferVersionCheck()
{
	static cudnnStatus_t (*lcudnnOpsInferVersionCheck) ();
	if (!lcudnnOpsInferVersionCheck) {
		lcudnnOpsInferVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnOpsInferVersionCheck");
		tracer._kernel_map[(void *) lcudnnOpsInferVersionCheck] = std::string("cudnnOpsInferVersionCheck");
	}
	assert(lcudnnOpsInferVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnOpsInferVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnOpsInferVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnSoftmaxBackward(cudnnHandle_t  handle, cudnnSoftmaxAlgorithm_t  algo, cudnnSoftmaxMode_t  mode, const void * alpha, const cudnnTensorDescriptor_t  yDesc, const void * y, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx)
{
	static cudnnStatus_t (*lcudnnSoftmaxBackward) (cudnnHandle_t , cudnnSoftmaxAlgorithm_t , cudnnSoftmaxMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnSoftmaxBackward) {
		lcudnnSoftmaxBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnSoftmaxAlgorithm_t , cudnnSoftmaxMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnSoftmaxBackward");
		tracer._kernel_map[(void *) lcudnnSoftmaxBackward] = std::string("cudnnSoftmaxBackward");
	}
	assert(lcudnnSoftmaxBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSoftmaxBackward(handle, algo, mode, alpha, yDesc, y, dyDesc, dy, beta, dxDesc, dx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSoftmaxBackward);
	}
	return res;
}

cudnnStatus_t cudnnPoolingBackward(cudnnHandle_t  handle, const cudnnPoolingDescriptor_t  poolingDesc, const void * alpha, const cudnnTensorDescriptor_t  yDesc, const void * y, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx)
{
	static cudnnStatus_t (*lcudnnPoolingBackward) (cudnnHandle_t , const cudnnPoolingDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnPoolingBackward) {
		lcudnnPoolingBackward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnPoolingDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnPoolingBackward");
		tracer._kernel_map[(void *) lcudnnPoolingBackward] = std::string("cudnnPoolingBackward");
	}
	assert(lcudnnPoolingBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnPoolingBackward(handle, poolingDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnPoolingBackward);
	}
	return res;
}

cudnnStatus_t cudnnActivationBackward(cudnnHandle_t  handle, cudnnActivationDescriptor_t  activationDesc, const void * alpha, const cudnnTensorDescriptor_t  yDesc, const void * y, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx)
{
	static cudnnStatus_t (*lcudnnActivationBackward) (cudnnHandle_t , cudnnActivationDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnActivationBackward) {
		lcudnnActivationBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnActivationDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnActivationBackward");
		tracer._kernel_map[(void *) lcudnnActivationBackward] = std::string("cudnnActivationBackward");
	}
	assert(lcudnnActivationBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnActivationBackward(handle, activationDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnActivationBackward);
	}
	return res;
}

cudnnStatus_t cudnnLRNCrossChannelBackward(cudnnHandle_t  handle, cudnnLRNDescriptor_t  normDesc, cudnnLRNMode_t  lrnMode, const void * alpha, const cudnnTensorDescriptor_t  yDesc, const void * y, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx)
{
	static cudnnStatus_t (*lcudnnLRNCrossChannelBackward) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnLRNMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnLRNCrossChannelBackward) {
		lcudnnLRNCrossChannelBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnLRNMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnLRNCrossChannelBackward");
		tracer._kernel_map[(void *) lcudnnLRNCrossChannelBackward] = std::string("cudnnLRNCrossChannelBackward");
	}
	assert(lcudnnLRNCrossChannelBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnLRNCrossChannelBackward(handle, normDesc, lrnMode, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnLRNCrossChannelBackward);
	}
	return res;
}

cudnnStatus_t cudnnDivisiveNormalizationBackward(cudnnHandle_t  handle, cudnnLRNDescriptor_t  normDesc, cudnnDivNormMode_t  mode, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * means, const void * dy, void * temp, void * temp2, const void * beta, const cudnnTensorDescriptor_t  dXdMeansDesc, void * dx, void * dMeans)
{
	static cudnnStatus_t (*lcudnnDivisiveNormalizationBackward) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnDivNormMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, void *, void *, const void *, const cudnnTensorDescriptor_t , void *, void *);
	if (!lcudnnDivisiveNormalizationBackward) {
		lcudnnDivisiveNormalizationBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnLRNDescriptor_t , cudnnDivNormMode_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, void *, void *, const void *, const cudnnTensorDescriptor_t , void *, void *)) dlsym(tracer.cudnn_handle, "cudnnDivisiveNormalizationBackward");
		tracer._kernel_map[(void *) lcudnnDivisiveNormalizationBackward] = std::string("cudnnDivisiveNormalizationBackward");
	}
	assert(lcudnnDivisiveNormalizationBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDivisiveNormalizationBackward(handle, normDesc, mode, alpha, xDesc, x, means, dy, temp, temp2, beta, dXdMeansDesc, dx, dMeans);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDivisiveNormalizationBackward);
	}
	return res;
}

cudnnStatus_t cudnnGetBatchNormalizationForwardTrainingExWorkspaceSize(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, cudnnBatchNormOps_t  bnOps, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  zDesc, const cudnnTensorDescriptor_t  yDesc, const cudnnTensorDescriptor_t  bnScaleBiasMeanVarDesc, const cudnnActivationDescriptor_t  activationDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , size_t *);
	if (!lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize) {
		lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetBatchNormalizationForwardTrainingExWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize] = std::string("cudnnGetBatchNormalizationForwardTrainingExWorkspaceSize");
	}
	assert(lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize);
	cudnnStatus_t res = 
		lcudnnGetBatchNormalizationForwardTrainingExWorkspaceSize(handle, mode, bnOps, xDesc, zDesc, yDesc, bnScaleBiasMeanVarDesc, activationDesc, sizeInBytes);
	return res;
}

cudnnStatus_t cudnnGetBatchNormalizationBackwardExWorkspaceSize(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, cudnnBatchNormOps_t  bnOps, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  yDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnTensorDescriptor_t  dzDesc, const cudnnTensorDescriptor_t  dxDesc, const cudnnTensorDescriptor_t  dBnScaleBiasDesc, const cudnnActivationDescriptor_t  activationDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetBatchNormalizationBackwardExWorkspaceSize) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , size_t *);
	if (!lcudnnGetBatchNormalizationBackwardExWorkspaceSize) {
		lcudnnGetBatchNormalizationBackwardExWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetBatchNormalizationBackwardExWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetBatchNormalizationBackwardExWorkspaceSize] = std::string("cudnnGetBatchNormalizationBackwardExWorkspaceSize");
	}
	assert(lcudnnGetBatchNormalizationBackwardExWorkspaceSize);
	cudnnStatus_t res = 
		lcudnnGetBatchNormalizationBackwardExWorkspaceSize(handle, mode, bnOps, xDesc, yDesc, dyDesc, dzDesc, dxDesc, dBnScaleBiasDesc, activationDesc, sizeInBytes);
	return res;
}

cudnnStatus_t cudnnGetBatchNormalizationTrainingExReserveSpaceSize(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, cudnnBatchNormOps_t  bnOps, const cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  xDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetBatchNormalizationTrainingExReserveSpaceSize) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnGetBatchNormalizationTrainingExReserveSpaceSize) {
		lcudnnGetBatchNormalizationTrainingExReserveSpaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetBatchNormalizationTrainingExReserveSpaceSize");
		tracer._kernel_map[(void *) lcudnnGetBatchNormalizationTrainingExReserveSpaceSize] = std::string("cudnnGetBatchNormalizationTrainingExReserveSpaceSize");
	}
	assert(lcudnnGetBatchNormalizationTrainingExReserveSpaceSize);
	cudnnStatus_t res = 
		lcudnnGetBatchNormalizationTrainingExReserveSpaceSize(handle, mode, bnOps, activationDesc, xDesc, sizeInBytes);
	return res;
}

cudnnStatus_t cudnnBatchNormalizationForwardTraining(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, const void * alpha, const void * beta, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  yDesc, void * y, const cudnnTensorDescriptor_t  bnScaleBiasMeanVarDesc, const void * bnScale, const void * bnBias, double  exponentialAverageFactor, void * resultRunningMean, void * resultRunningVariance, double  epsilon, void * resultSaveMean, void * resultSaveInvVariance)
{
	static cudnnStatus_t (*lcudnnBatchNormalizationForwardTraining) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, double , void *, void *, double , void *, void *);
	if (!lcudnnBatchNormalizationForwardTraining) {
		lcudnnBatchNormalizationForwardTraining = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, double , void *, void *, double , void *, void *)) dlsym(tracer.cudnn_handle, "cudnnBatchNormalizationForwardTraining");
		tracer._kernel_map[(void *) lcudnnBatchNormalizationForwardTraining] = std::string("cudnnBatchNormalizationForwardTraining");
	}
	assert(lcudnnBatchNormalizationForwardTraining);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBatchNormalizationForwardTraining(handle, mode, alpha, beta, xDesc, x, yDesc, y, bnScaleBiasMeanVarDesc, bnScale, bnBias, exponentialAverageFactor, resultRunningMean, resultRunningVariance, epsilon, resultSaveMean, resultSaveInvVariance);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBatchNormalizationForwardTraining);
	}
	return res;
}

cudnnStatus_t cudnnBatchNormalizationForwardTrainingEx(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, cudnnBatchNormOps_t  bnOps, const void * alpha, const void * beta, const cudnnTensorDescriptor_t  xDesc, const void * xData, const cudnnTensorDescriptor_t  zDesc, const void * zData, const cudnnTensorDescriptor_t  yDesc, void * yData, const cudnnTensorDescriptor_t  bnScaleBiasMeanVarDesc, const void * bnScale, const void * bnBias, double  exponentialAverageFactor, void * resultRunningMean, void * resultRunningVariance, double  epsilon, void * resultSaveMean, void * resultSaveInvVariance, cudnnActivationDescriptor_t  activationDesc, void * workspace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnBatchNormalizationForwardTrainingEx) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, double , void *, void *, double , void *, void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t );
	if (!lcudnnBatchNormalizationForwardTrainingEx) {
		lcudnnBatchNormalizationForwardTrainingEx = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, double , void *, void *, double , void *, void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnBatchNormalizationForwardTrainingEx");
		tracer._kernel_map[(void *) lcudnnBatchNormalizationForwardTrainingEx] = std::string("cudnnBatchNormalizationForwardTrainingEx");
	}
	assert(lcudnnBatchNormalizationForwardTrainingEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBatchNormalizationForwardTrainingEx(handle, mode, bnOps, alpha, beta, xDesc, xData, zDesc, zData, yDesc, yData, bnScaleBiasMeanVarDesc, bnScale, bnBias, exponentialAverageFactor, resultRunningMean, resultRunningVariance, epsilon, resultSaveMean, resultSaveInvVariance, activationDesc, workspace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBatchNormalizationForwardTrainingEx);
	}
	return res;
}

cudnnStatus_t cudnnBatchNormalizationBackward(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, const void * alphaDataDiff, const void * betaDataDiff, const void * alphaParamDiff, const void * betaParamDiff, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnTensorDescriptor_t  dxDesc, void * dx, const cudnnTensorDescriptor_t  dBnScaleBiasDesc, const void * bnScale, void * dBnScaleResult, void * dBnBiasResult, double  epsilon, const void * savedMean, const void * savedInvVariance)
{
	static cudnnStatus_t (*lcudnnBatchNormalizationBackward) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, void *, void *, double , const void *, const void *);
	if (!lcudnnBatchNormalizationBackward) {
		lcudnnBatchNormalizationBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, void *, void *, double , const void *, const void *)) dlsym(tracer.cudnn_handle, "cudnnBatchNormalizationBackward");
		tracer._kernel_map[(void *) lcudnnBatchNormalizationBackward] = std::string("cudnnBatchNormalizationBackward");
	}
	assert(lcudnnBatchNormalizationBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBatchNormalizationBackward(handle, mode, alphaDataDiff, betaDataDiff, alphaParamDiff, betaParamDiff, xDesc, x, dyDesc, dy, dxDesc, dx, dBnScaleBiasDesc, bnScale, dBnScaleResult, dBnBiasResult, epsilon, savedMean, savedInvVariance);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBatchNormalizationBackward);
	}
	return res;
}

cudnnStatus_t cudnnBatchNormalizationBackwardEx(cudnnHandle_t  handle, cudnnBatchNormMode_t  mode, cudnnBatchNormOps_t  bnOps, const void * alphaDataDiff, const void * betaDataDiff, const void * alphaParamDiff, const void * betaParamDiff, const cudnnTensorDescriptor_t  xDesc, const void * xData, const cudnnTensorDescriptor_t  yDesc, const void * yData, const cudnnTensorDescriptor_t  dyDesc, const void * dyData, const cudnnTensorDescriptor_t  dzDesc, void * dzData, const cudnnTensorDescriptor_t  dxDesc, void * dxData, const cudnnTensorDescriptor_t  dBnScaleBiasDesc, const void * bnScaleData, const void * bnBiasData, void * dBnScaleData, void * dBnBiasData, double  epsilon, const void * savedMean, const void * savedInvVariance, cudnnActivationDescriptor_t  activationDesc, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnBatchNormalizationBackwardEx) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, double , const void *, const void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t );
	if (!lcudnnBatchNormalizationBackwardEx) {
		lcudnnBatchNormalizationBackwardEx = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBatchNormMode_t , cudnnBatchNormOps_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, double , const void *, const void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnBatchNormalizationBackwardEx");
		tracer._kernel_map[(void *) lcudnnBatchNormalizationBackwardEx] = std::string("cudnnBatchNormalizationBackwardEx");
	}
	assert(lcudnnBatchNormalizationBackwardEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBatchNormalizationBackwardEx(handle, mode, bnOps, alphaDataDiff, betaDataDiff, alphaParamDiff, betaParamDiff, xDesc, xData, yDesc, yData, dyDesc, dyData, dzDesc, dzData, dxDesc, dxData, dBnScaleBiasDesc, bnScaleData, bnBiasData, dBnScaleData, dBnBiasData, epsilon, savedMean, savedInvVariance, activationDesc, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBatchNormalizationBackwardEx);
	}
	return res;
}

cudnnStatus_t cudnnGetNormalizationForwardTrainingWorkspaceSize(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  zDesc, const cudnnTensorDescriptor_t  yDesc, const cudnnTensorDescriptor_t  normScaleBiasDesc, const cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  normMeanVarDesc, size_t * sizeInBytes, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnGetNormalizationForwardTrainingWorkspaceSize) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int );
	if (!lcudnnGetNormalizationForwardTrainingWorkspaceSize) {
		lcudnnGetNormalizationForwardTrainingWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int )) dlsym(tracer.cudnn_handle, "cudnnGetNormalizationForwardTrainingWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetNormalizationForwardTrainingWorkspaceSize] = std::string("cudnnGetNormalizationForwardTrainingWorkspaceSize");
	}
	assert(lcudnnGetNormalizationForwardTrainingWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetNormalizationForwardTrainingWorkspaceSize(handle, mode, normOps, algo, xDesc, zDesc, yDesc, normScaleBiasDesc, activationDesc, normMeanVarDesc, sizeInBytes, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetNormalizationForwardTrainingWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnGetNormalizationBackwardWorkspaceSize(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  yDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnTensorDescriptor_t  dzDesc, const cudnnTensorDescriptor_t  dxDesc, const cudnnTensorDescriptor_t  dNormScaleBiasDesc, const cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  normMeanVarDesc, size_t * sizeInBytes, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnGetNormalizationBackwardWorkspaceSize) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int );
	if (!lcudnnGetNormalizationBackwardWorkspaceSize) {
		lcudnnGetNormalizationBackwardWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int )) dlsym(tracer.cudnn_handle, "cudnnGetNormalizationBackwardWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetNormalizationBackwardWorkspaceSize] = std::string("cudnnGetNormalizationBackwardWorkspaceSize");
	}
	assert(lcudnnGetNormalizationBackwardWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetNormalizationBackwardWorkspaceSize(handle, mode, normOps, algo, xDesc, yDesc, dyDesc, dzDesc, dxDesc, dNormScaleBiasDesc, activationDesc, normMeanVarDesc, sizeInBytes, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetNormalizationBackwardWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnGetNormalizationTrainingReserveSpaceSize(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  xDesc, size_t * sizeInBytes, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnGetNormalizationTrainingReserveSpaceSize) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int );
	if (!lcudnnGetNormalizationTrainingReserveSpaceSize) {
		lcudnnGetNormalizationTrainingReserveSpaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , size_t *, int )) dlsym(tracer.cudnn_handle, "cudnnGetNormalizationTrainingReserveSpaceSize");
		tracer._kernel_map[(void *) lcudnnGetNormalizationTrainingReserveSpaceSize] = std::string("cudnnGetNormalizationTrainingReserveSpaceSize");
	}
	assert(lcudnnGetNormalizationTrainingReserveSpaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetNormalizationTrainingReserveSpaceSize(handle, mode, normOps, algo, activationDesc, xDesc, sizeInBytes, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetNormalizationTrainingReserveSpaceSize);
	}
	return res;
}

cudnnStatus_t cudnnNormalizationForwardTraining(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const void * alpha, const void * beta, const cudnnTensorDescriptor_t  xDesc, const void * xData, const cudnnTensorDescriptor_t  normScaleBiasDesc, const void * normScale, const void * normBias, double  exponentialAverageFactor, const cudnnTensorDescriptor_t  normMeanVarDesc, void * resultRunningMean, void * resultRunningVariance, double  epsilon, void * resultSaveMean, void * resultSaveInvVariance, cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  zDesc, const void * zData, const cudnnTensorDescriptor_t  yDesc, void * yData, void * workspace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnNormalizationForwardTraining) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, double , const cudnnTensorDescriptor_t , void *, void *, double , void *, void *, cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t , int );
	if (!lcudnnNormalizationForwardTraining) {
		lcudnnNormalizationForwardTraining = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, double , const cudnnTensorDescriptor_t , void *, void *, double , void *, void *, cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t , int )) dlsym(tracer.cudnn_handle, "cudnnNormalizationForwardTraining");
		tracer._kernel_map[(void *) lcudnnNormalizationForwardTraining] = std::string("cudnnNormalizationForwardTraining");
	}
	assert(lcudnnNormalizationForwardTraining);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnNormalizationForwardTraining(handle, mode, normOps, algo, alpha, beta, xDesc, xData, normScaleBiasDesc, normScale, normBias, exponentialAverageFactor, normMeanVarDesc, resultRunningMean, resultRunningVariance, epsilon, resultSaveMean, resultSaveInvVariance, activationDesc, zDesc, zData, yDesc, yData, workspace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnNormalizationForwardTraining);
	}
	return res;
}

cudnnStatus_t cudnnNormalizationBackward(cudnnHandle_t  handle, cudnnNormMode_t  mode, cudnnNormOps_t  normOps, cudnnNormAlgo_t  algo, const void * alphaDataDiff, const void * betaDataDiff, const void * alphaParamDiff, const void * betaParamDiff, const cudnnTensorDescriptor_t  xDesc, const void * xData, const cudnnTensorDescriptor_t  yDesc, const void * yData, const cudnnTensorDescriptor_t  dyDesc, const void * dyData, const cudnnTensorDescriptor_t  dzDesc, void * dzData, const cudnnTensorDescriptor_t  dxDesc, void * dxData, const cudnnTensorDescriptor_t  dNormScaleBiasDesc, const void * normScaleData, const void * normBiasData, void * dNormScaleData, void * dNormBiasData, double  epsilon, const cudnnTensorDescriptor_t  normMeanVarDesc, const void * savedMean, const void * savedInvVariance, cudnnActivationDescriptor_t  activationDesc, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes, int  groupCnt)
{
	static cudnnStatus_t (*lcudnnNormalizationBackward) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, double , const cudnnTensorDescriptor_t , const void *, const void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t , int );
	if (!lcudnnNormalizationBackward) {
		lcudnnNormalizationBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnNormMode_t , cudnnNormOps_t , cudnnNormAlgo_t , const void *, const void *, const void *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , const void *, const void *, void *, void *, double , const cudnnTensorDescriptor_t , const void *, const void *, cudnnActivationDescriptor_t , void *, size_t , void *, size_t , int )) dlsym(tracer.cudnn_handle, "cudnnNormalizationBackward");
		tracer._kernel_map[(void *) lcudnnNormalizationBackward] = std::string("cudnnNormalizationBackward");
	}
	assert(lcudnnNormalizationBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnNormalizationBackward(handle, mode, normOps, algo, alphaDataDiff, betaDataDiff, alphaParamDiff, betaParamDiff, xDesc, xData, yDesc, yData, dyDesc, dyData, dzDesc, dzData, dxDesc, dxData, dNormScaleBiasDesc, normScaleData, normBiasData, dNormScaleData, dNormBiasData, epsilon, normMeanVarDesc, savedMean, savedInvVariance, activationDesc, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes, groupCnt);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnNormalizationBackward);
	}
	return res;
}

cudnnStatus_t cudnnSpatialTfGridGeneratorBackward(cudnnHandle_t  handle, const cudnnSpatialTransformerDescriptor_t  stDesc, const void * dgrid, void * dtheta)
{
	static cudnnStatus_t (*lcudnnSpatialTfGridGeneratorBackward) (cudnnHandle_t , const cudnnSpatialTransformerDescriptor_t , const void *, void *);
	if (!lcudnnSpatialTfGridGeneratorBackward) {
		lcudnnSpatialTfGridGeneratorBackward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnSpatialTransformerDescriptor_t , const void *, void *)) dlsym(tracer.cudnn_handle, "cudnnSpatialTfGridGeneratorBackward");
		tracer._kernel_map[(void *) lcudnnSpatialTfGridGeneratorBackward] = std::string("cudnnSpatialTfGridGeneratorBackward");
	}
	assert(lcudnnSpatialTfGridGeneratorBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSpatialTfGridGeneratorBackward(handle, stDesc, dgrid, dtheta);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSpatialTfGridGeneratorBackward);
	}
	return res;
}

cudnnStatus_t cudnnSpatialTfSamplerBackward(cudnnHandle_t  handle, cudnnSpatialTransformerDescriptor_t  stDesc, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx, const void * alphaDgrid, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const void * grid, const void * betaDgrid, void * dgrid)
{
	static cudnnStatus_t (*lcudnnSpatialTfSamplerBackward) (cudnnHandle_t , cudnnSpatialTransformerDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, void *);
	if (!lcudnnSpatialTfSamplerBackward) {
		lcudnnSpatialTfSamplerBackward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnSpatialTransformerDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *, const void *, const cudnnTensorDescriptor_t , const void *, const void *, const void *, void *)) dlsym(tracer.cudnn_handle, "cudnnSpatialTfSamplerBackward");
		tracer._kernel_map[(void *) lcudnnSpatialTfSamplerBackward] = std::string("cudnnSpatialTfSamplerBackward");
	}
	assert(lcudnnSpatialTfSamplerBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSpatialTfSamplerBackward(handle, stDesc, alpha, xDesc, x, beta, dxDesc, dx, alphaDgrid, dyDesc, dy, grid, betaDgrid, dgrid);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSpatialTfSamplerBackward);
	}
	return res;
}

cudnnStatus_t cudnnDropoutBackward(cudnnHandle_t  handle, const cudnnDropoutDescriptor_t  dropoutDesc, const cudnnTensorDescriptor_t  dydesc, const void * dy, const cudnnTensorDescriptor_t  dxdesc, void * dx, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnDropoutBackward) (cudnnHandle_t , const cudnnDropoutDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t );
	if (!lcudnnDropoutBackward) {
		lcudnnDropoutBackward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnDropoutDescriptor_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , void *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnDropoutBackward");
		tracer._kernel_map[(void *) lcudnnDropoutBackward] = std::string("cudnnDropoutBackward");
	}
	assert(lcudnnDropoutBackward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDropoutBackward(handle, dropoutDesc, dydesc, dy, dxdesc, dx, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDropoutBackward);
	}
	return res;
}

cudnnStatus_t cudnnOpsTrainVersionCheck()
{
	static cudnnStatus_t (*lcudnnOpsTrainVersionCheck) ();
	if (!lcudnnOpsTrainVersionCheck) {
		lcudnnOpsTrainVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnOpsTrainVersionCheck");
		tracer._kernel_map[(void *) lcudnnOpsTrainVersionCheck] = std::string("cudnnOpsTrainVersionCheck");
	}
	assert(lcudnnOpsTrainVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnOpsTrainVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnOpsTrainVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnCreateRNNDescriptor(cudnnRNNDescriptor_t * rnnDesc)
{
	static cudnnStatus_t (*lcudnnCreateRNNDescriptor) (cudnnRNNDescriptor_t *);
	if (!lcudnnCreateRNNDescriptor) {
		lcudnnCreateRNNDescriptor = (cudnnStatus_t (*) (cudnnRNNDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateRNNDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateRNNDescriptor] = std::string("cudnnCreateRNNDescriptor");
	}
	assert(lcudnnCreateRNNDescriptor);
	cudnnStatus_t res = 
		lcudnnCreateRNNDescriptor(rnnDesc);
	return res;
}

cudnnStatus_t cudnnDestroyRNNDescriptor(cudnnRNNDescriptor_t  rnnDesc)
{
	static cudnnStatus_t (*lcudnnDestroyRNNDescriptor) (cudnnRNNDescriptor_t );
	if (!lcudnnDestroyRNNDescriptor) {
		lcudnnDestroyRNNDescriptor = (cudnnStatus_t (*) (cudnnRNNDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyRNNDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyRNNDescriptor] = std::string("cudnnDestroyRNNDescriptor");
	}
	assert(lcudnnDestroyRNNDescriptor);
	cudnnStatus_t res = 
		lcudnnDestroyRNNDescriptor(rnnDesc);
	return res;
}

cudnnStatus_t cudnnSetRNNDescriptor_v8(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNAlgo_t  algo, cudnnRNNMode_t  cellMode, cudnnRNNBiasMode_t  biasMode, cudnnDirectionMode_t  dirMode, cudnnRNNInputMode_t  inputMode, cudnnDataType_t  dataType, cudnnDataType_t  mathPrec, cudnnMathType_t  mathType, int32_t  inputSize, int32_t  hiddenSize, int32_t  projSize, int32_t  numLayers, cudnnDropoutDescriptor_t  dropoutDesc, uint32_t  auxFlags)
{
	static cudnnStatus_t (*lcudnnSetRNNDescriptor_v8) (cudnnRNNDescriptor_t , cudnnRNNAlgo_t , cudnnRNNMode_t , cudnnRNNBiasMode_t , cudnnDirectionMode_t , cudnnRNNInputMode_t , cudnnDataType_t , cudnnDataType_t , cudnnMathType_t , int32_t , int32_t , int32_t , int32_t , cudnnDropoutDescriptor_t , uint32_t );
	if (!lcudnnSetRNNDescriptor_v8) {
		lcudnnSetRNNDescriptor_v8 = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNAlgo_t , cudnnRNNMode_t , cudnnRNNBiasMode_t , cudnnDirectionMode_t , cudnnRNNInputMode_t , cudnnDataType_t , cudnnDataType_t , cudnnMathType_t , int32_t , int32_t , int32_t , int32_t , cudnnDropoutDescriptor_t , uint32_t )) dlsym(tracer.cudnn_handle, "cudnnSetRNNDescriptor_v8");
		tracer._kernel_map[(void *) lcudnnSetRNNDescriptor_v8] = std::string("cudnnSetRNNDescriptor_v8");
	}
	assert(lcudnnSetRNNDescriptor_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNDescriptor_v8(rnnDesc, algo, cellMode, biasMode, dirMode, inputMode, dataType, mathPrec, mathType, inputSize, hiddenSize, projSize, numLayers, dropoutDesc, auxFlags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNDescriptor_v8);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNDescriptor_v8(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNAlgo_t * algo, cudnnRNNMode_t * cellMode, cudnnRNNBiasMode_t * biasMode, cudnnDirectionMode_t * dirMode, cudnnRNNInputMode_t * inputMode, cudnnDataType_t * dataType, cudnnDataType_t * mathPrec, cudnnMathType_t * mathType, int32_t * inputSize, int32_t * hiddenSize, int32_t * projSize, int32_t * numLayers, cudnnDropoutDescriptor_t * dropoutDesc, uint32_t * auxFlags)
{
	static cudnnStatus_t (*lcudnnGetRNNDescriptor_v8) (cudnnRNNDescriptor_t , cudnnRNNAlgo_t *, cudnnRNNMode_t *, cudnnRNNBiasMode_t *, cudnnDirectionMode_t *, cudnnRNNInputMode_t *, cudnnDataType_t *, cudnnDataType_t *, cudnnMathType_t *, int32_t *, int32_t *, int32_t *, int32_t *, cudnnDropoutDescriptor_t *, uint32_t *);
	if (!lcudnnGetRNNDescriptor_v8) {
		lcudnnGetRNNDescriptor_v8 = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNAlgo_t *, cudnnRNNMode_t *, cudnnRNNBiasMode_t *, cudnnDirectionMode_t *, cudnnRNNInputMode_t *, cudnnDataType_t *, cudnnDataType_t *, cudnnMathType_t *, int32_t *, int32_t *, int32_t *, int32_t *, cudnnDropoutDescriptor_t *, uint32_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNDescriptor_v8");
		tracer._kernel_map[(void *) lcudnnGetRNNDescriptor_v8] = std::string("cudnnGetRNNDescriptor_v8");
	}
	assert(lcudnnGetRNNDescriptor_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNDescriptor_v8(rnnDesc, algo, cellMode, biasMode, dirMode, inputMode, dataType, mathPrec, mathType, inputSize, hiddenSize, projSize, numLayers, dropoutDesc, auxFlags);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNDescriptor_v8);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNDescriptor_v6(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, const int  hiddenSize, const int  numLayers, cudnnDropoutDescriptor_t  dropoutDesc, cudnnRNNInputMode_t  inputMode, cudnnDirectionMode_t  direction, cudnnRNNMode_t  cellMode, cudnnRNNAlgo_t  algo, cudnnDataType_t  mathPrec)
{
	static cudnnStatus_t (*lcudnnSetRNNDescriptor_v6) (cudnnHandle_t , cudnnRNNDescriptor_t , const int , const int , cudnnDropoutDescriptor_t , cudnnRNNInputMode_t , cudnnDirectionMode_t , cudnnRNNMode_t , cudnnRNNAlgo_t , cudnnDataType_t );
	if (!lcudnnSetRNNDescriptor_v6) {
		lcudnnSetRNNDescriptor_v6 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , const int , const int , cudnnDropoutDescriptor_t , cudnnRNNInputMode_t , cudnnDirectionMode_t , cudnnRNNMode_t , cudnnRNNAlgo_t , cudnnDataType_t )) dlsym(tracer.cudnn_handle, "cudnnSetRNNDescriptor_v6");
		tracer._kernel_map[(void *) lcudnnSetRNNDescriptor_v6] = std::string("cudnnSetRNNDescriptor_v6");
	}
	assert(lcudnnSetRNNDescriptor_v6);
	cudnnStatus_t res = 
		lcudnnSetRNNDescriptor_v6(handle, rnnDesc, hiddenSize, numLayers, dropoutDesc, inputMode, direction, cellMode, algo, mathPrec);
	return res;
}

cudnnStatus_t cudnnGetRNNDescriptor_v6(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, int * hiddenSize, int * numLayers, cudnnDropoutDescriptor_t * dropoutDesc, cudnnRNNInputMode_t * inputMode, cudnnDirectionMode_t * direction, cudnnRNNMode_t * cellMode, cudnnRNNAlgo_t * algo, cudnnDataType_t * mathPrec)
{
	static cudnnStatus_t (*lcudnnGetRNNDescriptor_v6) (cudnnHandle_t , cudnnRNNDescriptor_t , int *, int *, cudnnDropoutDescriptor_t *, cudnnRNNInputMode_t *, cudnnDirectionMode_t *, cudnnRNNMode_t *, cudnnRNNAlgo_t *, cudnnDataType_t *);
	if (!lcudnnGetRNNDescriptor_v6) {
		lcudnnGetRNNDescriptor_v6 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , int *, int *, cudnnDropoutDescriptor_t *, cudnnRNNInputMode_t *, cudnnDirectionMode_t *, cudnnRNNMode_t *, cudnnRNNAlgo_t *, cudnnDataType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNDescriptor_v6");
		tracer._kernel_map[(void *) lcudnnGetRNNDescriptor_v6] = std::string("cudnnGetRNNDescriptor_v6");
	}
	assert(lcudnnGetRNNDescriptor_v6);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNDescriptor_v6(handle, rnnDesc, hiddenSize, numLayers, dropoutDesc, inputMode, direction, cellMode, algo, mathPrec);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNDescriptor_v6);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNMatrixMathType(cudnnRNNDescriptor_t  rnnDesc, cudnnMathType_t  mType)
{
	static cudnnStatus_t (*lcudnnSetRNNMatrixMathType) (cudnnRNNDescriptor_t , cudnnMathType_t );
	if (!lcudnnSetRNNMatrixMathType) {
		lcudnnSetRNNMatrixMathType = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnMathType_t )) dlsym(tracer.cudnn_handle, "cudnnSetRNNMatrixMathType");
		tracer._kernel_map[(void *) lcudnnSetRNNMatrixMathType] = std::string("cudnnSetRNNMatrixMathType");
	}
	assert(lcudnnSetRNNMatrixMathType);
	cudnnStatus_t res = 
		lcudnnSetRNNMatrixMathType(rnnDesc, mType);
	return res;
}

cudnnStatus_t cudnnGetRNNMatrixMathType(cudnnRNNDescriptor_t  rnnDesc, cudnnMathType_t * mType)
{
	static cudnnStatus_t (*lcudnnGetRNNMatrixMathType) (cudnnRNNDescriptor_t , cudnnMathType_t *);
	if (!lcudnnGetRNNMatrixMathType) {
		lcudnnGetRNNMatrixMathType = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnMathType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNMatrixMathType");
		tracer._kernel_map[(void *) lcudnnGetRNNMatrixMathType] = std::string("cudnnGetRNNMatrixMathType");
	}
	assert(lcudnnGetRNNMatrixMathType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNMatrixMathType(rnnDesc, mType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNMatrixMathType);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNBiasMode(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNBiasMode_t  biasMode)
{
	static cudnnStatus_t (*lcudnnSetRNNBiasMode) (cudnnRNNDescriptor_t , cudnnRNNBiasMode_t );
	if (!lcudnnSetRNNBiasMode) {
		lcudnnSetRNNBiasMode = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNBiasMode_t )) dlsym(tracer.cudnn_handle, "cudnnSetRNNBiasMode");
		tracer._kernel_map[(void *) lcudnnSetRNNBiasMode] = std::string("cudnnSetRNNBiasMode");
	}
	assert(lcudnnSetRNNBiasMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNBiasMode(rnnDesc, biasMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNBiasMode);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNBiasMode(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNBiasMode_t * biasMode)
{
	static cudnnStatus_t (*lcudnnGetRNNBiasMode) (cudnnRNNDescriptor_t , cudnnRNNBiasMode_t *);
	if (!lcudnnGetRNNBiasMode) {
		lcudnnGetRNNBiasMode = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNBiasMode_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNBiasMode");
		tracer._kernel_map[(void *) lcudnnGetRNNBiasMode] = std::string("cudnnGetRNNBiasMode");
	}
	assert(lcudnnGetRNNBiasMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNBiasMode(rnnDesc, biasMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNBiasMode);
	}
	return res;
}

cudnnStatus_t cudnnRNNSetClip_v8(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNClipMode_t  clipMode, cudnnNanPropagation_t  clipNanOpt, double  lclip, double  rclip)
{
	static cudnnStatus_t (*lcudnnRNNSetClip_v8) (cudnnRNNDescriptor_t , cudnnRNNClipMode_t , cudnnNanPropagation_t , double , double );
	if (!lcudnnRNNSetClip_v8) {
		lcudnnRNNSetClip_v8 = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNClipMode_t , cudnnNanPropagation_t , double , double )) dlsym(tracer.cudnn_handle, "cudnnRNNSetClip_v8");
		tracer._kernel_map[(void *) lcudnnRNNSetClip_v8] = std::string("cudnnRNNSetClip_v8");
	}
	assert(lcudnnRNNSetClip_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNSetClip_v8(rnnDesc, clipMode, clipNanOpt, lclip, rclip);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNSetClip_v8);
	}
	return res;
}

cudnnStatus_t cudnnRNNGetClip_v8(cudnnRNNDescriptor_t  rnnDesc, cudnnRNNClipMode_t * clipMode, cudnnNanPropagation_t * clipNanOpt, double * lclip, double * rclip)
{
	static cudnnStatus_t (*lcudnnRNNGetClip_v8) (cudnnRNNDescriptor_t , cudnnRNNClipMode_t *, cudnnNanPropagation_t *, double *, double *);
	if (!lcudnnRNNGetClip_v8) {
		lcudnnRNNGetClip_v8 = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnRNNClipMode_t *, cudnnNanPropagation_t *, double *, double *)) dlsym(tracer.cudnn_handle, "cudnnRNNGetClip_v8");
		tracer._kernel_map[(void *) lcudnnRNNGetClip_v8] = std::string("cudnnRNNGetClip_v8");
	}
	assert(lcudnnRNNGetClip_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNGetClip_v8(rnnDesc, clipMode, clipNanOpt, lclip, rclip);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNGetClip_v8);
	}
	return res;
}

cudnnStatus_t cudnnRNNSetClip(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnRNNClipMode_t  clipMode, cudnnNanPropagation_t  clipNanOpt, double  lclip, double  rclip)
{
	static cudnnStatus_t (*lcudnnRNNSetClip) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnRNNClipMode_t , cudnnNanPropagation_t , double , double );
	if (!lcudnnRNNSetClip) {
		lcudnnRNNSetClip = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnRNNClipMode_t , cudnnNanPropagation_t , double , double )) dlsym(tracer.cudnn_handle, "cudnnRNNSetClip");
		tracer._kernel_map[(void *) lcudnnRNNSetClip] = std::string("cudnnRNNSetClip");
	}
	assert(lcudnnRNNSetClip);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNSetClip(handle, rnnDesc, clipMode, clipNanOpt, lclip, rclip);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNSetClip);
	}
	return res;
}

cudnnStatus_t cudnnRNNGetClip(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnRNNClipMode_t * clipMode, cudnnNanPropagation_t * clipNanOpt, double * lclip, double * rclip)
{
	static cudnnStatus_t (*lcudnnRNNGetClip) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnRNNClipMode_t *, cudnnNanPropagation_t *, double *, double *);
	if (!lcudnnRNNGetClip) {
		lcudnnRNNGetClip = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnRNNClipMode_t *, cudnnNanPropagation_t *, double *, double *)) dlsym(tracer.cudnn_handle, "cudnnRNNGetClip");
		tracer._kernel_map[(void *) lcudnnRNNGetClip] = std::string("cudnnRNNGetClip");
	}
	assert(lcudnnRNNGetClip);
	cudnnStatus_t res = 
		lcudnnRNNGetClip(handle, rnnDesc, clipMode, clipNanOpt, lclip, rclip);
	return res;
}

cudnnStatus_t cudnnSetRNNProjectionLayers(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, const int  recProjSize, const int  outProjSize)
{
	static cudnnStatus_t (*lcudnnSetRNNProjectionLayers) (cudnnHandle_t , cudnnRNNDescriptor_t , const int , const int );
	if (!lcudnnSetRNNProjectionLayers) {
		lcudnnSetRNNProjectionLayers = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , const int , const int )) dlsym(tracer.cudnn_handle, "cudnnSetRNNProjectionLayers");
		tracer._kernel_map[(void *) lcudnnSetRNNProjectionLayers] = std::string("cudnnSetRNNProjectionLayers");
	}
	assert(lcudnnSetRNNProjectionLayers);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNProjectionLayers(handle, rnnDesc, recProjSize, outProjSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNProjectionLayers);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNProjectionLayers(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, int * recProjSize, int * outProjSize)
{
	static cudnnStatus_t (*lcudnnGetRNNProjectionLayers) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *, int *);
	if (!lcudnnGetRNNProjectionLayers) {
		lcudnnGetRNNProjectionLayers = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNProjectionLayers");
		tracer._kernel_map[(void *) lcudnnGetRNNProjectionLayers] = std::string("cudnnGetRNNProjectionLayers");
	}
	assert(lcudnnGetRNNProjectionLayers);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNProjectionLayers(handle, rnnDesc, recProjSize, outProjSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNProjectionLayers);
	}
	return res;
}

cudnnStatus_t cudnnCreatePersistentRNNPlan(cudnnRNNDescriptor_t  rnnDesc, const int  minibatch, const cudnnDataType_t  dataType, cudnnPersistentRNNPlan_t * plan)
{
	static cudnnStatus_t (*lcudnnCreatePersistentRNNPlan) (cudnnRNNDescriptor_t , const int , const cudnnDataType_t , cudnnPersistentRNNPlan_t *);
	if (!lcudnnCreatePersistentRNNPlan) {
		lcudnnCreatePersistentRNNPlan = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , const int , const cudnnDataType_t , cudnnPersistentRNNPlan_t *)) dlsym(tracer.cudnn_handle, "cudnnCreatePersistentRNNPlan");
		tracer._kernel_map[(void *) lcudnnCreatePersistentRNNPlan] = std::string("cudnnCreatePersistentRNNPlan");
	}
	assert(lcudnnCreatePersistentRNNPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreatePersistentRNNPlan(rnnDesc, minibatch, dataType, plan);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreatePersistentRNNPlan);
	}
	return res;
}

cudnnStatus_t cudnnDestroyPersistentRNNPlan(cudnnPersistentRNNPlan_t  plan)
{
	static cudnnStatus_t (*lcudnnDestroyPersistentRNNPlan) (cudnnPersistentRNNPlan_t );
	if (!lcudnnDestroyPersistentRNNPlan) {
		lcudnnDestroyPersistentRNNPlan = (cudnnStatus_t (*) (cudnnPersistentRNNPlan_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyPersistentRNNPlan");
		tracer._kernel_map[(void *) lcudnnDestroyPersistentRNNPlan] = std::string("cudnnDestroyPersistentRNNPlan");
	}
	assert(lcudnnDestroyPersistentRNNPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyPersistentRNNPlan(plan);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyPersistentRNNPlan);
	}
	return res;
}

cudnnStatus_t cudnnSetPersistentRNNPlan(cudnnRNNDescriptor_t  rnnDesc, cudnnPersistentRNNPlan_t  plan)
{
	static cudnnStatus_t (*lcudnnSetPersistentRNNPlan) (cudnnRNNDescriptor_t , cudnnPersistentRNNPlan_t );
	if (!lcudnnSetPersistentRNNPlan) {
		lcudnnSetPersistentRNNPlan = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , cudnnPersistentRNNPlan_t )) dlsym(tracer.cudnn_handle, "cudnnSetPersistentRNNPlan");
		tracer._kernel_map[(void *) lcudnnSetPersistentRNNPlan] = std::string("cudnnSetPersistentRNNPlan");
	}
	assert(lcudnnSetPersistentRNNPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetPersistentRNNPlan(rnnDesc, plan);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetPersistentRNNPlan);
	}
	return res;
}

cudnnStatus_t cudnnBuildRNNDynamic(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, int  miniBatch)
{
	static cudnnStatus_t (*lcudnnBuildRNNDynamic) (cudnnHandle_t , cudnnRNNDescriptor_t , int );
	if (!lcudnnBuildRNNDynamic) {
		lcudnnBuildRNNDynamic = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , int )) dlsym(tracer.cudnn_handle, "cudnnBuildRNNDynamic");
		tracer._kernel_map[(void *) lcudnnBuildRNNDynamic] = std::string("cudnnBuildRNNDynamic");
	}
	assert(lcudnnBuildRNNDynamic);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBuildRNNDynamic(handle, rnnDesc, miniBatch);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBuildRNNDynamic);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNWorkspaceSize(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetRNNWorkspaceSize) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, size_t *);
	if (!lcudnnGetRNNWorkspaceSize) {
		lcudnnGetRNNWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetRNNWorkspaceSize] = std::string("cudnnGetRNNWorkspaceSize");
	}
	assert(lcudnnGetRNNWorkspaceSize);
	cudnnStatus_t res = 
		lcudnnGetRNNWorkspaceSize(handle, rnnDesc, seqLength, xDesc, sizeInBytes);
	return res;
}

cudnnStatus_t cudnnGetRNNTrainingReserveSize(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetRNNTrainingReserveSize) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, size_t *);
	if (!lcudnnGetRNNTrainingReserveSize) {
		lcudnnGetRNNTrainingReserveSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNTrainingReserveSize");
		tracer._kernel_map[(void *) lcudnnGetRNNTrainingReserveSize] = std::string("cudnnGetRNNTrainingReserveSize");
	}
	assert(lcudnnGetRNNTrainingReserveSize);
	cudnnStatus_t res = 
		lcudnnGetRNNTrainingReserveSize(handle, rnnDesc, seqLength, xDesc, sizeInBytes);
	return res;
}

cudnnStatus_t cudnnGetRNNTempSpaceSizes(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnForwardMode_t  fwdMode, cudnnRNNDataDescriptor_t  xDesc, size_t * workSpaceSize, size_t * reserveSpaceSize)
{
	static cudnnStatus_t (*lcudnnGetRNNTempSpaceSizes) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnForwardMode_t , cudnnRNNDataDescriptor_t , size_t *, size_t *);
	if (!lcudnnGetRNNTempSpaceSizes) {
		lcudnnGetRNNTempSpaceSizes = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnForwardMode_t , cudnnRNNDataDescriptor_t , size_t *, size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNTempSpaceSizes");
		tracer._kernel_map[(void *) lcudnnGetRNNTempSpaceSizes] = std::string("cudnnGetRNNTempSpaceSizes");
	}
	assert(lcudnnGetRNNTempSpaceSizes);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNTempSpaceSizes(handle, rnnDesc, fwdMode, xDesc, workSpaceSize, reserveSpaceSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNTempSpaceSizes);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNParamsSize(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const cudnnTensorDescriptor_t  xDesc, size_t * sizeInBytes, cudnnDataType_t  dataType)
{
	static cudnnStatus_t (*lcudnnGetRNNParamsSize) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnTensorDescriptor_t , size_t *, cudnnDataType_t );
	if (!lcudnnGetRNNParamsSize) {
		lcudnnGetRNNParamsSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnTensorDescriptor_t , size_t *, cudnnDataType_t )) dlsym(tracer.cudnn_handle, "cudnnGetRNNParamsSize");
		tracer._kernel_map[(void *) lcudnnGetRNNParamsSize] = std::string("cudnnGetRNNParamsSize");
	}
	assert(lcudnnGetRNNParamsSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNParamsSize(handle, rnnDesc, xDesc, sizeInBytes, dataType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNParamsSize);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNWeightSpaceSize(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, size_t * weightSpaceSize)
{
	static cudnnStatus_t (*lcudnnGetRNNWeightSpaceSize) (cudnnHandle_t , cudnnRNNDescriptor_t , size_t *);
	if (!lcudnnGetRNNWeightSpaceSize) {
		lcudnnGetRNNWeightSpaceSize = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNWeightSpaceSize");
		tracer._kernel_map[(void *) lcudnnGetRNNWeightSpaceSize] = std::string("cudnnGetRNNWeightSpaceSize");
	}
	assert(lcudnnGetRNNWeightSpaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNWeightSpaceSize(handle, rnnDesc, weightSpaceSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNWeightSpaceSize);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNLinLayerMatrixParams(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  pseudoLayer, const cudnnTensorDescriptor_t  xDesc, const cudnnFilterDescriptor_t  wDesc, const void * w, const int  linLayerID, cudnnFilterDescriptor_t  linLayerMatDesc, void ** linLayerMat)
{
	static cudnnStatus_t (*lcudnnGetRNNLinLayerMatrixParams) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const void *, const int , cudnnFilterDescriptor_t , void **);
	if (!lcudnnGetRNNLinLayerMatrixParams) {
		lcudnnGetRNNLinLayerMatrixParams = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const void *, const int , cudnnFilterDescriptor_t , void **)) dlsym(tracer.cudnn_handle, "cudnnGetRNNLinLayerMatrixParams");
		tracer._kernel_map[(void *) lcudnnGetRNNLinLayerMatrixParams] = std::string("cudnnGetRNNLinLayerMatrixParams");
	}
	assert(lcudnnGetRNNLinLayerMatrixParams);
	cudnnStatus_t res = 
		lcudnnGetRNNLinLayerMatrixParams(handle, rnnDesc, pseudoLayer, xDesc, wDesc, w, linLayerID, linLayerMatDesc, linLayerMat);
	return res;
}

cudnnStatus_t cudnnGetRNNLinLayerBiasParams(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  pseudoLayer, const cudnnTensorDescriptor_t  xDesc, const cudnnFilterDescriptor_t  wDesc, const void * w, const int  linLayerID, cudnnFilterDescriptor_t  linLayerBiasDesc, void ** linLayerBias)
{
	static cudnnStatus_t (*lcudnnGetRNNLinLayerBiasParams) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const void *, const int , cudnnFilterDescriptor_t , void **);
	if (!lcudnnGetRNNLinLayerBiasParams) {
		lcudnnGetRNNLinLayerBiasParams = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const void *, const int , cudnnFilterDescriptor_t , void **)) dlsym(tracer.cudnn_handle, "cudnnGetRNNLinLayerBiasParams");
		tracer._kernel_map[(void *) lcudnnGetRNNLinLayerBiasParams] = std::string("cudnnGetRNNLinLayerBiasParams");
	}
	assert(lcudnnGetRNNLinLayerBiasParams);
	cudnnStatus_t res = 
		lcudnnGetRNNLinLayerBiasParams(handle, rnnDesc, pseudoLayer, xDesc, wDesc, w, linLayerID, linLayerBiasDesc, linLayerBias);
	return res;
}

cudnnStatus_t cudnnGetRNNWeightParams(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, int32_t  pseudoLayer, size_t  weightSpaceSize, const void * weightSpace, int32_t  linLayerID, cudnnTensorDescriptor_t  mDesc, void ** mAddr, cudnnTensorDescriptor_t  bDesc, void ** bAddr)
{
	static cudnnStatus_t (*lcudnnGetRNNWeightParams) (cudnnHandle_t , cudnnRNNDescriptor_t , int32_t , size_t , const void *, int32_t , cudnnTensorDescriptor_t , void **, cudnnTensorDescriptor_t , void **);
	if (!lcudnnGetRNNWeightParams) {
		lcudnnGetRNNWeightParams = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , int32_t , size_t , const void *, int32_t , cudnnTensorDescriptor_t , void **, cudnnTensorDescriptor_t , void **)) dlsym(tracer.cudnn_handle, "cudnnGetRNNWeightParams");
		tracer._kernel_map[(void *) lcudnnGetRNNWeightParams] = std::string("cudnnGetRNNWeightParams");
	}
	assert(lcudnnGetRNNWeightParams);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNWeightParams(handle, rnnDesc, pseudoLayer, weightSpaceSize, weightSpace, linLayerID, mDesc, mAddr, bDesc, bAddr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNWeightParams);
	}
	return res;
}

cudnnStatus_t cudnnRNNForwardInference(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, void * workSpace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNForwardInference) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t );
	if (!lcudnnRNNForwardInference) {
		lcudnnRNNForwardInference = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNForwardInference");
		tracer._kernel_map[(void *) lcudnnRNNForwardInference] = std::string("cudnnRNNForwardInference");
	}
	assert(lcudnnRNNForwardInference);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNForwardInference(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, workSpace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNForwardInference);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNPaddingMode(cudnnRNNDescriptor_t  rnnDesc, unsigned  paddingMode)
{
	static cudnnStatus_t (*lcudnnSetRNNPaddingMode) (cudnnRNNDescriptor_t , unsigned );
	if (!lcudnnSetRNNPaddingMode) {
		lcudnnSetRNNPaddingMode = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , unsigned )) dlsym(tracer.cudnn_handle, "cudnnSetRNNPaddingMode");
		tracer._kernel_map[(void *) lcudnnSetRNNPaddingMode] = std::string("cudnnSetRNNPaddingMode");
	}
	assert(lcudnnSetRNNPaddingMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNPaddingMode(rnnDesc, paddingMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNPaddingMode);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNPaddingMode(cudnnRNNDescriptor_t  rnnDesc, unsigned * paddingMode)
{
	static cudnnStatus_t (*lcudnnGetRNNPaddingMode) (cudnnRNNDescriptor_t , unsigned *);
	if (!lcudnnGetRNNPaddingMode) {
		lcudnnGetRNNPaddingMode = (cudnnStatus_t (*) (cudnnRNNDescriptor_t , unsigned *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNPaddingMode");
		tracer._kernel_map[(void *) lcudnnGetRNNPaddingMode] = std::string("cudnnGetRNNPaddingMode");
	}
	assert(lcudnnGetRNNPaddingMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNPaddingMode(rnnDesc, paddingMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNPaddingMode);
	}
	return res;
}

cudnnStatus_t cudnnCreateRNNDataDescriptor(cudnnRNNDataDescriptor_t * rnnDataDesc)
{
	static cudnnStatus_t (*lcudnnCreateRNNDataDescriptor) (cudnnRNNDataDescriptor_t *);
	if (!lcudnnCreateRNNDataDescriptor) {
		lcudnnCreateRNNDataDescriptor = (cudnnStatus_t (*) (cudnnRNNDataDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateRNNDataDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateRNNDataDescriptor] = std::string("cudnnCreateRNNDataDescriptor");
	}
	assert(lcudnnCreateRNNDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateRNNDataDescriptor(rnnDataDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateRNNDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyRNNDataDescriptor(cudnnRNNDataDescriptor_t  rnnDataDesc)
{
	static cudnnStatus_t (*lcudnnDestroyRNNDataDescriptor) (cudnnRNNDataDescriptor_t );
	if (!lcudnnDestroyRNNDataDescriptor) {
		lcudnnDestroyRNNDataDescriptor = (cudnnStatus_t (*) (cudnnRNNDataDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyRNNDataDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyRNNDataDescriptor] = std::string("cudnnDestroyRNNDataDescriptor");
	}
	assert(lcudnnDestroyRNNDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyRNNDataDescriptor(rnnDataDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyRNNDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNDataDescriptor(cudnnRNNDataDescriptor_t  rnnDataDesc, cudnnDataType_t  dataType, cudnnRNNDataLayout_t  layout, int  maxSeqLength, int  batchSize, int  vectorSize, const int  seqLengthArray[], void * paddingFill)
{
	static cudnnStatus_t (*lcudnnSetRNNDataDescriptor) (cudnnRNNDataDescriptor_t , cudnnDataType_t , cudnnRNNDataLayout_t , int , int , int , const int [], void *);
	if (!lcudnnSetRNNDataDescriptor) {
		lcudnnSetRNNDataDescriptor = (cudnnStatus_t (*) (cudnnRNNDataDescriptor_t , cudnnDataType_t , cudnnRNNDataLayout_t , int , int , int , const int [], void *)) dlsym(tracer.cudnn_handle, "cudnnSetRNNDataDescriptor");
		tracer._kernel_map[(void *) lcudnnSetRNNDataDescriptor] = std::string("cudnnSetRNNDataDescriptor");
	}
	assert(lcudnnSetRNNDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNDataDescriptor(rnnDataDesc, dataType, layout, maxSeqLength, batchSize, vectorSize, seqLengthArray, paddingFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNDataDescriptor(cudnnRNNDataDescriptor_t  rnnDataDesc, cudnnDataType_t * dataType, cudnnRNNDataLayout_t * layout, int * maxSeqLength, int * batchSize, int * vectorSize, int  arrayLengthRequested, int  seqLengthArray[], void * paddingFill)
{
	static cudnnStatus_t (*lcudnnGetRNNDataDescriptor) (cudnnRNNDataDescriptor_t , cudnnDataType_t *, cudnnRNNDataLayout_t *, int *, int *, int *, int , int [], void *);
	if (!lcudnnGetRNNDataDescriptor) {
		lcudnnGetRNNDataDescriptor = (cudnnStatus_t (*) (cudnnRNNDataDescriptor_t , cudnnDataType_t *, cudnnRNNDataLayout_t *, int *, int *, int *, int , int [], void *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNDataDescriptor");
		tracer._kernel_map[(void *) lcudnnGetRNNDataDescriptor] = std::string("cudnnGetRNNDataDescriptor");
	}
	assert(lcudnnGetRNNDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNDataDescriptor(rnnDataDesc, dataType, layout, maxSeqLength, batchSize, vectorSize, arrayLengthRequested, seqLengthArray, paddingFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnRNNForwardInferenceEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const cudnnRNNDataDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnRNNDataDescriptor_t  yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, const cudnnRNNDataDescriptor_t  kDesc, const void * keys, const cudnnRNNDataDescriptor_t  cDesc, void * cAttn, const cudnnRNNDataDescriptor_t  iDesc, void * iAttn, const cudnnRNNDataDescriptor_t  qDesc, void * queries, void * workSpace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNForwardInferenceEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t );
	if (!lcudnnRNNForwardInferenceEx) {
		lcudnnRNNForwardInferenceEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNForwardInferenceEx");
		tracer._kernel_map[(void *) lcudnnRNNForwardInferenceEx] = std::string("cudnnRNNForwardInferenceEx");
	}
	assert(lcudnnRNNForwardInferenceEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNForwardInferenceEx(handle, rnnDesc, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, kDesc, keys, cDesc, cAttn, iDesc, iAttn, qDesc, queries, workSpace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNForwardInferenceEx);
	}
	return res;
}

cudnnStatus_t cudnnRNNForward(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnForwardMode_t  fwdMode, const int32_t  devSeqLengths[], cudnnRNNDataDescriptor_t  xDesc, const void * x, cudnnRNNDataDescriptor_t  yDesc, void * y, cudnnTensorDescriptor_t  hDesc, const void * hx, void * hy, cudnnTensorDescriptor_t  cDesc, const void * cx, void * cy, size_t  weightSpaceSize, const void * weightSpace, size_t  workSpaceSize, void * workSpace, size_t  reserveSpaceSize, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnRNNForward) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnForwardMode_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, cudnnRNNDataDescriptor_t , void *, cudnnTensorDescriptor_t , const void *, void *, cudnnTensorDescriptor_t , const void *, void *, size_t , const void *, size_t , void *, size_t , void *);
	if (!lcudnnRNNForward) {
		lcudnnRNNForward = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnForwardMode_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, cudnnRNNDataDescriptor_t , void *, cudnnTensorDescriptor_t , const void *, void *, cudnnTensorDescriptor_t , const void *, void *, size_t , const void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnRNNForward");
		tracer._kernel_map[(void *) lcudnnRNNForward] = std::string("cudnnRNNForward");
	}
	assert(lcudnnRNNForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNForward(handle, rnnDesc, fwdMode, devSeqLengths, xDesc, x, yDesc, y, hDesc, hx, hy, cDesc, cx, cy, weightSpaceSize, weightSpace, workSpaceSize, workSpace, reserveSpaceSize, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNForward);
	}
	return res;
}

cudnnStatus_t cudnnSetRNNAlgorithmDescriptor(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnAlgorithmDescriptor_t  algoDesc)
{
	static cudnnStatus_t (*lcudnnSetRNNAlgorithmDescriptor) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnAlgorithmDescriptor_t );
	if (!lcudnnSetRNNAlgorithmDescriptor) {
		lcudnnSetRNNAlgorithmDescriptor = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnAlgorithmDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnSetRNNAlgorithmDescriptor");
		tracer._kernel_map[(void *) lcudnnSetRNNAlgorithmDescriptor] = std::string("cudnnSetRNNAlgorithmDescriptor");
	}
	assert(lcudnnSetRNNAlgorithmDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetRNNAlgorithmDescriptor(handle, rnnDesc, algoDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetRNNAlgorithmDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNForwardInferenceAlgorithmMaxCount(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, int * count)
{
	static cudnnStatus_t (*lcudnnGetRNNForwardInferenceAlgorithmMaxCount) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *);
	if (!lcudnnGetRNNForwardInferenceAlgorithmMaxCount) {
		lcudnnGetRNNForwardInferenceAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNForwardInferenceAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetRNNForwardInferenceAlgorithmMaxCount] = std::string("cudnnGetRNNForwardInferenceAlgorithmMaxCount");
	}
	assert(lcudnnGetRNNForwardInferenceAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNForwardInferenceAlgorithmMaxCount(handle, rnnDesc, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNForwardInferenceAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindRNNForwardInferenceAlgorithmEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, const float  findIntensity, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnAlgorithmPerformance_t * perfResults, void * workspace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindRNNForwardInferenceAlgorithmEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t );
	if (!lcudnnFindRNNForwardInferenceAlgorithmEx) {
		lcudnnFindRNNForwardInferenceAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindRNNForwardInferenceAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindRNNForwardInferenceAlgorithmEx] = std::string("cudnnFindRNNForwardInferenceAlgorithmEx");
	}
	assert(lcudnnFindRNNForwardInferenceAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindRNNForwardInferenceAlgorithmEx(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, findIntensity, requestedAlgoCount, returnedAlgoCount, perfResults, workspace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindRNNForwardInferenceAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnCreateSeqDataDescriptor(cudnnSeqDataDescriptor_t * seqDataDesc)
{
	static cudnnStatus_t (*lcudnnCreateSeqDataDescriptor) (cudnnSeqDataDescriptor_t *);
	if (!lcudnnCreateSeqDataDescriptor) {
		lcudnnCreateSeqDataDescriptor = (cudnnStatus_t (*) (cudnnSeqDataDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateSeqDataDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateSeqDataDescriptor] = std::string("cudnnCreateSeqDataDescriptor");
	}
	assert(lcudnnCreateSeqDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateSeqDataDescriptor(seqDataDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateSeqDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroySeqDataDescriptor(cudnnSeqDataDescriptor_t  seqDataDesc)
{
	static cudnnStatus_t (*lcudnnDestroySeqDataDescriptor) (cudnnSeqDataDescriptor_t );
	if (!lcudnnDestroySeqDataDescriptor) {
		lcudnnDestroySeqDataDescriptor = (cudnnStatus_t (*) (cudnnSeqDataDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroySeqDataDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroySeqDataDescriptor] = std::string("cudnnDestroySeqDataDescriptor");
	}
	assert(lcudnnDestroySeqDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroySeqDataDescriptor(seqDataDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroySeqDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetSeqDataDescriptor(cudnnSeqDataDescriptor_t  seqDataDesc, cudnnDataType_t  dataType, int  nbDims, const int  dimA[], const cudnnSeqDataAxis_t  axes[], size_t  seqLengthArraySize, const int  seqLengthArray[], void * paddingFill)
{
	static cudnnStatus_t (*lcudnnSetSeqDataDescriptor) (cudnnSeqDataDescriptor_t , cudnnDataType_t , int , const int [], const cudnnSeqDataAxis_t [], size_t , const int [], void *);
	if (!lcudnnSetSeqDataDescriptor) {
		lcudnnSetSeqDataDescriptor = (cudnnStatus_t (*) (cudnnSeqDataDescriptor_t , cudnnDataType_t , int , const int [], const cudnnSeqDataAxis_t [], size_t , const int [], void *)) dlsym(tracer.cudnn_handle, "cudnnSetSeqDataDescriptor");
		tracer._kernel_map[(void *) lcudnnSetSeqDataDescriptor] = std::string("cudnnSetSeqDataDescriptor");
	}
	assert(lcudnnSetSeqDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetSeqDataDescriptor(seqDataDesc, dataType, nbDims, dimA, axes, seqLengthArraySize, seqLengthArray, paddingFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetSeqDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetSeqDataDescriptor(const cudnnSeqDataDescriptor_t  seqDataDesc, cudnnDataType_t * dataType, int * nbDims, int  nbDimsRequested, int  dimA[], cudnnSeqDataAxis_t  axes[], size_t * seqLengthArraySize, size_t  seqLengthSizeRequested, int  seqLengthArray[], void * paddingFill)
{
	static cudnnStatus_t (*lcudnnGetSeqDataDescriptor) (const cudnnSeqDataDescriptor_t , cudnnDataType_t *, int *, int , int [], cudnnSeqDataAxis_t [], size_t *, size_t , int [], void *);
	if (!lcudnnGetSeqDataDescriptor) {
		lcudnnGetSeqDataDescriptor = (cudnnStatus_t (*) (const cudnnSeqDataDescriptor_t , cudnnDataType_t *, int *, int , int [], cudnnSeqDataAxis_t [], size_t *, size_t , int [], void *)) dlsym(tracer.cudnn_handle, "cudnnGetSeqDataDescriptor");
		tracer._kernel_map[(void *) lcudnnGetSeqDataDescriptor] = std::string("cudnnGetSeqDataDescriptor");
	}
	assert(lcudnnGetSeqDataDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetSeqDataDescriptor(seqDataDesc, dataType, nbDims, nbDimsRequested, dimA, axes, seqLengthArraySize, seqLengthSizeRequested, seqLengthArray, paddingFill);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetSeqDataDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnCreateAttnDescriptor(cudnnAttnDescriptor_t * attnDesc)
{
	static cudnnStatus_t (*lcudnnCreateAttnDescriptor) (cudnnAttnDescriptor_t *);
	if (!lcudnnCreateAttnDescriptor) {
		lcudnnCreateAttnDescriptor = (cudnnStatus_t (*) (cudnnAttnDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateAttnDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateAttnDescriptor] = std::string("cudnnCreateAttnDescriptor");
	}
	assert(lcudnnCreateAttnDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateAttnDescriptor(attnDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateAttnDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyAttnDescriptor(cudnnAttnDescriptor_t  attnDesc)
{
	static cudnnStatus_t (*lcudnnDestroyAttnDescriptor) (cudnnAttnDescriptor_t );
	if (!lcudnnDestroyAttnDescriptor) {
		lcudnnDestroyAttnDescriptor = (cudnnStatus_t (*) (cudnnAttnDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyAttnDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyAttnDescriptor] = std::string("cudnnDestroyAttnDescriptor");
	}
	assert(lcudnnDestroyAttnDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyAttnDescriptor(attnDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyAttnDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetAttnDescriptor(cudnnAttnDescriptor_t  attnDesc, unsigned  attnMode, int  nHeads, double  smScaler, cudnnDataType_t  dataType, cudnnDataType_t  computePrec, cudnnMathType_t  mathType, cudnnDropoutDescriptor_t  attnDropoutDesc, cudnnDropoutDescriptor_t  postDropoutDesc, int  qSize, int  kSize, int  vSize, int  qProjSize, int  kProjSize, int  vProjSize, int  oProjSize, int  qoMaxSeqLength, int  kvMaxSeqLength, int  maxBatchSize, int  maxBeamSize)
{
	static cudnnStatus_t (*lcudnnSetAttnDescriptor) (cudnnAttnDescriptor_t , unsigned , int , double , cudnnDataType_t , cudnnDataType_t , cudnnMathType_t , cudnnDropoutDescriptor_t , cudnnDropoutDescriptor_t , int , int , int , int , int , int , int , int , int , int , int );
	if (!lcudnnSetAttnDescriptor) {
		lcudnnSetAttnDescriptor = (cudnnStatus_t (*) (cudnnAttnDescriptor_t , unsigned , int , double , cudnnDataType_t , cudnnDataType_t , cudnnMathType_t , cudnnDropoutDescriptor_t , cudnnDropoutDescriptor_t , int , int , int , int , int , int , int , int , int , int , int )) dlsym(tracer.cudnn_handle, "cudnnSetAttnDescriptor");
		tracer._kernel_map[(void *) lcudnnSetAttnDescriptor] = std::string("cudnnSetAttnDescriptor");
	}
	assert(lcudnnSetAttnDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetAttnDescriptor(attnDesc, attnMode, nHeads, smScaler, dataType, computePrec, mathType, attnDropoutDesc, postDropoutDesc, qSize, kSize, vSize, qProjSize, kProjSize, vProjSize, oProjSize, qoMaxSeqLength, kvMaxSeqLength, maxBatchSize, maxBeamSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetAttnDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetAttnDescriptor(cudnnAttnDescriptor_t  attnDesc, unsigned * attnMode, int * nHeads, double * smScaler, cudnnDataType_t * dataType, cudnnDataType_t * computePrec, cudnnMathType_t * mathType, cudnnDropoutDescriptor_t * attnDropoutDesc, cudnnDropoutDescriptor_t * postDropoutDesc, int * qSize, int * kSize, int * vSize, int * qProjSize, int * kProjSize, int * vProjSize, int * oProjSize, int * qoMaxSeqLength, int * kvMaxSeqLength, int * maxBatchSize, int * maxBeamSize)
{
	static cudnnStatus_t (*lcudnnGetAttnDescriptor) (cudnnAttnDescriptor_t , unsigned *, int *, double *, cudnnDataType_t *, cudnnDataType_t *, cudnnMathType_t *, cudnnDropoutDescriptor_t *, cudnnDropoutDescriptor_t *, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *);
	if (!lcudnnGetAttnDescriptor) {
		lcudnnGetAttnDescriptor = (cudnnStatus_t (*) (cudnnAttnDescriptor_t , unsigned *, int *, double *, cudnnDataType_t *, cudnnDataType_t *, cudnnMathType_t *, cudnnDropoutDescriptor_t *, cudnnDropoutDescriptor_t *, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetAttnDescriptor");
		tracer._kernel_map[(void *) lcudnnGetAttnDescriptor] = std::string("cudnnGetAttnDescriptor");
	}
	assert(lcudnnGetAttnDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetAttnDescriptor(attnDesc, attnMode, nHeads, smScaler, dataType, computePrec, mathType, attnDropoutDesc, postDropoutDesc, qSize, kSize, vSize, qProjSize, kProjSize, vProjSize, oProjSize, qoMaxSeqLength, kvMaxSeqLength, maxBatchSize, maxBeamSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetAttnDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetMultiHeadAttnBuffers(cudnnHandle_t  handle, const cudnnAttnDescriptor_t  attnDesc, size_t * weightSizeInBytes, size_t * workSpaceSizeInBytes, size_t * reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetMultiHeadAttnBuffers) (cudnnHandle_t , const cudnnAttnDescriptor_t , size_t *, size_t *, size_t *);
	if (!lcudnnGetMultiHeadAttnBuffers) {
		lcudnnGetMultiHeadAttnBuffers = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnAttnDescriptor_t , size_t *, size_t *, size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetMultiHeadAttnBuffers");
		tracer._kernel_map[(void *) lcudnnGetMultiHeadAttnBuffers] = std::string("cudnnGetMultiHeadAttnBuffers");
	}
	assert(lcudnnGetMultiHeadAttnBuffers);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetMultiHeadAttnBuffers(handle, attnDesc, weightSizeInBytes, workSpaceSizeInBytes, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetMultiHeadAttnBuffers);
	}
	return res;
}

cudnnStatus_t cudnnGetMultiHeadAttnWeights(cudnnHandle_t  handle, const cudnnAttnDescriptor_t  attnDesc, cudnnMultiHeadAttnWeightKind_t  wKind, size_t  weightSizeInBytes, const void * weights, cudnnTensorDescriptor_t  wDesc, void ** wAddr)
{
	static cudnnStatus_t (*lcudnnGetMultiHeadAttnWeights) (cudnnHandle_t , const cudnnAttnDescriptor_t , cudnnMultiHeadAttnWeightKind_t , size_t , const void *, cudnnTensorDescriptor_t , void **);
	if (!lcudnnGetMultiHeadAttnWeights) {
		lcudnnGetMultiHeadAttnWeights = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnAttnDescriptor_t , cudnnMultiHeadAttnWeightKind_t , size_t , const void *, cudnnTensorDescriptor_t , void **)) dlsym(tracer.cudnn_handle, "cudnnGetMultiHeadAttnWeights");
		tracer._kernel_map[(void *) lcudnnGetMultiHeadAttnWeights] = std::string("cudnnGetMultiHeadAttnWeights");
	}
	assert(lcudnnGetMultiHeadAttnWeights);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetMultiHeadAttnWeights(handle, attnDesc, wKind, weightSizeInBytes, weights, wDesc, wAddr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetMultiHeadAttnWeights);
	}
	return res;
}

cudnnStatus_t cudnnMultiHeadAttnForward(cudnnHandle_t  handle, const cudnnAttnDescriptor_t  attnDesc, int  currIdx, const int  loWinIdx[], const int  hiWinIdx[], const int  devSeqLengthsQO[], const int  devSeqLengthsKV[], const cudnnSeqDataDescriptor_t  qDesc, const void * queries, const void * residuals, const cudnnSeqDataDescriptor_t  kDesc, const void * keys, const cudnnSeqDataDescriptor_t  vDesc, const void * values, const cudnnSeqDataDescriptor_t  oDesc, void * out, size_t  weightSizeInBytes, const void * weights, size_t  workSpaceSizeInBytes, void * workSpace, size_t  reserveSpaceSizeInBytes, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnMultiHeadAttnForward) (cudnnHandle_t , const cudnnAttnDescriptor_t , int , const int [], const int [], const int [], const int [], const cudnnSeqDataDescriptor_t , const void *, const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , void *, size_t , const void *, size_t , void *, size_t , void *);
	if (!lcudnnMultiHeadAttnForward) {
		lcudnnMultiHeadAttnForward = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnAttnDescriptor_t , int , const int [], const int [], const int [], const int [], const cudnnSeqDataDescriptor_t , const void *, const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , void *, size_t , const void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnMultiHeadAttnForward");
		tracer._kernel_map[(void *) lcudnnMultiHeadAttnForward] = std::string("cudnnMultiHeadAttnForward");
	}
	assert(lcudnnMultiHeadAttnForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnMultiHeadAttnForward(handle, attnDesc, currIdx, loWinIdx, hiWinIdx, devSeqLengthsQO, devSeqLengthsKV, qDesc, queries, residuals, kDesc, keys, vDesc, values, oDesc, out, weightSizeInBytes, weights, workSpaceSizeInBytes, workSpace, reserveSpaceSizeInBytes, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnMultiHeadAttnForward);
	}
	return res;
}

cudnnStatus_t cudnnAdvInferVersionCheck()
{
	static cudnnStatus_t (*lcudnnAdvInferVersionCheck) ();
	if (!lcudnnAdvInferVersionCheck) {
		lcudnnAdvInferVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnAdvInferVersionCheck");
		tracer._kernel_map[(void *) lcudnnAdvInferVersionCheck] = std::string("cudnnAdvInferVersionCheck");
	}
	assert(lcudnnAdvInferVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnAdvInferVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnAdvInferVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnRNNForwardTraining(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNForwardTraining) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t );
	if (!lcudnnRNNForwardTraining) {
		lcudnnRNNForwardTraining = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNForwardTraining");
		tracer._kernel_map[(void *) lcudnnRNNForwardTraining] = std::string("cudnnRNNForwardTraining");
	}
	assert(lcudnnRNNForwardTraining);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNForwardTraining(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNForwardTraining);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardData(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * yDesc, const void * y, const cudnnTensorDescriptor_t * dyDesc, const void * dy, const cudnnTensorDescriptor_t  dhyDesc, const void * dhy, const cudnnTensorDescriptor_t  dcyDesc, const void * dcy, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnTensorDescriptor_t * dxDesc, void * dx, const cudnnTensorDescriptor_t  dhxDesc, void * dhx, const cudnnTensorDescriptor_t  dcxDesc, void * dcx, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNBackwardData) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t );
	if (!lcudnnRNNBackwardData) {
		lcudnnRNNBackwardData = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardData");
		tracer._kernel_map[(void *) lcudnnRNNBackwardData] = std::string("cudnnRNNBackwardData");
	}
	assert(lcudnnRNNBackwardData);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardData(handle, rnnDesc, seqLength, yDesc, y, dyDesc, dy, dhyDesc, dhy, dcyDesc, dcy, wDesc, w, hxDesc, hx, cxDesc, cx, dxDesc, dx, dhxDesc, dhx, dcxDesc, dcx, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardData);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardData_v8(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, const int32_t  devSeqLengths[], cudnnRNNDataDescriptor_t  yDesc, const void * y, const void * dy, cudnnRNNDataDescriptor_t  xDesc, void * dx, cudnnTensorDescriptor_t  hDesc, const void * hx, const void * dhy, void * dhx, cudnnTensorDescriptor_t  cDesc, const void * cx, const void * dcy, void * dcx, size_t  weightSpaceSize, const void * weightSpace, size_t  workSpaceSize, void * workSpace, size_t  reserveSpaceSize, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnRNNBackwardData_v8) (cudnnHandle_t , cudnnRNNDescriptor_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, const void *, cudnnRNNDataDescriptor_t , void *, cudnnTensorDescriptor_t , const void *, const void *, void *, cudnnTensorDescriptor_t , const void *, const void *, void *, size_t , const void *, size_t , void *, size_t , void *);
	if (!lcudnnRNNBackwardData_v8) {
		lcudnnRNNBackwardData_v8 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, const void *, cudnnRNNDataDescriptor_t , void *, cudnnTensorDescriptor_t , const void *, const void *, void *, cudnnTensorDescriptor_t , const void *, const void *, void *, size_t , const void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardData_v8");
		tracer._kernel_map[(void *) lcudnnRNNBackwardData_v8] = std::string("cudnnRNNBackwardData_v8");
	}
	assert(lcudnnRNNBackwardData_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardData_v8(handle, rnnDesc, devSeqLengths, yDesc, y, dy, xDesc, dx, hDesc, hx, dhy, dhx, cDesc, cx, dcy, dcx, weightSpaceSize, weightSpace, workSpaceSize, workSpace, reserveSpaceSize, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardData_v8);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardWeights(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t * yDesc, const void * y, const void * workSpace, size_t  workSpaceSizeInBytes, const cudnnFilterDescriptor_t  dwDesc, void * dw, const void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNBackwardWeights) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, const void *, const void *, size_t , const cudnnFilterDescriptor_t , void *, const void *, size_t );
	if (!lcudnnRNNBackwardWeights) {
		lcudnnRNNBackwardWeights = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, const void *, const void *, size_t , const cudnnFilterDescriptor_t , void *, const void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardWeights");
		tracer._kernel_map[(void *) lcudnnRNNBackwardWeights] = std::string("cudnnRNNBackwardWeights");
	}
	assert(lcudnnRNNBackwardWeights);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardWeights(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, yDesc, y, workSpace, workSpaceSizeInBytes, dwDesc, dw, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardWeights);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardWeights_v8(cudnnHandle_t  handle, cudnnRNNDescriptor_t  rnnDesc, cudnnWgradMode_t  addGrad, const int32_t  devSeqLengths[], cudnnRNNDataDescriptor_t  xDesc, const void * x, cudnnTensorDescriptor_t  hDesc, const void * hx, cudnnRNNDataDescriptor_t  yDesc, const void * y, size_t  weightSpaceSize, void * dweightSpace, size_t  workSpaceSize, void * workSpace, size_t  reserveSpaceSize, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnRNNBackwardWeights_v8) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnWgradMode_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, cudnnTensorDescriptor_t , const void *, cudnnRNNDataDescriptor_t , const void *, size_t , void *, size_t , void *, size_t , void *);
	if (!lcudnnRNNBackwardWeights_v8) {
		lcudnnRNNBackwardWeights_v8 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnRNNDescriptor_t , cudnnWgradMode_t , const int32_t [], cudnnRNNDataDescriptor_t , const void *, cudnnTensorDescriptor_t , const void *, cudnnRNNDataDescriptor_t , const void *, size_t , void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardWeights_v8");
		tracer._kernel_map[(void *) lcudnnRNNBackwardWeights_v8] = std::string("cudnnRNNBackwardWeights_v8");
	}
	assert(lcudnnRNNBackwardWeights_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardWeights_v8(handle, rnnDesc, addGrad, devSeqLengths, xDesc, x, hDesc, hx, yDesc, y, weightSpaceSize, dweightSpace, workSpaceSize, workSpace, reserveSpaceSize, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardWeights_v8);
	}
	return res;
}

cudnnStatus_t cudnnRNNForwardTrainingEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const cudnnRNNDataDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnRNNDataDescriptor_t  yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, const cudnnRNNDataDescriptor_t  kDesc, const void * keys, const cudnnRNNDataDescriptor_t  cDesc, void * cAttn, const cudnnRNNDataDescriptor_t  iDesc, void * iAttn, const cudnnRNNDataDescriptor_t  qDesc, void * queries, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNForwardTrainingEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t , void *, size_t );
	if (!lcudnnRNNForwardTrainingEx) {
		lcudnnRNNForwardTrainingEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNForwardTrainingEx");
		tracer._kernel_map[(void *) lcudnnRNNForwardTrainingEx] = std::string("cudnnRNNForwardTrainingEx");
	}
	assert(lcudnnRNNForwardTrainingEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNForwardTrainingEx(handle, rnnDesc, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, kDesc, keys, cDesc, cAttn, iDesc, iAttn, qDesc, queries, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNForwardTrainingEx);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardDataEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const cudnnRNNDataDescriptor_t  yDesc, const void * y, const cudnnRNNDataDescriptor_t  dyDesc, const void * dy, const cudnnRNNDataDescriptor_t  dcDesc, const void * dcAttn, const cudnnTensorDescriptor_t  dhyDesc, const void * dhy, const cudnnTensorDescriptor_t  dcyDesc, const void * dcy, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnRNNDataDescriptor_t  dxDesc, void * dx, const cudnnTensorDescriptor_t  dhxDesc, void * dhx, const cudnnTensorDescriptor_t  dcxDesc, void * dcx, const cudnnRNNDataDescriptor_t  dkDesc, void * dkeys, void * workSpace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNBackwardDataEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t , void *, size_t );
	if (!lcudnnRNNBackwardDataEx) {
		lcudnnRNNBackwardDataEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const cudnnRNNDataDescriptor_t , void *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardDataEx");
		tracer._kernel_map[(void *) lcudnnRNNBackwardDataEx] = std::string("cudnnRNNBackwardDataEx");
	}
	assert(lcudnnRNNBackwardDataEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardDataEx(handle, rnnDesc, yDesc, y, dyDesc, dy, dcDesc, dcAttn, dhyDesc, dhy, dcyDesc, dcy, wDesc, w, hxDesc, hx, cxDesc, cx, dxDesc, dx, dhxDesc, dhx, dcxDesc, dcx, dkDesc, dkeys, workSpace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardDataEx);
	}
	return res;
}

cudnnStatus_t cudnnRNNBackwardWeightsEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const cudnnRNNDataDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnRNNDataDescriptor_t  yDesc, const void * y, void * workSpace, size_t  workSpaceSizeInBytes, const cudnnFilterDescriptor_t  dwDesc, void * dw, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnRNNBackwardWeightsEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, void *, size_t , const cudnnFilterDescriptor_t , void *, void *, size_t );
	if (!lcudnnRNNBackwardWeightsEx) {
		lcudnnRNNBackwardWeightsEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const cudnnRNNDataDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnRNNDataDescriptor_t , const void *, void *, size_t , const cudnnFilterDescriptor_t , void *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnRNNBackwardWeightsEx");
		tracer._kernel_map[(void *) lcudnnRNNBackwardWeightsEx] = std::string("cudnnRNNBackwardWeightsEx");
	}
	assert(lcudnnRNNBackwardWeightsEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnRNNBackwardWeightsEx(handle, rnnDesc, xDesc, x, hxDesc, hx, yDesc, y, workSpace, workSpaceSizeInBytes, dwDesc, dw, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnRNNBackwardWeightsEx);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNForwardTrainingAlgorithmMaxCount(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, int * count)
{
	static cudnnStatus_t (*lcudnnGetRNNForwardTrainingAlgorithmMaxCount) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *);
	if (!lcudnnGetRNNForwardTrainingAlgorithmMaxCount) {
		lcudnnGetRNNForwardTrainingAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNForwardTrainingAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetRNNForwardTrainingAlgorithmMaxCount] = std::string("cudnnGetRNNForwardTrainingAlgorithmMaxCount");
	}
	assert(lcudnnGetRNNForwardTrainingAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNForwardTrainingAlgorithmMaxCount(handle, rnnDesc, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNForwardTrainingAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindRNNForwardTrainingAlgorithmEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t * yDesc, void * y, const cudnnTensorDescriptor_t  hyDesc, void * hy, const cudnnTensorDescriptor_t  cyDesc, void * cy, const float  findIntensity, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnAlgorithmPerformance_t * perfResults, void * workspace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindRNNForwardTrainingAlgorithmEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t , void *, size_t );
	if (!lcudnnFindRNNForwardTrainingAlgorithmEx) {
		lcudnnFindRNNForwardTrainingAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindRNNForwardTrainingAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindRNNForwardTrainingAlgorithmEx] = std::string("cudnnFindRNNForwardTrainingAlgorithmEx");
	}
	assert(lcudnnFindRNNForwardTrainingAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindRNNForwardTrainingAlgorithmEx(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, cxDesc, cx, wDesc, w, yDesc, y, hyDesc, hy, cyDesc, cy, findIntensity, requestedAlgoCount, returnedAlgoCount, perfResults, workspace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindRNNForwardTrainingAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNBackwardDataAlgorithmMaxCount(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, int * count)
{
	static cudnnStatus_t (*lcudnnGetRNNBackwardDataAlgorithmMaxCount) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *);
	if (!lcudnnGetRNNBackwardDataAlgorithmMaxCount) {
		lcudnnGetRNNBackwardDataAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNBackwardDataAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetRNNBackwardDataAlgorithmMaxCount] = std::string("cudnnGetRNNBackwardDataAlgorithmMaxCount");
	}
	assert(lcudnnGetRNNBackwardDataAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNBackwardDataAlgorithmMaxCount(handle, rnnDesc, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNBackwardDataAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindRNNBackwardDataAlgorithmEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * yDesc, const void * y, const cudnnTensorDescriptor_t * dyDesc, const void * dy, const cudnnTensorDescriptor_t  dhyDesc, const void * dhy, const cudnnTensorDescriptor_t  dcyDesc, const void * dcy, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t  cxDesc, const void * cx, const cudnnTensorDescriptor_t * dxDesc, void * dx, const cudnnTensorDescriptor_t  dhxDesc, void * dhx, const cudnnTensorDescriptor_t  dcxDesc, void * dcx, const float  findIntensity, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnAlgorithmPerformance_t * perfResults, void * workspace, size_t  workSpaceSizeInBytes, void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindRNNBackwardDataAlgorithmEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t , void *, size_t );
	if (!lcudnnFindRNNBackwardDataAlgorithmEx) {
		lcudnnFindRNNBackwardDataAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, void *, const cudnnTensorDescriptor_t , void *, const cudnnTensorDescriptor_t , void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, void *, size_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindRNNBackwardDataAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindRNNBackwardDataAlgorithmEx] = std::string("cudnnFindRNNBackwardDataAlgorithmEx");
	}
	assert(lcudnnFindRNNBackwardDataAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindRNNBackwardDataAlgorithmEx(handle, rnnDesc, seqLength, yDesc, y, dyDesc, dy, dhyDesc, dhy, dcyDesc, dcy, wDesc, w, hxDesc, hx, cxDesc, cx, dxDesc, dx, dhxDesc, dhx, dcxDesc, dcx, findIntensity, requestedAlgoCount, returnedAlgoCount, perfResults, workspace, workSpaceSizeInBytes, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindRNNBackwardDataAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnGetRNNBackwardWeightsAlgorithmMaxCount(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, int * count)
{
	static cudnnStatus_t (*lcudnnGetRNNBackwardWeightsAlgorithmMaxCount) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *);
	if (!lcudnnGetRNNBackwardWeightsAlgorithmMaxCount) {
		lcudnnGetRNNBackwardWeightsAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetRNNBackwardWeightsAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetRNNBackwardWeightsAlgorithmMaxCount] = std::string("cudnnGetRNNBackwardWeightsAlgorithmMaxCount");
	}
	assert(lcudnnGetRNNBackwardWeightsAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetRNNBackwardWeightsAlgorithmMaxCount(handle, rnnDesc, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetRNNBackwardWeightsAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindRNNBackwardWeightsAlgorithmEx(cudnnHandle_t  handle, const cudnnRNNDescriptor_t  rnnDesc, const int  seqLength, const cudnnTensorDescriptor_t * xDesc, const void * x, const cudnnTensorDescriptor_t  hxDesc, const void * hx, const cudnnTensorDescriptor_t * yDesc, const void * y, const float  findIntensity, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnAlgorithmPerformance_t * perfResults, const void * workspace, size_t  workSpaceSizeInBytes, const cudnnFilterDescriptor_t  dwDesc, void * dw, const void * reserveSpace, size_t  reserveSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindRNNBackwardWeightsAlgorithmEx) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, const void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, const void *, size_t , const cudnnFilterDescriptor_t , void *, const void *, size_t );
	if (!lcudnnFindRNNBackwardWeightsAlgorithmEx) {
		lcudnnFindRNNBackwardWeightsAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnRNNDescriptor_t , const int , const cudnnTensorDescriptor_t *, const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t *, const void *, const float , const int , int *, cudnnAlgorithmPerformance_t *, const void *, size_t , const cudnnFilterDescriptor_t , void *, const void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindRNNBackwardWeightsAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindRNNBackwardWeightsAlgorithmEx] = std::string("cudnnFindRNNBackwardWeightsAlgorithmEx");
	}
	assert(lcudnnFindRNNBackwardWeightsAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindRNNBackwardWeightsAlgorithmEx(handle, rnnDesc, seqLength, xDesc, x, hxDesc, hx, yDesc, y, findIntensity, requestedAlgoCount, returnedAlgoCount, perfResults, workspace, workSpaceSizeInBytes, dwDesc, dw, reserveSpace, reserveSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindRNNBackwardWeightsAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnMultiHeadAttnBackwardData(cudnnHandle_t  handle, const cudnnAttnDescriptor_t  attnDesc, const int  loWinIdx[], const int  hiWinIdx[], const int  devSeqLengthsDQDO[], const int  devSeqLengthsDKDV[], const cudnnSeqDataDescriptor_t  doDesc, const void * dout, const cudnnSeqDataDescriptor_t  dqDesc, void * dqueries, const void * queries, const cudnnSeqDataDescriptor_t  dkDesc, void * dkeys, const void * keys, const cudnnSeqDataDescriptor_t  dvDesc, void * dvalues, const void * values, size_t  weightSizeInBytes, const void * weights, size_t  workSpaceSizeInBytes, void * workSpace, size_t  reserveSpaceSizeInBytes, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnMultiHeadAttnBackwardData) (cudnnHandle_t , const cudnnAttnDescriptor_t , const int [], const int [], const int [], const int [], const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , void *, const void *, const cudnnSeqDataDescriptor_t , void *, const void *, const cudnnSeqDataDescriptor_t , void *, const void *, size_t , const void *, size_t , void *, size_t , void *);
	if (!lcudnnMultiHeadAttnBackwardData) {
		lcudnnMultiHeadAttnBackwardData = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnAttnDescriptor_t , const int [], const int [], const int [], const int [], const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , void *, const void *, const cudnnSeqDataDescriptor_t , void *, const void *, const cudnnSeqDataDescriptor_t , void *, const void *, size_t , const void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnMultiHeadAttnBackwardData");
		tracer._kernel_map[(void *) lcudnnMultiHeadAttnBackwardData] = std::string("cudnnMultiHeadAttnBackwardData");
	}
	assert(lcudnnMultiHeadAttnBackwardData);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnMultiHeadAttnBackwardData(handle, attnDesc, loWinIdx, hiWinIdx, devSeqLengthsDQDO, devSeqLengthsDKDV, doDesc, dout, dqDesc, dqueries, queries, dkDesc, dkeys, keys, dvDesc, dvalues, values, weightSizeInBytes, weights, workSpaceSizeInBytes, workSpace, reserveSpaceSizeInBytes, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnMultiHeadAttnBackwardData);
	}
	return res;
}

cudnnStatus_t cudnnMultiHeadAttnBackwardWeights(cudnnHandle_t  handle, const cudnnAttnDescriptor_t  attnDesc, cudnnWgradMode_t  addGrad, const cudnnSeqDataDescriptor_t  qDesc, const void * queries, const cudnnSeqDataDescriptor_t  kDesc, const void * keys, const cudnnSeqDataDescriptor_t  vDesc, const void * values, const cudnnSeqDataDescriptor_t  doDesc, const void * dout, size_t  weightSizeInBytes, const void * weights, void * dweights, size_t  workSpaceSizeInBytes, void * workSpace, size_t  reserveSpaceSizeInBytes, void * reserveSpace)
{
	static cudnnStatus_t (*lcudnnMultiHeadAttnBackwardWeights) (cudnnHandle_t , const cudnnAttnDescriptor_t , cudnnWgradMode_t , const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, size_t , const void *, void *, size_t , void *, size_t , void *);
	if (!lcudnnMultiHeadAttnBackwardWeights) {
		lcudnnMultiHeadAttnBackwardWeights = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnAttnDescriptor_t , cudnnWgradMode_t , const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, const cudnnSeqDataDescriptor_t , const void *, size_t , const void *, void *, size_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnMultiHeadAttnBackwardWeights");
		tracer._kernel_map[(void *) lcudnnMultiHeadAttnBackwardWeights] = std::string("cudnnMultiHeadAttnBackwardWeights");
	}
	assert(lcudnnMultiHeadAttnBackwardWeights);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnMultiHeadAttnBackwardWeights(handle, attnDesc, addGrad, qDesc, queries, kDesc, keys, vDesc, values, doDesc, dout, weightSizeInBytes, weights, dweights, workSpaceSizeInBytes, workSpace, reserveSpaceSizeInBytes, reserveSpace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnMultiHeadAttnBackwardWeights);
	}
	return res;
}

cudnnStatus_t cudnnCreateCTCLossDescriptor(cudnnCTCLossDescriptor_t * ctcLossDesc)
{
	static cudnnStatus_t (*lcudnnCreateCTCLossDescriptor) (cudnnCTCLossDescriptor_t *);
	if (!lcudnnCreateCTCLossDescriptor) {
		lcudnnCreateCTCLossDescriptor = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateCTCLossDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateCTCLossDescriptor] = std::string("cudnnCreateCTCLossDescriptor");
	}
	assert(lcudnnCreateCTCLossDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateCTCLossDescriptor(ctcLossDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateCTCLossDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetCTCLossDescriptor(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t  compType)
{
	static cudnnStatus_t (*lcudnnSetCTCLossDescriptor) (cudnnCTCLossDescriptor_t , cudnnDataType_t );
	if (!lcudnnSetCTCLossDescriptor) {
		lcudnnSetCTCLossDescriptor = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t )) dlsym(tracer.cudnn_handle, "cudnnSetCTCLossDescriptor");
		tracer._kernel_map[(void *) lcudnnSetCTCLossDescriptor] = std::string("cudnnSetCTCLossDescriptor");
	}
	assert(lcudnnSetCTCLossDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetCTCLossDescriptor(ctcLossDesc, compType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetCTCLossDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetCTCLossDescriptorEx(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t  compType, cudnnLossNormalizationMode_t  normMode, cudnnNanPropagation_t  gradMode)
{
	static cudnnStatus_t (*lcudnnSetCTCLossDescriptorEx) (cudnnCTCLossDescriptor_t , cudnnDataType_t , cudnnLossNormalizationMode_t , cudnnNanPropagation_t );
	if (!lcudnnSetCTCLossDescriptorEx) {
		lcudnnSetCTCLossDescriptorEx = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t , cudnnLossNormalizationMode_t , cudnnNanPropagation_t )) dlsym(tracer.cudnn_handle, "cudnnSetCTCLossDescriptorEx");
		tracer._kernel_map[(void *) lcudnnSetCTCLossDescriptorEx] = std::string("cudnnSetCTCLossDescriptorEx");
	}
	assert(lcudnnSetCTCLossDescriptorEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetCTCLossDescriptorEx(ctcLossDesc, compType, normMode, gradMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetCTCLossDescriptorEx);
	}
	return res;
}

cudnnStatus_t cudnnSetCTCLossDescriptor_v8(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t  compType, cudnnLossNormalizationMode_t  normMode, cudnnNanPropagation_t  gradMode, int  maxLabelLength)
{
	static cudnnStatus_t (*lcudnnSetCTCLossDescriptor_v8) (cudnnCTCLossDescriptor_t , cudnnDataType_t , cudnnLossNormalizationMode_t , cudnnNanPropagation_t , int );
	if (!lcudnnSetCTCLossDescriptor_v8) {
		lcudnnSetCTCLossDescriptor_v8 = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t , cudnnLossNormalizationMode_t , cudnnNanPropagation_t , int )) dlsym(tracer.cudnn_handle, "cudnnSetCTCLossDescriptor_v8");
		tracer._kernel_map[(void *) lcudnnSetCTCLossDescriptor_v8] = std::string("cudnnSetCTCLossDescriptor_v8");
	}
	assert(lcudnnSetCTCLossDescriptor_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetCTCLossDescriptor_v8(ctcLossDesc, compType, normMode, gradMode, maxLabelLength);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetCTCLossDescriptor_v8);
	}
	return res;
}

cudnnStatus_t cudnnGetCTCLossDescriptor(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t * compType)
{
	static cudnnStatus_t (*lcudnnGetCTCLossDescriptor) (cudnnCTCLossDescriptor_t , cudnnDataType_t *);
	if (!lcudnnGetCTCLossDescriptor) {
		lcudnnGetCTCLossDescriptor = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetCTCLossDescriptor");
		tracer._kernel_map[(void *) lcudnnGetCTCLossDescriptor] = std::string("cudnnGetCTCLossDescriptor");
	}
	assert(lcudnnGetCTCLossDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCTCLossDescriptor(ctcLossDesc, compType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCTCLossDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetCTCLossDescriptorEx(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t * compType, cudnnLossNormalizationMode_t * normMode, cudnnNanPropagation_t * gradMode)
{
	static cudnnStatus_t (*lcudnnGetCTCLossDescriptorEx) (cudnnCTCLossDescriptor_t , cudnnDataType_t *, cudnnLossNormalizationMode_t *, cudnnNanPropagation_t *);
	if (!lcudnnGetCTCLossDescriptorEx) {
		lcudnnGetCTCLossDescriptorEx = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t *, cudnnLossNormalizationMode_t *, cudnnNanPropagation_t *)) dlsym(tracer.cudnn_handle, "cudnnGetCTCLossDescriptorEx");
		tracer._kernel_map[(void *) lcudnnGetCTCLossDescriptorEx] = std::string("cudnnGetCTCLossDescriptorEx");
	}
	assert(lcudnnGetCTCLossDescriptorEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCTCLossDescriptorEx(ctcLossDesc, compType, normMode, gradMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCTCLossDescriptorEx);
	}
	return res;
}

cudnnStatus_t cudnnGetCTCLossDescriptor_v8(cudnnCTCLossDescriptor_t  ctcLossDesc, cudnnDataType_t * compType, cudnnLossNormalizationMode_t * normMode, cudnnNanPropagation_t * gradMode, int * maxLabelLength)
{
	static cudnnStatus_t (*lcudnnGetCTCLossDescriptor_v8) (cudnnCTCLossDescriptor_t , cudnnDataType_t *, cudnnLossNormalizationMode_t *, cudnnNanPropagation_t *, int *);
	if (!lcudnnGetCTCLossDescriptor_v8) {
		lcudnnGetCTCLossDescriptor_v8 = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t , cudnnDataType_t *, cudnnLossNormalizationMode_t *, cudnnNanPropagation_t *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetCTCLossDescriptor_v8");
		tracer._kernel_map[(void *) lcudnnGetCTCLossDescriptor_v8] = std::string("cudnnGetCTCLossDescriptor_v8");
	}
	assert(lcudnnGetCTCLossDescriptor_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCTCLossDescriptor_v8(ctcLossDesc, compType, normMode, gradMode, maxLabelLength);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCTCLossDescriptor_v8);
	}
	return res;
}

cudnnStatus_t cudnnDestroyCTCLossDescriptor(cudnnCTCLossDescriptor_t  ctcLossDesc)
{
	static cudnnStatus_t (*lcudnnDestroyCTCLossDescriptor) (cudnnCTCLossDescriptor_t );
	if (!lcudnnDestroyCTCLossDescriptor) {
		lcudnnDestroyCTCLossDescriptor = (cudnnStatus_t (*) (cudnnCTCLossDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyCTCLossDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyCTCLossDescriptor] = std::string("cudnnDestroyCTCLossDescriptor");
	}
	assert(lcudnnDestroyCTCLossDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyCTCLossDescriptor(ctcLossDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyCTCLossDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnCTCLoss(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  probsDesc, const void * probs, const int  hostLabels[], const int  hostLabelLengths[], const int  hostInputLengths[], void * costs, const cudnnTensorDescriptor_t  gradientsDesc, void * gradients, cudnnCTCLossAlgo_t  algo, cudnnCTCLossDescriptor_t  ctcLossDesc, void * workspace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnCTCLoss) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const int [], const int [], const int [], void *, const cudnnTensorDescriptor_t , void *, cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , void *, size_t );
	if (!lcudnnCTCLoss) {
		lcudnnCTCLoss = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const int [], const int [], const int [], void *, const cudnnTensorDescriptor_t , void *, cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnCTCLoss");
		tracer._kernel_map[(void *) lcudnnCTCLoss] = std::string("cudnnCTCLoss");
	}
	assert(lcudnnCTCLoss);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCTCLoss(handle, probsDesc, probs, hostLabels, hostLabelLengths, hostInputLengths, costs, gradientsDesc, gradients, algo, ctcLossDesc, workspace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCTCLoss);
	}
	return res;
}

cudnnStatus_t cudnnCTCLoss_v8(cudnnHandle_t  handle, cudnnCTCLossAlgo_t  algo, cudnnCTCLossDescriptor_t  ctcLossDesc, const cudnnTensorDescriptor_t  probsDesc, const void * probs, const int  labels[], const int  labelLengths[], const int  inputLengths[], void * costs, const cudnnTensorDescriptor_t  gradientsDesc, void * gradients, size_t  workSpaceSizeInBytes, void * workspace)
{
	static cudnnStatus_t (*lcudnnCTCLoss_v8) (cudnnHandle_t , cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , const cudnnTensorDescriptor_t , const void *, const int [], const int [], const int [], void *, const cudnnTensorDescriptor_t , void *, size_t , void *);
	if (!lcudnnCTCLoss_v8) {
		lcudnnCTCLoss_v8 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , const cudnnTensorDescriptor_t , const void *, const int [], const int [], const int [], void *, const cudnnTensorDescriptor_t , void *, size_t , void *)) dlsym(tracer.cudnn_handle, "cudnnCTCLoss_v8");
		tracer._kernel_map[(void *) lcudnnCTCLoss_v8] = std::string("cudnnCTCLoss_v8");
	}
	assert(lcudnnCTCLoss_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCTCLoss_v8(handle, algo, ctcLossDesc, probsDesc, probs, labels, labelLengths, inputLengths, costs, gradientsDesc, gradients, workSpaceSizeInBytes, workspace);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCTCLoss_v8);
	}
	return res;
}

cudnnStatus_t cudnnGetCTCLossWorkspaceSize(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  probsDesc, const cudnnTensorDescriptor_t  gradientsDesc, const int * labels, const int * labelLengths, const int * inputLengths, cudnnCTCLossAlgo_t  algo, cudnnCTCLossDescriptor_t  ctcLossDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetCTCLossWorkspaceSize) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const int *, const int *, const int *, cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , size_t *);
	if (!lcudnnGetCTCLossWorkspaceSize) {
		lcudnnGetCTCLossWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const int *, const int *, const int *, cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetCTCLossWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetCTCLossWorkspaceSize] = std::string("cudnnGetCTCLossWorkspaceSize");
	}
	assert(lcudnnGetCTCLossWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCTCLossWorkspaceSize(handle, probsDesc, gradientsDesc, labels, labelLengths, inputLengths, algo, ctcLossDesc, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCTCLossWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnGetCTCLossWorkspaceSize_v8(cudnnHandle_t  handle, cudnnCTCLossAlgo_t  algo, cudnnCTCLossDescriptor_t  ctcLossDesc, const cudnnTensorDescriptor_t  probsDesc, const cudnnTensorDescriptor_t  gradientsDesc, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetCTCLossWorkspaceSize_v8) (cudnnHandle_t , cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *);
	if (!lcudnnGetCTCLossWorkspaceSize_v8) {
		lcudnnGetCTCLossWorkspaceSize_v8 = (cudnnStatus_t (*) (cudnnHandle_t , cudnnCTCLossAlgo_t , cudnnCTCLossDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetCTCLossWorkspaceSize_v8");
		tracer._kernel_map[(void *) lcudnnGetCTCLossWorkspaceSize_v8] = std::string("cudnnGetCTCLossWorkspaceSize_v8");
	}
	assert(lcudnnGetCTCLossWorkspaceSize_v8);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetCTCLossWorkspaceSize_v8(handle, algo, ctcLossDesc, probsDesc, gradientsDesc, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetCTCLossWorkspaceSize_v8);
	}
	return res;
}

cudnnStatus_t cudnnAdvTrainVersionCheck()
{
	static cudnnStatus_t (*lcudnnAdvTrainVersionCheck) ();
	if (!lcudnnAdvTrainVersionCheck) {
		lcudnnAdvTrainVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnAdvTrainVersionCheck");
		tracer._kernel_map[(void *) lcudnnAdvTrainVersionCheck] = std::string("cudnnAdvTrainVersionCheck");
	}
	assert(lcudnnAdvTrainVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnAdvTrainVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnAdvTrainVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnCreateConvolutionDescriptor(cudnnConvolutionDescriptor_t * convDesc)
{
	static cudnnStatus_t (*lcudnnCreateConvolutionDescriptor) (cudnnConvolutionDescriptor_t *);
	if (!lcudnnCreateConvolutionDescriptor) {
		lcudnnCreateConvolutionDescriptor = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnCreateConvolutionDescriptor");
		tracer._kernel_map[(void *) lcudnnCreateConvolutionDescriptor] = std::string("cudnnCreateConvolutionDescriptor");
	}
	assert(lcudnnCreateConvolutionDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateConvolutionDescriptor(convDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateConvolutionDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnDestroyConvolutionDescriptor(cudnnConvolutionDescriptor_t  convDesc)
{
	static cudnnStatus_t (*lcudnnDestroyConvolutionDescriptor) (cudnnConvolutionDescriptor_t );
	if (!lcudnnDestroyConvolutionDescriptor) {
		lcudnnDestroyConvolutionDescriptor = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyConvolutionDescriptor");
		tracer._kernel_map[(void *) lcudnnDestroyConvolutionDescriptor] = std::string("cudnnDestroyConvolutionDescriptor");
	}
	assert(lcudnnDestroyConvolutionDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyConvolutionDescriptor(convDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyConvolutionDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetConvolutionMathType(cudnnConvolutionDescriptor_t  convDesc, cudnnMathType_t  mathType)
{
	static cudnnStatus_t (*lcudnnSetConvolutionMathType) (cudnnConvolutionDescriptor_t , cudnnMathType_t );
	if (!lcudnnSetConvolutionMathType) {
		lcudnnSetConvolutionMathType = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , cudnnMathType_t )) dlsym(tracer.cudnn_handle, "cudnnSetConvolutionMathType");
		tracer._kernel_map[(void *) lcudnnSetConvolutionMathType] = std::string("cudnnSetConvolutionMathType");
	}
	assert(lcudnnSetConvolutionMathType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetConvolutionMathType(convDesc, mathType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetConvolutionMathType);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionMathType(cudnnConvolutionDescriptor_t  convDesc, cudnnMathType_t * mathType)
{
	static cudnnStatus_t (*lcudnnGetConvolutionMathType) (cudnnConvolutionDescriptor_t , cudnnMathType_t *);
	if (!lcudnnGetConvolutionMathType) {
		lcudnnGetConvolutionMathType = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , cudnnMathType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionMathType");
		tracer._kernel_map[(void *) lcudnnGetConvolutionMathType] = std::string("cudnnGetConvolutionMathType");
	}
	assert(lcudnnGetConvolutionMathType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionMathType(convDesc, mathType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionMathType);
	}
	return res;
}

cudnnStatus_t cudnnSetConvolutionGroupCount(cudnnConvolutionDescriptor_t  convDesc, int  groupCount)
{
	static cudnnStatus_t (*lcudnnSetConvolutionGroupCount) (cudnnConvolutionDescriptor_t , int );
	if (!lcudnnSetConvolutionGroupCount) {
		lcudnnSetConvolutionGroupCount = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , int )) dlsym(tracer.cudnn_handle, "cudnnSetConvolutionGroupCount");
		tracer._kernel_map[(void *) lcudnnSetConvolutionGroupCount] = std::string("cudnnSetConvolutionGroupCount");
	}
	assert(lcudnnSetConvolutionGroupCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetConvolutionGroupCount(convDesc, groupCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetConvolutionGroupCount);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionGroupCount(cudnnConvolutionDescriptor_t  convDesc, int * groupCount)
{
	static cudnnStatus_t (*lcudnnGetConvolutionGroupCount) (cudnnConvolutionDescriptor_t , int *);
	if (!lcudnnGetConvolutionGroupCount) {
		lcudnnGetConvolutionGroupCount = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionGroupCount");
		tracer._kernel_map[(void *) lcudnnGetConvolutionGroupCount] = std::string("cudnnGetConvolutionGroupCount");
	}
	assert(lcudnnGetConvolutionGroupCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionGroupCount(convDesc, groupCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionGroupCount);
	}
	return res;
}

cudnnStatus_t cudnnSetConvolutionReorderType(cudnnConvolutionDescriptor_t  convDesc, cudnnReorderType_t  reorderType)
{
	static cudnnStatus_t (*lcudnnSetConvolutionReorderType) (cudnnConvolutionDescriptor_t , cudnnReorderType_t );
	if (!lcudnnSetConvolutionReorderType) {
		lcudnnSetConvolutionReorderType = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , cudnnReorderType_t )) dlsym(tracer.cudnn_handle, "cudnnSetConvolutionReorderType");
		tracer._kernel_map[(void *) lcudnnSetConvolutionReorderType] = std::string("cudnnSetConvolutionReorderType");
	}
	assert(lcudnnSetConvolutionReorderType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetConvolutionReorderType(convDesc, reorderType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetConvolutionReorderType);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionReorderType(cudnnConvolutionDescriptor_t  convDesc, cudnnReorderType_t * reorderType)
{
	static cudnnStatus_t (*lcudnnGetConvolutionReorderType) (cudnnConvolutionDescriptor_t , cudnnReorderType_t *);
	if (!lcudnnGetConvolutionReorderType) {
		lcudnnGetConvolutionReorderType = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , cudnnReorderType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionReorderType");
		tracer._kernel_map[(void *) lcudnnGetConvolutionReorderType] = std::string("cudnnGetConvolutionReorderType");
	}
	assert(lcudnnGetConvolutionReorderType);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionReorderType(convDesc, reorderType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionReorderType);
	}
	return res;
}

cudnnStatus_t cudnnSetConvolution2dDescriptor(cudnnConvolutionDescriptor_t  convDesc, int  pad_h, int  pad_w, int  u, int  v, int  dilation_h, int  dilation_w, cudnnConvolutionMode_t  mode, cudnnDataType_t  computeType)
{
	static cudnnStatus_t (*lcudnnSetConvolution2dDescriptor) (cudnnConvolutionDescriptor_t , int , int , int , int , int , int , cudnnConvolutionMode_t , cudnnDataType_t );
	if (!lcudnnSetConvolution2dDescriptor) {
		lcudnnSetConvolution2dDescriptor = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , int , int , int , int , int , int , cudnnConvolutionMode_t , cudnnDataType_t )) dlsym(tracer.cudnn_handle, "cudnnSetConvolution2dDescriptor");
		tracer._kernel_map[(void *) lcudnnSetConvolution2dDescriptor] = std::string("cudnnSetConvolution2dDescriptor");
	}
	assert(lcudnnSetConvolution2dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetConvolution2dDescriptor(convDesc, pad_h, pad_w, u, v, dilation_h, dilation_w, mode, computeType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetConvolution2dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolution2dDescriptor(const cudnnConvolutionDescriptor_t  convDesc, int * pad_h, int * pad_w, int * u, int * v, int * dilation_h, int * dilation_w, cudnnConvolutionMode_t * mode, cudnnDataType_t * computeType)
{
	static cudnnStatus_t (*lcudnnGetConvolution2dDescriptor) (const cudnnConvolutionDescriptor_t , int *, int *, int *, int *, int *, int *, cudnnConvolutionMode_t *, cudnnDataType_t *);
	if (!lcudnnGetConvolution2dDescriptor) {
		lcudnnGetConvolution2dDescriptor = (cudnnStatus_t (*) (const cudnnConvolutionDescriptor_t , int *, int *, int *, int *, int *, int *, cudnnConvolutionMode_t *, cudnnDataType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolution2dDescriptor");
		tracer._kernel_map[(void *) lcudnnGetConvolution2dDescriptor] = std::string("cudnnGetConvolution2dDescriptor");
	}
	assert(lcudnnGetConvolution2dDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolution2dDescriptor(convDesc, pad_h, pad_w, u, v, dilation_h, dilation_w, mode, computeType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolution2dDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnSetConvolutionNdDescriptor(cudnnConvolutionDescriptor_t  convDesc, int  arrayLength, const int  padA[], const int  filterStrideA[], const int  dilationA[], cudnnConvolutionMode_t  mode, cudnnDataType_t  computeType)
{
	static cudnnStatus_t (*lcudnnSetConvolutionNdDescriptor) (cudnnConvolutionDescriptor_t , int , const int [], const int [], const int [], cudnnConvolutionMode_t , cudnnDataType_t );
	if (!lcudnnSetConvolutionNdDescriptor) {
		lcudnnSetConvolutionNdDescriptor = (cudnnStatus_t (*) (cudnnConvolutionDescriptor_t , int , const int [], const int [], const int [], cudnnConvolutionMode_t , cudnnDataType_t )) dlsym(tracer.cudnn_handle, "cudnnSetConvolutionNdDescriptor");
		tracer._kernel_map[(void *) lcudnnSetConvolutionNdDescriptor] = std::string("cudnnSetConvolutionNdDescriptor");
	}
	assert(lcudnnSetConvolutionNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetConvolutionNdDescriptor(convDesc, arrayLength, padA, filterStrideA, dilationA, mode, computeType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetConvolutionNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionNdDescriptor(const cudnnConvolutionDescriptor_t  convDesc, int  arrayLengthRequested, int * arrayLength, int  padA[], int  strideA[], int  dilationA[], cudnnConvolutionMode_t * mode, cudnnDataType_t * computeType)
{
	static cudnnStatus_t (*lcudnnGetConvolutionNdDescriptor) (const cudnnConvolutionDescriptor_t , int , int *, int [], int [], int [], cudnnConvolutionMode_t *, cudnnDataType_t *);
	if (!lcudnnGetConvolutionNdDescriptor) {
		lcudnnGetConvolutionNdDescriptor = (cudnnStatus_t (*) (const cudnnConvolutionDescriptor_t , int , int *, int [], int [], int [], cudnnConvolutionMode_t *, cudnnDataType_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionNdDescriptor");
		tracer._kernel_map[(void *) lcudnnGetConvolutionNdDescriptor] = std::string("cudnnGetConvolutionNdDescriptor");
	}
	assert(lcudnnGetConvolutionNdDescriptor);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionNdDescriptor(convDesc, arrayLengthRequested, arrayLength, padA, strideA, dilationA, mode, computeType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionNdDescriptor);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolution2dForwardOutputDim(const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  inputTensorDesc, const cudnnFilterDescriptor_t  filterDesc, int * n, int * c, int * h, int * w)
{
	static cudnnStatus_t (*lcudnnGetConvolution2dForwardOutputDim) (const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , int *, int *, int *, int *);
	if (!lcudnnGetConvolution2dForwardOutputDim) {
		lcudnnGetConvolution2dForwardOutputDim = (cudnnStatus_t (*) (const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , int *, int *, int *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolution2dForwardOutputDim");
		tracer._kernel_map[(void *) lcudnnGetConvolution2dForwardOutputDim] = std::string("cudnnGetConvolution2dForwardOutputDim");
	}
	assert(lcudnnGetConvolution2dForwardOutputDim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolution2dForwardOutputDim(convDesc, inputTensorDesc, filterDesc, n, c, h, w);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolution2dForwardOutputDim);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionNdForwardOutputDim(const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  inputTensorDesc, const cudnnFilterDescriptor_t  filterDesc, int  nbDims, int  tensorOuputDimA[])
{
	static cudnnStatus_t (*lcudnnGetConvolutionNdForwardOutputDim) (const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , int , int []);
	if (!lcudnnGetConvolutionNdForwardOutputDim) {
		lcudnnGetConvolutionNdForwardOutputDim = (cudnnStatus_t (*) (const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , int , int [])) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionNdForwardOutputDim");
		tracer._kernel_map[(void *) lcudnnGetConvolutionNdForwardOutputDim] = std::string("cudnnGetConvolutionNdForwardOutputDim");
	}
	assert(lcudnnGetConvolutionNdForwardOutputDim);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionNdForwardOutputDim(convDesc, inputTensorDesc, filterDesc, nbDims, tensorOuputDimA);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionNdForwardOutputDim);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionForwardAlgorithmMaxCount(cudnnHandle_t  handle, int * count)
{
	static cudnnStatus_t (*lcudnnGetConvolutionForwardAlgorithmMaxCount) (cudnnHandle_t , int *);
	if (!lcudnnGetConvolutionForwardAlgorithmMaxCount) {
		lcudnnGetConvolutionForwardAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionForwardAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetConvolutionForwardAlgorithmMaxCount] = std::string("cudnnGetConvolutionForwardAlgorithmMaxCount");
	}
	assert(lcudnnGetConvolutionForwardAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionForwardAlgorithmMaxCount(handle, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionForwardAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionForwardAlgorithm_v7(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  srcDesc, const cudnnFilterDescriptor_t  filterDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  destDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionFwdAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnGetConvolutionForwardAlgorithm_v7) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionFwdAlgoPerf_t *);
	if (!lcudnnGetConvolutionForwardAlgorithm_v7) {
		lcudnnGetConvolutionForwardAlgorithm_v7 = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionFwdAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionForwardAlgorithm_v7");
		tracer._kernel_map[(void *) lcudnnGetConvolutionForwardAlgorithm_v7] = std::string("cudnnGetConvolutionForwardAlgorithm_v7");
	}
	assert(lcudnnGetConvolutionForwardAlgorithm_v7);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionForwardAlgorithm_v7(handle, srcDesc, filterDesc, convDesc, destDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionForwardAlgorithm_v7);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionForwardAlgorithm(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const cudnnFilterDescriptor_t  wDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  yDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionFwdAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnFindConvolutionForwardAlgorithm) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionFwdAlgoPerf_t *);
	if (!lcudnnFindConvolutionForwardAlgorithm) {
		lcudnnFindConvolutionForwardAlgorithm = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionFwdAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionForwardAlgorithm");
		tracer._kernel_map[(void *) lcudnnFindConvolutionForwardAlgorithm] = std::string("cudnnFindConvolutionForwardAlgorithm");
	}
	assert(lcudnnFindConvolutionForwardAlgorithm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionForwardAlgorithm(handle, xDesc, wDesc, convDesc, yDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionForwardAlgorithm);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionForwardAlgorithmEx(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  yDesc, void * y, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionFwdAlgoPerf_t * perfResults, void * workSpace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindConvolutionForwardAlgorithmEx) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , void *, const int , int *, cudnnConvolutionFwdAlgoPerf_t *, void *, size_t );
	if (!lcudnnFindConvolutionForwardAlgorithmEx) {
		lcudnnFindConvolutionForwardAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , void *, const int , int *, cudnnConvolutionFwdAlgoPerf_t *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionForwardAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindConvolutionForwardAlgorithmEx] = std::string("cudnnFindConvolutionForwardAlgorithmEx");
	}
	assert(lcudnnFindConvolutionForwardAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionForwardAlgorithmEx(handle, xDesc, x, wDesc, w, convDesc, yDesc, y, requestedAlgoCount, returnedAlgoCount, perfResults, workSpace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionForwardAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnIm2Col(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnFilterDescriptor_t  wDesc, const cudnnConvolutionDescriptor_t  convDesc, void * colBuffer)
{
	static cudnnStatus_t (*lcudnnIm2Col) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , void *);
	if (!lcudnnIm2Col) {
		lcudnnIm2Col = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnIm2Col");
		tracer._kernel_map[(void *) lcudnnIm2Col] = std::string("cudnnIm2Col");
	}
	assert(lcudnnIm2Col);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnIm2Col(handle, xDesc, x, wDesc, convDesc, colBuffer);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnIm2Col);
	}
	return res;
}

cudnnStatus_t cudnnReorderFilterAndBias(cudnnHandle_t  handle, const cudnnFilterDescriptor_t  filterDesc, cudnnReorderType_t  reorderType, const void * filterData, void * reorderedFilterData, int  reorderBias, const void * biasData, void * reorderedBiasData)
{
	static cudnnStatus_t (*lcudnnReorderFilterAndBias) (cudnnHandle_t , const cudnnFilterDescriptor_t , cudnnReorderType_t , const void *, void *, int , const void *, void *);
	if (!lcudnnReorderFilterAndBias) {
		lcudnnReorderFilterAndBias = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFilterDescriptor_t , cudnnReorderType_t , const void *, void *, int , const void *, void *)) dlsym(tracer.cudnn_handle, "cudnnReorderFilterAndBias");
		tracer._kernel_map[(void *) lcudnnReorderFilterAndBias] = std::string("cudnnReorderFilterAndBias");
	}
	assert(lcudnnReorderFilterAndBias);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnReorderFilterAndBias(handle, filterDesc, reorderType, filterData, reorderedFilterData, reorderBias, biasData, reorderedBiasData);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnReorderFilterAndBias);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionForwardWorkspaceSize(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const cudnnFilterDescriptor_t  wDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  yDesc, cudnnConvolutionFwdAlgo_t  algo, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetConvolutionForwardWorkspaceSize) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , cudnnConvolutionFwdAlgo_t , size_t *);
	if (!lcudnnGetConvolutionForwardWorkspaceSize) {
		lcudnnGetConvolutionForwardWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnFilterDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , cudnnConvolutionFwdAlgo_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionForwardWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetConvolutionForwardWorkspaceSize] = std::string("cudnnGetConvolutionForwardWorkspaceSize");
	}
	assert(lcudnnGetConvolutionForwardWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionForwardWorkspaceSize(handle, xDesc, wDesc, convDesc, yDesc, algo, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionForwardWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnConvolutionForward(cudnnHandle_t  handle, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnConvolutionDescriptor_t  convDesc, cudnnConvolutionFwdAlgo_t  algo, void * workSpace, size_t  workSpaceSizeInBytes, const void * beta, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnConvolutionForward) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionFwdAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnConvolutionForward) {
		lcudnnConvolutionForward = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionFwdAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnConvolutionForward");
		tracer._kernel_map[(void *) lcudnnConvolutionForward] = std::string("cudnnConvolutionForward");
	}
	assert(lcudnnConvolutionForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnConvolutionForward(handle, alpha, xDesc, x, wDesc, w, convDesc, algo, workSpace, workSpaceSizeInBytes, beta, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnConvolutionForward);
	}
	return res;
}

cudnnStatus_t cudnnConvolutionBiasActivationForward(cudnnHandle_t  handle, const void * alpha1, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnConvolutionDescriptor_t  convDesc, cudnnConvolutionFwdAlgo_t  algo, void * workSpace, size_t  workSpaceSizeInBytes, const void * alpha2, const cudnnTensorDescriptor_t  zDesc, const void * z, const cudnnTensorDescriptor_t  biasDesc, const void * bias, const cudnnActivationDescriptor_t  activationDesc, const cudnnTensorDescriptor_t  yDesc, void * y)
{
	static cudnnStatus_t (*lcudnnConvolutionBiasActivationForward) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionFwdAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , void *);
	if (!lcudnnConvolutionBiasActivationForward) {
		lcudnnConvolutionBiasActivationForward = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionFwdAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnActivationDescriptor_t , const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnConvolutionBiasActivationForward");
		tracer._kernel_map[(void *) lcudnnConvolutionBiasActivationForward] = std::string("cudnnConvolutionBiasActivationForward");
	}
	assert(lcudnnConvolutionBiasActivationForward);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnConvolutionBiasActivationForward(handle, alpha1, xDesc, x, wDesc, w, convDesc, algo, workSpace, workSpaceSizeInBytes, alpha2, zDesc, z, biasDesc, bias, activationDesc, yDesc, y);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnConvolutionBiasActivationForward);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardDataAlgorithmMaxCount(cudnnHandle_t  handle, int * count)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardDataAlgorithmMaxCount) (cudnnHandle_t , int *);
	if (!lcudnnGetConvolutionBackwardDataAlgorithmMaxCount) {
		lcudnnGetConvolutionBackwardDataAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardDataAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardDataAlgorithmMaxCount] = std::string("cudnnGetConvolutionBackwardDataAlgorithmMaxCount");
	}
	assert(lcudnnGetConvolutionBackwardDataAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardDataAlgorithmMaxCount(handle, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardDataAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionBackwardDataAlgorithm(cudnnHandle_t  handle, const cudnnFilterDescriptor_t  wDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  dxDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdDataAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnFindConvolutionBackwardDataAlgorithm) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *);
	if (!lcudnnFindConvolutionBackwardDataAlgorithm) {
		lcudnnFindConvolutionBackwardDataAlgorithm = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionBackwardDataAlgorithm");
		tracer._kernel_map[(void *) lcudnnFindConvolutionBackwardDataAlgorithm] = std::string("cudnnFindConvolutionBackwardDataAlgorithm");
	}
	assert(lcudnnFindConvolutionBackwardDataAlgorithm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionBackwardDataAlgorithm(handle, wDesc, dyDesc, convDesc, dxDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionBackwardDataAlgorithm);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionBackwardDataAlgorithmEx(cudnnHandle_t  handle, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  dxDesc, void * dx, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdDataAlgoPerf_t * perfResults, void * workSpace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindConvolutionBackwardDataAlgorithmEx) (cudnnHandle_t , const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , void *, const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *, void *, size_t );
	if (!lcudnnFindConvolutionBackwardDataAlgorithmEx) {
		lcudnnFindConvolutionBackwardDataAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , void *, const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionBackwardDataAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindConvolutionBackwardDataAlgorithmEx] = std::string("cudnnFindConvolutionBackwardDataAlgorithmEx");
	}
	assert(lcudnnFindConvolutionBackwardDataAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionBackwardDataAlgorithmEx(handle, wDesc, w, dyDesc, dy, convDesc, dxDesc, dx, requestedAlgoCount, returnedAlgoCount, perfResults, workSpace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionBackwardDataAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardDataAlgorithm_v7(cudnnHandle_t  handle, const cudnnFilterDescriptor_t  filterDesc, const cudnnTensorDescriptor_t  diffDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  gradDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdDataAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardDataAlgorithm_v7) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *);
	if (!lcudnnGetConvolutionBackwardDataAlgorithm_v7) {
		lcudnnGetConvolutionBackwardDataAlgorithm_v7 = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const int , int *, cudnnConvolutionBwdDataAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardDataAlgorithm_v7");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardDataAlgorithm_v7] = std::string("cudnnGetConvolutionBackwardDataAlgorithm_v7");
	}
	assert(lcudnnGetConvolutionBackwardDataAlgorithm_v7);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardDataAlgorithm_v7(handle, filterDesc, diffDesc, convDesc, gradDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardDataAlgorithm_v7);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardDataWorkspaceSize(cudnnHandle_t  handle, const cudnnFilterDescriptor_t  wDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  dxDesc, cudnnConvolutionBwdDataAlgo_t  algo, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardDataWorkspaceSize) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , cudnnConvolutionBwdDataAlgo_t , size_t *);
	if (!lcudnnGetConvolutionBackwardDataWorkspaceSize) {
		lcudnnGetConvolutionBackwardDataWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , cudnnConvolutionBwdDataAlgo_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardDataWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardDataWorkspaceSize] = std::string("cudnnGetConvolutionBackwardDataWorkspaceSize");
	}
	assert(lcudnnGetConvolutionBackwardDataWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardDataWorkspaceSize(handle, wDesc, dyDesc, convDesc, dxDesc, algo, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardDataWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnConvolutionBackwardData(cudnnHandle_t  handle, const void * alpha, const cudnnFilterDescriptor_t  wDesc, const void * w, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnConvolutionDescriptor_t  convDesc, cudnnConvolutionBwdDataAlgo_t  algo, void * workSpace, size_t  workSpaceSizeInBytes, const void * beta, const cudnnTensorDescriptor_t  dxDesc, void * dx)
{
	static cudnnStatus_t (*lcudnnConvolutionBackwardData) (cudnnHandle_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionBwdDataAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnConvolutionBackwardData) {
		lcudnnConvolutionBackwardData = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnFilterDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionBwdDataAlgo_t , void *, size_t , const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnConvolutionBackwardData");
		tracer._kernel_map[(void *) lcudnnConvolutionBackwardData] = std::string("cudnnConvolutionBackwardData");
	}
	assert(lcudnnConvolutionBackwardData);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnConvolutionBackwardData(handle, alpha, wDesc, w, dyDesc, dy, convDesc, algo, workSpace, workSpaceSizeInBytes, beta, dxDesc, dx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnConvolutionBackwardData);
	}
	return res;
}

cudnnStatus_t cudnnGetFoldedConvBackwardDataDescriptors(const cudnnHandle_t  handle, const cudnnFilterDescriptor_t  filterDesc, const cudnnTensorDescriptor_t  diffDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnTensorDescriptor_t  gradDesc, const cudnnTensorFormat_t  transformFormat, cudnnFilterDescriptor_t  foldedFilterDesc, cudnnTensorDescriptor_t  paddedDiffDesc, cudnnConvolutionDescriptor_t  foldedConvDesc, cudnnTensorDescriptor_t  foldedGradDesc, cudnnTensorTransformDescriptor_t  filterFoldTransDesc, cudnnTensorTransformDescriptor_t  diffPadTransDesc, cudnnTensorTransformDescriptor_t  gradFoldTransDesc, cudnnTensorTransformDescriptor_t  gradUnfoldTransDesc)
{
	static cudnnStatus_t (*lcudnnGetFoldedConvBackwardDataDescriptors) (const cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorFormat_t , cudnnFilterDescriptor_t , cudnnTensorDescriptor_t , cudnnConvolutionDescriptor_t , cudnnTensorDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t );
	if (!lcudnnGetFoldedConvBackwardDataDescriptors) {
		lcudnnGetFoldedConvBackwardDataDescriptors = (cudnnStatus_t (*) (const cudnnHandle_t , const cudnnFilterDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnTensorDescriptor_t , const cudnnTensorFormat_t , cudnnFilterDescriptor_t , cudnnTensorDescriptor_t , cudnnConvolutionDescriptor_t , cudnnTensorDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t , cudnnTensorTransformDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnGetFoldedConvBackwardDataDescriptors");
		tracer._kernel_map[(void *) lcudnnGetFoldedConvBackwardDataDescriptors] = std::string("cudnnGetFoldedConvBackwardDataDescriptors");
	}
	assert(lcudnnGetFoldedConvBackwardDataDescriptors);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFoldedConvBackwardDataDescriptors(handle, filterDesc, diffDesc, convDesc, gradDesc, transformFormat, foldedFilterDesc, paddedDiffDesc, foldedConvDesc, foldedGradDesc, filterFoldTransDesc, diffPadTransDesc, gradFoldTransDesc, gradUnfoldTransDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFoldedConvBackwardDataDescriptors);
	}
	return res;
}

cudnnStatus_t cudnnCnnInferVersionCheck()
{
	static cudnnStatus_t (*lcudnnCnnInferVersionCheck) ();
	if (!lcudnnCnnInferVersionCheck) {
		lcudnnCnnInferVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnCnnInferVersionCheck");
		tracer._kernel_map[(void *) lcudnnCnnInferVersionCheck] = std::string("cudnnCnnInferVersionCheck");
	}
	assert(lcudnnCnnInferVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCnnInferVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCnnInferVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardFilterAlgorithmMaxCount(cudnnHandle_t  handle, int * count)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount) (cudnnHandle_t , int *);
	if (!lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount) {
		lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount = (cudnnStatus_t (*) (cudnnHandle_t , int *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardFilterAlgorithmMaxCount");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount] = std::string("cudnnGetConvolutionBackwardFilterAlgorithmMaxCount");
	}
	assert(lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount(handle, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardFilterAlgorithmMaxCount);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionBackwardFilterAlgorithm(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnFilterDescriptor_t  dwDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdFilterAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnFindConvolutionBackwardFilterAlgorithm) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *);
	if (!lcudnnFindConvolutionBackwardFilterAlgorithm) {
		lcudnnFindConvolutionBackwardFilterAlgorithm = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionBackwardFilterAlgorithm");
		tracer._kernel_map[(void *) lcudnnFindConvolutionBackwardFilterAlgorithm] = std::string("cudnnFindConvolutionBackwardFilterAlgorithm");
	}
	assert(lcudnnFindConvolutionBackwardFilterAlgorithm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionBackwardFilterAlgorithm(handle, xDesc, dyDesc, convDesc, dwDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionBackwardFilterAlgorithm);
	}
	return res;
}

cudnnStatus_t cudnnFindConvolutionBackwardFilterAlgorithmEx(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  dyDesc, const void * y, const cudnnConvolutionDescriptor_t  convDesc, const cudnnFilterDescriptor_t  dwDesc, void * dw, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdFilterAlgoPerf_t * perfResults, void * workSpace, size_t  workSpaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnFindConvolutionBackwardFilterAlgorithmEx) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , void *, const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *, void *, size_t );
	if (!lcudnnFindConvolutionBackwardFilterAlgorithmEx) {
		lcudnnFindConvolutionBackwardFilterAlgorithmEx = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , void *, const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *, void *, size_t )) dlsym(tracer.cudnn_handle, "cudnnFindConvolutionBackwardFilterAlgorithmEx");
		tracer._kernel_map[(void *) lcudnnFindConvolutionBackwardFilterAlgorithmEx] = std::string("cudnnFindConvolutionBackwardFilterAlgorithmEx");
	}
	assert(lcudnnFindConvolutionBackwardFilterAlgorithmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFindConvolutionBackwardFilterAlgorithmEx(handle, xDesc, x, dyDesc, y, convDesc, dwDesc, dw, requestedAlgoCount, returnedAlgoCount, perfResults, workSpace, workSpaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFindConvolutionBackwardFilterAlgorithmEx);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardFilterAlgorithm_v7(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  srcDesc, const cudnnTensorDescriptor_t  diffDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnFilterDescriptor_t  gradDesc, const int  requestedAlgoCount, int * returnedAlgoCount, cudnnConvolutionBwdFilterAlgoPerf_t * perfResults)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardFilterAlgorithm_v7) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *);
	if (!lcudnnGetConvolutionBackwardFilterAlgorithm_v7) {
		lcudnnGetConvolutionBackwardFilterAlgorithm_v7 = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , const int , int *, cudnnConvolutionBwdFilterAlgoPerf_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardFilterAlgorithm_v7");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardFilterAlgorithm_v7] = std::string("cudnnGetConvolutionBackwardFilterAlgorithm_v7");
	}
	assert(lcudnnGetConvolutionBackwardFilterAlgorithm_v7);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardFilterAlgorithm_v7(handle, srcDesc, diffDesc, convDesc, gradDesc, requestedAlgoCount, returnedAlgoCount, perfResults);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardFilterAlgorithm_v7);
	}
	return res;
}

cudnnStatus_t cudnnGetConvolutionBackwardFilterWorkspaceSize(cudnnHandle_t  handle, const cudnnTensorDescriptor_t  xDesc, const cudnnTensorDescriptor_t  dyDesc, const cudnnConvolutionDescriptor_t  convDesc, const cudnnFilterDescriptor_t  gradDesc, cudnnConvolutionBwdFilterAlgo_t  algo, size_t * sizeInBytes)
{
	static cudnnStatus_t (*lcudnnGetConvolutionBackwardFilterWorkspaceSize) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , cudnnConvolutionBwdFilterAlgo_t , size_t *);
	if (!lcudnnGetConvolutionBackwardFilterWorkspaceSize) {
		lcudnnGetConvolutionBackwardFilterWorkspaceSize = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnTensorDescriptor_t , const cudnnTensorDescriptor_t , const cudnnConvolutionDescriptor_t , const cudnnFilterDescriptor_t , cudnnConvolutionBwdFilterAlgo_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnGetConvolutionBackwardFilterWorkspaceSize");
		tracer._kernel_map[(void *) lcudnnGetConvolutionBackwardFilterWorkspaceSize] = std::string("cudnnGetConvolutionBackwardFilterWorkspaceSize");
	}
	assert(lcudnnGetConvolutionBackwardFilterWorkspaceSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetConvolutionBackwardFilterWorkspaceSize(handle, xDesc, dyDesc, convDesc, gradDesc, algo, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetConvolutionBackwardFilterWorkspaceSize);
	}
	return res;
}

cudnnStatus_t cudnnConvolutionBackwardFilter(cudnnHandle_t  handle, const void * alpha, const cudnnTensorDescriptor_t  xDesc, const void * x, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const cudnnConvolutionDescriptor_t  convDesc, cudnnConvolutionBwdFilterAlgo_t  algo, void * workSpace, size_t  workSpaceSizeInBytes, const void * beta, const cudnnFilterDescriptor_t  dwDesc, void * dw)
{
	static cudnnStatus_t (*lcudnnConvolutionBackwardFilter) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionBwdFilterAlgo_t , void *, size_t , const void *, const cudnnFilterDescriptor_t , void *);
	if (!lcudnnConvolutionBackwardFilter) {
		lcudnnConvolutionBackwardFilter = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnTensorDescriptor_t , const void *, const cudnnConvolutionDescriptor_t , cudnnConvolutionBwdFilterAlgo_t , void *, size_t , const void *, const cudnnFilterDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnConvolutionBackwardFilter");
		tracer._kernel_map[(void *) lcudnnConvolutionBackwardFilter] = std::string("cudnnConvolutionBackwardFilter");
	}
	assert(lcudnnConvolutionBackwardFilter);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnConvolutionBackwardFilter(handle, alpha, xDesc, x, dyDesc, dy, convDesc, algo, workSpace, workSpaceSizeInBytes, beta, dwDesc, dw);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnConvolutionBackwardFilter);
	}
	return res;
}

cudnnStatus_t cudnnConvolutionBackwardBias(cudnnHandle_t  handle, const void * alpha, const cudnnTensorDescriptor_t  dyDesc, const void * dy, const void * beta, const cudnnTensorDescriptor_t  dbDesc, void * db)
{
	static cudnnStatus_t (*lcudnnConvolutionBackwardBias) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *);
	if (!lcudnnConvolutionBackwardBias) {
		lcudnnConvolutionBackwardBias = (cudnnStatus_t (*) (cudnnHandle_t , const void *, const cudnnTensorDescriptor_t , const void *, const void *, const cudnnTensorDescriptor_t , void *)) dlsym(tracer.cudnn_handle, "cudnnConvolutionBackwardBias");
		tracer._kernel_map[(void *) lcudnnConvolutionBackwardBias] = std::string("cudnnConvolutionBackwardBias");
	}
	assert(lcudnnConvolutionBackwardBias);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnConvolutionBackwardBias(handle, alpha, dyDesc, dy, beta, dbDesc, db);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnConvolutionBackwardBias);
	}
	return res;
}

cudnnStatus_t cudnnCreateFusedOpsConstParamPack(cudnnFusedOpsConstParamPack_t * constPack, cudnnFusedOps_t  ops)
{
	static cudnnStatus_t (*lcudnnCreateFusedOpsConstParamPack) (cudnnFusedOpsConstParamPack_t *, cudnnFusedOps_t );
	if (!lcudnnCreateFusedOpsConstParamPack) {
		lcudnnCreateFusedOpsConstParamPack = (cudnnStatus_t (*) (cudnnFusedOpsConstParamPack_t *, cudnnFusedOps_t )) dlsym(tracer.cudnn_handle, "cudnnCreateFusedOpsConstParamPack");
		tracer._kernel_map[(void *) lcudnnCreateFusedOpsConstParamPack] = std::string("cudnnCreateFusedOpsConstParamPack");
	}
	assert(lcudnnCreateFusedOpsConstParamPack);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateFusedOpsConstParamPack(constPack, ops);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateFusedOpsConstParamPack);
	}
	return res;
}

cudnnStatus_t cudnnDestroyFusedOpsConstParamPack(cudnnFusedOpsConstParamPack_t  constPack)
{
	static cudnnStatus_t (*lcudnnDestroyFusedOpsConstParamPack) (cudnnFusedOpsConstParamPack_t );
	if (!lcudnnDestroyFusedOpsConstParamPack) {
		lcudnnDestroyFusedOpsConstParamPack = (cudnnStatus_t (*) (cudnnFusedOpsConstParamPack_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyFusedOpsConstParamPack");
		tracer._kernel_map[(void *) lcudnnDestroyFusedOpsConstParamPack] = std::string("cudnnDestroyFusedOpsConstParamPack");
	}
	assert(lcudnnDestroyFusedOpsConstParamPack);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyFusedOpsConstParamPack(constPack);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyFusedOpsConstParamPack);
	}
	return res;
}

cudnnStatus_t cudnnSetFusedOpsConstParamPackAttribute(cudnnFusedOpsConstParamPack_t  constPack, cudnnFusedOpsConstParamLabel_t  paramLabel, const void * param)
{
	static cudnnStatus_t (*lcudnnSetFusedOpsConstParamPackAttribute) (cudnnFusedOpsConstParamPack_t , cudnnFusedOpsConstParamLabel_t , const void *);
	if (!lcudnnSetFusedOpsConstParamPackAttribute) {
		lcudnnSetFusedOpsConstParamPackAttribute = (cudnnStatus_t (*) (cudnnFusedOpsConstParamPack_t , cudnnFusedOpsConstParamLabel_t , const void *)) dlsym(tracer.cudnn_handle, "cudnnSetFusedOpsConstParamPackAttribute");
		tracer._kernel_map[(void *) lcudnnSetFusedOpsConstParamPackAttribute] = std::string("cudnnSetFusedOpsConstParamPackAttribute");
	}
	assert(lcudnnSetFusedOpsConstParamPackAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetFusedOpsConstParamPackAttribute(constPack, paramLabel, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetFusedOpsConstParamPackAttribute);
	}
	return res;
}

cudnnStatus_t cudnnGetFusedOpsConstParamPackAttribute(const cudnnFusedOpsConstParamPack_t  constPack, cudnnFusedOpsConstParamLabel_t  paramLabel, void * param, int * isNULL)
{
	static cudnnStatus_t (*lcudnnGetFusedOpsConstParamPackAttribute) (const cudnnFusedOpsConstParamPack_t , cudnnFusedOpsConstParamLabel_t , void *, int *);
	if (!lcudnnGetFusedOpsConstParamPackAttribute) {
		lcudnnGetFusedOpsConstParamPackAttribute = (cudnnStatus_t (*) (const cudnnFusedOpsConstParamPack_t , cudnnFusedOpsConstParamLabel_t , void *, int *)) dlsym(tracer.cudnn_handle, "cudnnGetFusedOpsConstParamPackAttribute");
		tracer._kernel_map[(void *) lcudnnGetFusedOpsConstParamPackAttribute] = std::string("cudnnGetFusedOpsConstParamPackAttribute");
	}
	assert(lcudnnGetFusedOpsConstParamPackAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFusedOpsConstParamPackAttribute(constPack, paramLabel, param, isNULL);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFusedOpsConstParamPackAttribute);
	}
	return res;
}

cudnnStatus_t cudnnCreateFusedOpsVariantParamPack(cudnnFusedOpsVariantParamPack_t * varPack, cudnnFusedOps_t  ops)
{
	static cudnnStatus_t (*lcudnnCreateFusedOpsVariantParamPack) (cudnnFusedOpsVariantParamPack_t *, cudnnFusedOps_t );
	if (!lcudnnCreateFusedOpsVariantParamPack) {
		lcudnnCreateFusedOpsVariantParamPack = (cudnnStatus_t (*) (cudnnFusedOpsVariantParamPack_t *, cudnnFusedOps_t )) dlsym(tracer.cudnn_handle, "cudnnCreateFusedOpsVariantParamPack");
		tracer._kernel_map[(void *) lcudnnCreateFusedOpsVariantParamPack] = std::string("cudnnCreateFusedOpsVariantParamPack");
	}
	assert(lcudnnCreateFusedOpsVariantParamPack);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateFusedOpsVariantParamPack(varPack, ops);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateFusedOpsVariantParamPack);
	}
	return res;
}

cudnnStatus_t cudnnDestroyFusedOpsVariantParamPack(cudnnFusedOpsVariantParamPack_t  varPack)
{
	static cudnnStatus_t (*lcudnnDestroyFusedOpsVariantParamPack) (cudnnFusedOpsVariantParamPack_t );
	if (!lcudnnDestroyFusedOpsVariantParamPack) {
		lcudnnDestroyFusedOpsVariantParamPack = (cudnnStatus_t (*) (cudnnFusedOpsVariantParamPack_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyFusedOpsVariantParamPack");
		tracer._kernel_map[(void *) lcudnnDestroyFusedOpsVariantParamPack] = std::string("cudnnDestroyFusedOpsVariantParamPack");
	}
	assert(lcudnnDestroyFusedOpsVariantParamPack);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyFusedOpsVariantParamPack(varPack);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyFusedOpsVariantParamPack);
	}
	return res;
}

cudnnStatus_t cudnnSetFusedOpsVariantParamPackAttribute(cudnnFusedOpsVariantParamPack_t  varPack, cudnnFusedOpsVariantParamLabel_t  paramLabel, void * ptr)
{
	static cudnnStatus_t (*lcudnnSetFusedOpsVariantParamPackAttribute) (cudnnFusedOpsVariantParamPack_t , cudnnFusedOpsVariantParamLabel_t , void *);
	if (!lcudnnSetFusedOpsVariantParamPackAttribute) {
		lcudnnSetFusedOpsVariantParamPackAttribute = (cudnnStatus_t (*) (cudnnFusedOpsVariantParamPack_t , cudnnFusedOpsVariantParamLabel_t , void *)) dlsym(tracer.cudnn_handle, "cudnnSetFusedOpsVariantParamPackAttribute");
		tracer._kernel_map[(void *) lcudnnSetFusedOpsVariantParamPackAttribute] = std::string("cudnnSetFusedOpsVariantParamPackAttribute");
	}
	assert(lcudnnSetFusedOpsVariantParamPackAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnSetFusedOpsVariantParamPackAttribute(varPack, paramLabel, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnSetFusedOpsVariantParamPackAttribute);
	}
	return res;
}

cudnnStatus_t cudnnGetFusedOpsVariantParamPackAttribute(const cudnnFusedOpsVariantParamPack_t  varPack, cudnnFusedOpsVariantParamLabel_t  paramLabel, void * ptr)
{
	static cudnnStatus_t (*lcudnnGetFusedOpsVariantParamPackAttribute) (const cudnnFusedOpsVariantParamPack_t , cudnnFusedOpsVariantParamLabel_t , void *);
	if (!lcudnnGetFusedOpsVariantParamPackAttribute) {
		lcudnnGetFusedOpsVariantParamPackAttribute = (cudnnStatus_t (*) (const cudnnFusedOpsVariantParamPack_t , cudnnFusedOpsVariantParamLabel_t , void *)) dlsym(tracer.cudnn_handle, "cudnnGetFusedOpsVariantParamPackAttribute");
		tracer._kernel_map[(void *) lcudnnGetFusedOpsVariantParamPackAttribute] = std::string("cudnnGetFusedOpsVariantParamPackAttribute");
	}
	assert(lcudnnGetFusedOpsVariantParamPackAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnGetFusedOpsVariantParamPackAttribute(varPack, paramLabel, ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnGetFusedOpsVariantParamPackAttribute);
	}
	return res;
}

cudnnStatus_t cudnnCreateFusedOpsPlan(cudnnFusedOpsPlan_t * plan, cudnnFusedOps_t  ops)
{
	static cudnnStatus_t (*lcudnnCreateFusedOpsPlan) (cudnnFusedOpsPlan_t *, cudnnFusedOps_t );
	if (!lcudnnCreateFusedOpsPlan) {
		lcudnnCreateFusedOpsPlan = (cudnnStatus_t (*) (cudnnFusedOpsPlan_t *, cudnnFusedOps_t )) dlsym(tracer.cudnn_handle, "cudnnCreateFusedOpsPlan");
		tracer._kernel_map[(void *) lcudnnCreateFusedOpsPlan] = std::string("cudnnCreateFusedOpsPlan");
	}
	assert(lcudnnCreateFusedOpsPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCreateFusedOpsPlan(plan, ops);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCreateFusedOpsPlan);
	}
	return res;
}

cudnnStatus_t cudnnDestroyFusedOpsPlan(cudnnFusedOpsPlan_t  plan)
{
	static cudnnStatus_t (*lcudnnDestroyFusedOpsPlan) (cudnnFusedOpsPlan_t );
	if (!lcudnnDestroyFusedOpsPlan) {
		lcudnnDestroyFusedOpsPlan = (cudnnStatus_t (*) (cudnnFusedOpsPlan_t )) dlsym(tracer.cudnn_handle, "cudnnDestroyFusedOpsPlan");
		tracer._kernel_map[(void *) lcudnnDestroyFusedOpsPlan] = std::string("cudnnDestroyFusedOpsPlan");
	}
	assert(lcudnnDestroyFusedOpsPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnDestroyFusedOpsPlan(plan);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnDestroyFusedOpsPlan);
	}
	return res;
}

cudnnStatus_t cudnnMakeFusedOpsPlan(cudnnHandle_t  handle, cudnnFusedOpsPlan_t  plan, const cudnnFusedOpsConstParamPack_t  constPack, size_t * workspaceSizeInBytes)
{
	static cudnnStatus_t (*lcudnnMakeFusedOpsPlan) (cudnnHandle_t , cudnnFusedOpsPlan_t , const cudnnFusedOpsConstParamPack_t , size_t *);
	if (!lcudnnMakeFusedOpsPlan) {
		lcudnnMakeFusedOpsPlan = (cudnnStatus_t (*) (cudnnHandle_t , cudnnFusedOpsPlan_t , const cudnnFusedOpsConstParamPack_t , size_t *)) dlsym(tracer.cudnn_handle, "cudnnMakeFusedOpsPlan");
		tracer._kernel_map[(void *) lcudnnMakeFusedOpsPlan] = std::string("cudnnMakeFusedOpsPlan");
	}
	assert(lcudnnMakeFusedOpsPlan);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnMakeFusedOpsPlan(handle, plan, constPack, workspaceSizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnMakeFusedOpsPlan);
	}
	return res;
}

cudnnStatus_t cudnnFusedOpsExecute(cudnnHandle_t  handle, const cudnnFusedOpsPlan_t  plan, cudnnFusedOpsVariantParamPack_t  varPack)
{
	static cudnnStatus_t (*lcudnnFusedOpsExecute) (cudnnHandle_t , const cudnnFusedOpsPlan_t , cudnnFusedOpsVariantParamPack_t );
	if (!lcudnnFusedOpsExecute) {
		lcudnnFusedOpsExecute = (cudnnStatus_t (*) (cudnnHandle_t , const cudnnFusedOpsPlan_t , cudnnFusedOpsVariantParamPack_t )) dlsym(tracer.cudnn_handle, "cudnnFusedOpsExecute");
		tracer._kernel_map[(void *) lcudnnFusedOpsExecute] = std::string("cudnnFusedOpsExecute");
	}
	assert(lcudnnFusedOpsExecute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnFusedOpsExecute(handle, plan, varPack);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnFusedOpsExecute);
	}
	return res;
}

cudnnStatus_t cudnnCnnTrainVersionCheck()
{
	static cudnnStatus_t (*lcudnnCnnTrainVersionCheck) ();
	if (!lcudnnCnnTrainVersionCheck) {
		lcudnnCnnTrainVersionCheck = (cudnnStatus_t (*) ()) dlsym(tracer.cudnn_handle, "cudnnCnnTrainVersionCheck");
		tracer._kernel_map[(void *) lcudnnCnnTrainVersionCheck] = std::string("cudnnCnnTrainVersionCheck");
	}
	assert(lcudnnCnnTrainVersionCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnCnnTrainVersionCheck();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnCnnTrainVersionCheck);
	}
	return res;
}

cudnnStatus_t cudnnBackendCreateDescriptor(cudnnBackendDescriptorType_t  descriptorType, cudnnBackendDescriptor_t * descriptor)
{
	static cudnnStatus_t (*lcudnnBackendCreateDescriptor) (cudnnBackendDescriptorType_t , cudnnBackendDescriptor_t *);
	if (!lcudnnBackendCreateDescriptor) {
		lcudnnBackendCreateDescriptor = (cudnnStatus_t (*) (cudnnBackendDescriptorType_t , cudnnBackendDescriptor_t *)) dlsym(tracer.cudnn_handle, "cudnnBackendCreateDescriptor");
		tracer._kernel_map[(void *) lcudnnBackendCreateDescriptor] = std::string("cudnnBackendCreateDescriptor");
	}
	assert(lcudnnBackendCreateDescriptor);
	cudnnStatus_t res = 
		lcudnnBackendCreateDescriptor(descriptorType, descriptor);
	return res;
}

cudnnStatus_t cudnnBackendDestroyDescriptor(cudnnBackendDescriptor_t  descriptor)
{
	static cudnnStatus_t (*lcudnnBackendDestroyDescriptor) (cudnnBackendDescriptor_t );
	if (!lcudnnBackendDestroyDescriptor) {
		lcudnnBackendDestroyDescriptor = (cudnnStatus_t (*) (cudnnBackendDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnBackendDestroyDescriptor");
		tracer._kernel_map[(void *) lcudnnBackendDestroyDescriptor] = std::string("cudnnBackendDestroyDescriptor");
	}
	assert(lcudnnBackendDestroyDescriptor);
	cudnnStatus_t res = 
		lcudnnBackendDestroyDescriptor(descriptor);
	return res;
}

cudnnStatus_t cudnnBackendInitialize(cudnnBackendDescriptor_t  descriptor)
{
	static cudnnStatus_t (*lcudnnBackendInitialize) (cudnnBackendDescriptor_t );
	if (!lcudnnBackendInitialize) {
		lcudnnBackendInitialize = (cudnnStatus_t (*) (cudnnBackendDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnBackendInitialize");
		tracer._kernel_map[(void *) lcudnnBackendInitialize] = std::string("cudnnBackendInitialize");
	}
	assert(lcudnnBackendInitialize);
	cudnnStatus_t res = 
		lcudnnBackendInitialize(descriptor);
	return res;
}

cudnnStatus_t cudnnBackendFinalize(cudnnBackendDescriptor_t  descriptor)
{
	static cudnnStatus_t (*lcudnnBackendFinalize) (cudnnBackendDescriptor_t );
	if (!lcudnnBackendFinalize) {
		lcudnnBackendFinalize = (cudnnStatus_t (*) (cudnnBackendDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnBackendFinalize");
		tracer._kernel_map[(void *) lcudnnBackendFinalize] = std::string("cudnnBackendFinalize");
	}
	assert(lcudnnBackendFinalize);
	cudnnStatus_t res = 
		lcudnnBackendFinalize(descriptor);
	return res;
}

cudnnStatus_t cudnnBackendSetAttribute(cudnnBackendDescriptor_t  descriptor, cudnnBackendAttributeName_t  attributeName, cudnnBackendAttributeType_t  attributeType, int64_t  elementCount, const void * arrayOfElements)
{
	static cudnnStatus_t (*lcudnnBackendSetAttribute) (cudnnBackendDescriptor_t , cudnnBackendAttributeName_t , cudnnBackendAttributeType_t , int64_t , const void *);
	if (!lcudnnBackendSetAttribute) {
		lcudnnBackendSetAttribute = (cudnnStatus_t (*) (cudnnBackendDescriptor_t , cudnnBackendAttributeName_t , cudnnBackendAttributeType_t , int64_t , const void *)) dlsym(tracer.cudnn_handle, "cudnnBackendSetAttribute");
		tracer._kernel_map[(void *) lcudnnBackendSetAttribute] = std::string("cudnnBackendSetAttribute");
	}
	assert(lcudnnBackendSetAttribute);
	cudnnStatus_t res = 
		lcudnnBackendSetAttribute(descriptor, attributeName, attributeType, elementCount, arrayOfElements);
	return res;
}

cudnnStatus_t cudnnBackendGetAttribute(cudnnBackendDescriptor_t const  descriptor, cudnnBackendAttributeName_t  attributeName, cudnnBackendAttributeType_t  attributeType, int64_t  requestedElementCount, int64_t * elementCount, void * arrayOfElements)
{
	static cudnnStatus_t (*lcudnnBackendGetAttribute) (cudnnBackendDescriptor_t const , cudnnBackendAttributeName_t , cudnnBackendAttributeType_t , int64_t , int64_t *, void *);
	if (!lcudnnBackendGetAttribute) {
		lcudnnBackendGetAttribute = (cudnnStatus_t (*) (cudnnBackendDescriptor_t const , cudnnBackendAttributeName_t , cudnnBackendAttributeType_t , int64_t , int64_t *, void *)) dlsym(tracer.cudnn_handle, "cudnnBackendGetAttribute");
		tracer._kernel_map[(void *) lcudnnBackendGetAttribute] = std::string("cudnnBackendGetAttribute");
	}
	assert(lcudnnBackendGetAttribute);
	cudnnStatus_t res = 
		lcudnnBackendGetAttribute(descriptor, attributeName, attributeType, requestedElementCount, elementCount, arrayOfElements);
	return res;
}

cudnnStatus_t cudnnBackendExecute(cudnnHandle_t  handle, cudnnBackendDescriptor_t  executionPlan, cudnnBackendDescriptor_t  variantPack)
{
	static cudnnStatus_t (*lcudnnBackendExecute) (cudnnHandle_t , cudnnBackendDescriptor_t , cudnnBackendDescriptor_t );
	if (!lcudnnBackendExecute) {
		lcudnnBackendExecute = (cudnnStatus_t (*) (cudnnHandle_t , cudnnBackendDescriptor_t , cudnnBackendDescriptor_t )) dlsym(tracer.cudnn_handle, "cudnnBackendExecute");
		tracer._kernel_map[(void *) lcudnnBackendExecute] = std::string("cudnnBackendExecute");
	}
	assert(lcudnnBackendExecute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cudnnStatus_t res = 
		lcudnnBackendExecute(handle, executionPlan, variantPack);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcudnnBackendExecute);
	}
	return res;
}

cublasStatus_t cublasCreate_v2(cublasHandle_t*  handle)
{
	static cublasStatus_t (*lcublasCreate_v2) (cublasHandle_t* );
	if (!lcublasCreate_v2) {
		lcublasCreate_v2 = (cublasStatus_t (*) (cublasHandle_t* )) dlsym(RTLD_NEXT, "cublasCreate_v2");
		tracer._kernel_map[(void *) lcublasCreate_v2] = std::string("cublasCreate_v2");
	}
	assert(lcublasCreate_v2);
	cublasStatus_t res = 
		lcublasCreate_v2(handle);
	return res;
}

cublasStatus_t cublasDestroy_v2(cublasHandle_t  handle)
{
	static cublasStatus_t (*lcublasDestroy_v2) (cublasHandle_t );
	if (!lcublasDestroy_v2) {
		lcublasDestroy_v2 = (cublasStatus_t (*) (cublasHandle_t )) dlsym(RTLD_NEXT, "cublasDestroy_v2");
		tracer._kernel_map[(void *) lcublasDestroy_v2] = std::string("cublasDestroy_v2");
	}
	assert(lcublasDestroy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDestroy_v2(handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDestroy_v2);
	}
	return res;
}

cublasStatus_t cublasGetVersion_v2(cublasHandle_t  handle, int*  version)
{
	static cublasStatus_t (*lcublasGetVersion_v2) (cublasHandle_t , int* );
	if (!lcublasGetVersion_v2) {
		lcublasGetVersion_v2 = (cublasStatus_t (*) (cublasHandle_t , int* )) dlsym(RTLD_NEXT, "cublasGetVersion_v2");
		tracer._kernel_map[(void *) lcublasGetVersion_v2] = std::string("cublasGetVersion_v2");
	}
	assert(lcublasGetVersion_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetVersion_v2(handle, version);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetVersion_v2);
	}
	return res;
}

cublasStatus_t cublasGetProperty(libraryPropertyType  type, int*  value)
{
	static cublasStatus_t (*lcublasGetProperty) (libraryPropertyType , int* );
	if (!lcublasGetProperty) {
		lcublasGetProperty = (cublasStatus_t (*) (libraryPropertyType , int* )) dlsym(RTLD_NEXT, "cublasGetProperty");
		tracer._kernel_map[(void *) lcublasGetProperty] = std::string("cublasGetProperty");
	}
	assert(lcublasGetProperty);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetProperty(type, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetProperty);
	}
	return res;
}

size_t cublasGetCudartVersion()
{
	static size_t (*lcublasGetCudartVersion) ();
	if (!lcublasGetCudartVersion) {
		lcublasGetCudartVersion = (size_t (*) ()) dlsym(RTLD_NEXT, "cublasGetCudartVersion");
		tracer._kernel_map[(void *) lcublasGetCudartVersion] = std::string("cublasGetCudartVersion");
	}
	assert(lcublasGetCudartVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcublasGetCudartVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetCudartVersion);
	}
	return res;
}

cublasStatus_t cublasSetWorkspace_v2(cublasHandle_t  handle, void*  workspace, size_t  workspaceSizeInBytes)
{
	static cublasStatus_t (*lcublasSetWorkspace_v2) (cublasHandle_t , void* , size_t );
	if (!lcublasSetWorkspace_v2) {
		lcublasSetWorkspace_v2 = (cublasStatus_t (*) (cublasHandle_t , void* , size_t )) dlsym(RTLD_NEXT, "cublasSetWorkspace_v2");
		tracer._kernel_map[(void *) lcublasSetWorkspace_v2] = std::string("cublasSetWorkspace_v2");
	}
	assert(lcublasSetWorkspace_v2);
	cublasStatus_t res = 
		lcublasSetWorkspace_v2(handle, workspace, workspaceSizeInBytes);
	return res;
}

cublasStatus_t cublasSetStream_v2(cublasHandle_t  handle, cudaStream_t  streamId)
{
	static cublasStatus_t (*lcublasSetStream_v2) (cublasHandle_t , cudaStream_t );
	if (!lcublasSetStream_v2) {
		lcublasSetStream_v2 = (cublasStatus_t (*) (cublasHandle_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasSetStream_v2");
		tracer._kernel_map[(void *) lcublasSetStream_v2] = std::string("cublasSetStream_v2");
	}
	assert(lcublasSetStream_v2);
	cublasStatus_t res = 
		lcublasSetStream_v2(handle, streamId);
	return res;
}

cublasStatus_t cublasGetStream_v2(cublasHandle_t  handle, cudaStream_t*  streamId)
{
	static cublasStatus_t (*lcublasGetStream_v2) (cublasHandle_t , cudaStream_t* );
	if (!lcublasGetStream_v2) {
		lcublasGetStream_v2 = (cublasStatus_t (*) (cublasHandle_t , cudaStream_t* )) dlsym(RTLD_NEXT, "cublasGetStream_v2");
		tracer._kernel_map[(void *) lcublasGetStream_v2] = std::string("cublasGetStream_v2");
	}
	assert(lcublasGetStream_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetStream_v2(handle, streamId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetStream_v2);
	}
	return res;
}

cublasStatus_t cublasGetPointerMode_v2(cublasHandle_t  handle, cublasPointerMode_t*  mode)
{
	static cublasStatus_t (*lcublasGetPointerMode_v2) (cublasHandle_t , cublasPointerMode_t* );
	if (!lcublasGetPointerMode_v2) {
		lcublasGetPointerMode_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasPointerMode_t* )) dlsym(RTLD_NEXT, "cublasGetPointerMode_v2");
		tracer._kernel_map[(void *) lcublasGetPointerMode_v2] = std::string("cublasGetPointerMode_v2");
	}
	assert(lcublasGetPointerMode_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetPointerMode_v2(handle, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetPointerMode_v2);
	}
	return res;
}

cublasStatus_t cublasSetPointerMode_v2(cublasHandle_t  handle, cublasPointerMode_t  mode)
{
	static cublasStatus_t (*lcublasSetPointerMode_v2) (cublasHandle_t , cublasPointerMode_t );
	if (!lcublasSetPointerMode_v2) {
		lcublasSetPointerMode_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasPointerMode_t )) dlsym(RTLD_NEXT, "cublasSetPointerMode_v2");
		tracer._kernel_map[(void *) lcublasSetPointerMode_v2] = std::string("cublasSetPointerMode_v2");
	}
	assert(lcublasSetPointerMode_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetPointerMode_v2(handle, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetPointerMode_v2);
	}
	return res;
}

cublasStatus_t cublasGetAtomicsMode(cublasHandle_t  handle, cublasAtomicsMode_t*  mode)
{
	static cublasStatus_t (*lcublasGetAtomicsMode) (cublasHandle_t , cublasAtomicsMode_t* );
	if (!lcublasGetAtomicsMode) {
		lcublasGetAtomicsMode = (cublasStatus_t (*) (cublasHandle_t , cublasAtomicsMode_t* )) dlsym(RTLD_NEXT, "cublasGetAtomicsMode");
		tracer._kernel_map[(void *) lcublasGetAtomicsMode] = std::string("cublasGetAtomicsMode");
	}
	assert(lcublasGetAtomicsMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetAtomicsMode(handle, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetAtomicsMode);
	}
	return res;
}

cublasStatus_t cublasSetAtomicsMode(cublasHandle_t  handle, cublasAtomicsMode_t  mode)
{
	static cublasStatus_t (*lcublasSetAtomicsMode) (cublasHandle_t , cublasAtomicsMode_t );
	if (!lcublasSetAtomicsMode) {
		lcublasSetAtomicsMode = (cublasStatus_t (*) (cublasHandle_t , cublasAtomicsMode_t )) dlsym(RTLD_NEXT, "cublasSetAtomicsMode");
		tracer._kernel_map[(void *) lcublasSetAtomicsMode] = std::string("cublasSetAtomicsMode");
	}
	assert(lcublasSetAtomicsMode);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetAtomicsMode(handle, mode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetAtomicsMode);
	}
	return res;
}

cublasStatus_t cublasGetMathMode(cublasHandle_t  handle, cublasMath_t*  mode)
{
	static cublasStatus_t (*lcublasGetMathMode) (cublasHandle_t , cublasMath_t* );
	if (!lcublasGetMathMode) {
		lcublasGetMathMode = (cublasStatus_t (*) (cublasHandle_t , cublasMath_t* )) dlsym(RTLD_NEXT, "cublasGetMathMode");
		tracer._kernel_map[(void *) lcublasGetMathMode] = std::string("cublasGetMathMode");
	}
	assert(lcublasGetMathMode);
	cublasStatus_t res = 
		lcublasGetMathMode(handle, mode);
	return res;
}

cublasStatus_t cublasSetMathMode(cublasHandle_t  handle, cublasMath_t  mode)
{
	static cublasStatus_t (*lcublasSetMathMode) (cublasHandle_t , cublasMath_t );
	if (!lcublasSetMathMode) {
		lcublasSetMathMode = (cublasStatus_t (*) (cublasHandle_t , cublasMath_t )) dlsym(RTLD_NEXT, "cublasSetMathMode");
		tracer._kernel_map[(void *) lcublasSetMathMode] = std::string("cublasSetMathMode");
	}
	assert(lcublasSetMathMode);
	cublasStatus_t res = 
		lcublasSetMathMode(handle, mode);
	return res;
}

cublasStatus_t cublasGetSmCountTarget(cublasHandle_t  handle, int*  smCountTarget)
{
	static cublasStatus_t (*lcublasGetSmCountTarget) (cublasHandle_t , int* );
	if (!lcublasGetSmCountTarget) {
		lcublasGetSmCountTarget = (cublasStatus_t (*) (cublasHandle_t , int* )) dlsym(RTLD_NEXT, "cublasGetSmCountTarget");
		tracer._kernel_map[(void *) lcublasGetSmCountTarget] = std::string("cublasGetSmCountTarget");
	}
	assert(lcublasGetSmCountTarget);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetSmCountTarget(handle, smCountTarget);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetSmCountTarget);
	}
	return res;
}

cublasStatus_t cublasSetSmCountTarget(cublasHandle_t  handle, int  smCountTarget)
{
	static cublasStatus_t (*lcublasSetSmCountTarget) (cublasHandle_t , int );
	if (!lcublasSetSmCountTarget) {
		lcublasSetSmCountTarget = (cublasStatus_t (*) (cublasHandle_t , int )) dlsym(RTLD_NEXT, "cublasSetSmCountTarget");
		tracer._kernel_map[(void *) lcublasSetSmCountTarget] = std::string("cublasSetSmCountTarget");
	}
	assert(lcublasSetSmCountTarget);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetSmCountTarget(handle, smCountTarget);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetSmCountTarget);
	}
	return res;
}

const char* cublasGetStatusName(cublasStatus_t  status)
{
	static const char* (*lcublasGetStatusName) (cublasStatus_t );
	if (!lcublasGetStatusName) {
		lcublasGetStatusName = (const char* (*) (cublasStatus_t )) dlsym(RTLD_NEXT, "cublasGetStatusName");
		tracer._kernel_map[(void *) lcublasGetStatusName] = std::string("cublasGetStatusName");
	}
	assert(lcublasGetStatusName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcublasGetStatusName(status);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetStatusName);
	}
	return res;
}

const char* cublasGetStatusString(cublasStatus_t  status)
{
	static const char* (*lcublasGetStatusString) (cublasStatus_t );
	if (!lcublasGetStatusString) {
		lcublasGetStatusString = (const char* (*) (cublasStatus_t )) dlsym(RTLD_NEXT, "cublasGetStatusString");
		tracer._kernel_map[(void *) lcublasGetStatusString] = std::string("cublasGetStatusString");
	}
	assert(lcublasGetStatusString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcublasGetStatusString(status);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetStatusString);
	}
	return res;
}

cublasStatus_t cublasLoggerConfigure(int  logIsOn, int  logToStdOut, int  logToStdErr, const char*  logFileName)
{
	static cublasStatus_t (*lcublasLoggerConfigure) (int , int , int , const char* );
	if (!lcublasLoggerConfigure) {
		lcublasLoggerConfigure = (cublasStatus_t (*) (int , int , int , const char* )) dlsym(RTLD_NEXT, "cublasLoggerConfigure");
		tracer._kernel_map[(void *) lcublasLoggerConfigure] = std::string("cublasLoggerConfigure");
	}
	assert(lcublasLoggerConfigure);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLoggerConfigure(logIsOn, logToStdOut, logToStdErr, logFileName);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLoggerConfigure);
	}
	return res;
}

cublasStatus_t cublasSetLoggerCallback(cublasLogCallback  userCallback)
{
	static cublasStatus_t (*lcublasSetLoggerCallback) (cublasLogCallback );
	if (!lcublasSetLoggerCallback) {
		lcublasSetLoggerCallback = (cublasStatus_t (*) (cublasLogCallback )) dlsym(RTLD_NEXT, "cublasSetLoggerCallback");
		tracer._kernel_map[(void *) lcublasSetLoggerCallback] = std::string("cublasSetLoggerCallback");
	}
	assert(lcublasSetLoggerCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetLoggerCallback(userCallback);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetLoggerCallback);
	}
	return res;
}

cublasStatus_t cublasGetLoggerCallback(cublasLogCallback*  userCallback)
{
	static cublasStatus_t (*lcublasGetLoggerCallback) (cublasLogCallback* );
	if (!lcublasGetLoggerCallback) {
		lcublasGetLoggerCallback = (cublasStatus_t (*) (cublasLogCallback* )) dlsym(RTLD_NEXT, "cublasGetLoggerCallback");
		tracer._kernel_map[(void *) lcublasGetLoggerCallback] = std::string("cublasGetLoggerCallback");
	}
	assert(lcublasGetLoggerCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetLoggerCallback(userCallback);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetLoggerCallback);
	}
	return res;
}

cublasStatus_t cublasSetVector(int  n, int  elemSize, const void*  x, int  incx, void*  devicePtr, int  incy)
{
	static cublasStatus_t (*lcublasSetVector) (int , int , const void* , int , void* , int );
	if (!lcublasSetVector) {
		lcublasSetVector = (cublasStatus_t (*) (int , int , const void* , int , void* , int )) dlsym(RTLD_NEXT, "cublasSetVector");
		tracer._kernel_map[(void *) lcublasSetVector] = std::string("cublasSetVector");
	}
	assert(lcublasSetVector);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetVector(n, elemSize, x, incx, devicePtr, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetVector);
	}
	return res;
}

cublasStatus_t cublasSetVector_64(int64_t  n, int64_t  elemSize, const void*  x, int64_t  incx, void*  devicePtr, int64_t  incy)
{
	static cublasStatus_t (*lcublasSetVector_64) (int64_t , int64_t , const void* , int64_t , void* , int64_t );
	if (!lcublasSetVector_64) {
		lcublasSetVector_64 = (cublasStatus_t (*) (int64_t , int64_t , const void* , int64_t , void* , int64_t )) dlsym(RTLD_NEXT, "cublasSetVector_64");
		tracer._kernel_map[(void *) lcublasSetVector_64] = std::string("cublasSetVector_64");
	}
	assert(lcublasSetVector_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetVector_64(n, elemSize, x, incx, devicePtr, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetVector_64);
	}
	return res;
}

cublasStatus_t cublasGetVector(int  n, int  elemSize, const void*  x, int  incx, void*  y, int  incy)
{
	static cublasStatus_t (*lcublasGetVector) (int , int , const void* , int , void* , int );
	if (!lcublasGetVector) {
		lcublasGetVector = (cublasStatus_t (*) (int , int , const void* , int , void* , int )) dlsym(RTLD_NEXT, "cublasGetVector");
		tracer._kernel_map[(void *) lcublasGetVector] = std::string("cublasGetVector");
	}
	assert(lcublasGetVector);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetVector(n, elemSize, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetVector);
	}
	return res;
}

cublasStatus_t cublasGetVector_64(int64_t  n, int64_t  elemSize, const void*  x, int64_t  incx, void*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasGetVector_64) (int64_t , int64_t , const void* , int64_t , void* , int64_t );
	if (!lcublasGetVector_64) {
		lcublasGetVector_64 = (cublasStatus_t (*) (int64_t , int64_t , const void* , int64_t , void* , int64_t )) dlsym(RTLD_NEXT, "cublasGetVector_64");
		tracer._kernel_map[(void *) lcublasGetVector_64] = std::string("cublasGetVector_64");
	}
	assert(lcublasGetVector_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetVector_64(n, elemSize, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetVector_64);
	}
	return res;
}

cublasStatus_t cublasSetMatrix(int  rows, int  cols, int  elemSize, const void*  A, int  lda, void*  B, int  ldb)
{
	static cublasStatus_t (*lcublasSetMatrix) (int , int , int , const void* , int , void* , int );
	if (!lcublasSetMatrix) {
		lcublasSetMatrix = (cublasStatus_t (*) (int , int , int , const void* , int , void* , int )) dlsym(RTLD_NEXT, "cublasSetMatrix");
		tracer._kernel_map[(void *) lcublasSetMatrix] = std::string("cublasSetMatrix");
	}
	assert(lcublasSetMatrix);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetMatrix(rows, cols, elemSize, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetMatrix);
	}
	return res;
}

cublasStatus_t cublasSetMatrix_64(int64_t  rows, int64_t  cols, int64_t  elemSize, const void*  A, int64_t  lda, void*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasSetMatrix_64) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t );
	if (!lcublasSetMatrix_64) {
		lcublasSetMatrix_64 = (cublasStatus_t (*) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t )) dlsym(RTLD_NEXT, "cublasSetMatrix_64");
		tracer._kernel_map[(void *) lcublasSetMatrix_64] = std::string("cublasSetMatrix_64");
	}
	assert(lcublasSetMatrix_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetMatrix_64(rows, cols, elemSize, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetMatrix_64);
	}
	return res;
}

cublasStatus_t cublasGetMatrix(int  rows, int  cols, int  elemSize, const void*  A, int  lda, void*  B, int  ldb)
{
	static cublasStatus_t (*lcublasGetMatrix) (int , int , int , const void* , int , void* , int );
	if (!lcublasGetMatrix) {
		lcublasGetMatrix = (cublasStatus_t (*) (int , int , int , const void* , int , void* , int )) dlsym(RTLD_NEXT, "cublasGetMatrix");
		tracer._kernel_map[(void *) lcublasGetMatrix] = std::string("cublasGetMatrix");
	}
	assert(lcublasGetMatrix);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetMatrix(rows, cols, elemSize, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetMatrix);
	}
	return res;
}

cublasStatus_t cublasGetMatrix_64(int64_t  rows, int64_t  cols, int64_t  elemSize, const void*  A, int64_t  lda, void*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasGetMatrix_64) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t );
	if (!lcublasGetMatrix_64) {
		lcublasGetMatrix_64 = (cublasStatus_t (*) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t )) dlsym(RTLD_NEXT, "cublasGetMatrix_64");
		tracer._kernel_map[(void *) lcublasGetMatrix_64] = std::string("cublasGetMatrix_64");
	}
	assert(lcublasGetMatrix_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetMatrix_64(rows, cols, elemSize, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetMatrix_64);
	}
	return res;
}

cublasStatus_t cublasSetVectorAsync(int  n, int  elemSize, const void*  hostPtr, int  incx, void*  devicePtr, int  incy, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasSetVectorAsync) (int , int , const void* , int , void* , int , cudaStream_t );
	if (!lcublasSetVectorAsync) {
		lcublasSetVectorAsync = (cublasStatus_t (*) (int , int , const void* , int , void* , int , cudaStream_t )) dlsym(RTLD_NEXT, "cublasSetVectorAsync");
		tracer._kernel_map[(void *) lcublasSetVectorAsync] = std::string("cublasSetVectorAsync");
	}
	assert(lcublasSetVectorAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetVectorAsync(n, elemSize, hostPtr, incx, devicePtr, incy, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetVectorAsync);
	}
	return res;
}

cublasStatus_t cublasSetVectorAsync_64(int64_t  n, int64_t  elemSize, const void*  hostPtr, int64_t  incx, void*  devicePtr, int64_t  incy, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasSetVectorAsync_64) (int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t );
	if (!lcublasSetVectorAsync_64) {
		lcublasSetVectorAsync_64 = (cublasStatus_t (*) (int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasSetVectorAsync_64");
		tracer._kernel_map[(void *) lcublasSetVectorAsync_64] = std::string("cublasSetVectorAsync_64");
	}
	assert(lcublasSetVectorAsync_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetVectorAsync_64(n, elemSize, hostPtr, incx, devicePtr, incy, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetVectorAsync_64);
	}
	return res;
}

cublasStatus_t cublasGetVectorAsync(int  n, int  elemSize, const void*  devicePtr, int  incx, void*  hostPtr, int  incy, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasGetVectorAsync) (int , int , const void* , int , void* , int , cudaStream_t );
	if (!lcublasGetVectorAsync) {
		lcublasGetVectorAsync = (cublasStatus_t (*) (int , int , const void* , int , void* , int , cudaStream_t )) dlsym(RTLD_NEXT, "cublasGetVectorAsync");
		tracer._kernel_map[(void *) lcublasGetVectorAsync] = std::string("cublasGetVectorAsync");
	}
	assert(lcublasGetVectorAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetVectorAsync(n, elemSize, devicePtr, incx, hostPtr, incy, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetVectorAsync);
	}
	return res;
}

cublasStatus_t cublasGetVectorAsync_64(int64_t  n, int64_t  elemSize, const void*  devicePtr, int64_t  incx, void*  hostPtr, int64_t  incy, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasGetVectorAsync_64) (int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t );
	if (!lcublasGetVectorAsync_64) {
		lcublasGetVectorAsync_64 = (cublasStatus_t (*) (int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasGetVectorAsync_64");
		tracer._kernel_map[(void *) lcublasGetVectorAsync_64] = std::string("cublasGetVectorAsync_64");
	}
	assert(lcublasGetVectorAsync_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetVectorAsync_64(n, elemSize, devicePtr, incx, hostPtr, incy, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetVectorAsync_64);
	}
	return res;
}

cublasStatus_t cublasSetMatrixAsync(int  rows, int  cols, int  elemSize, const void*  A, int  lda, void*  B, int  ldb, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasSetMatrixAsync) (int , int , int , const void* , int , void* , int , cudaStream_t );
	if (!lcublasSetMatrixAsync) {
		lcublasSetMatrixAsync = (cublasStatus_t (*) (int , int , int , const void* , int , void* , int , cudaStream_t )) dlsym(RTLD_NEXT, "cublasSetMatrixAsync");
		tracer._kernel_map[(void *) lcublasSetMatrixAsync] = std::string("cublasSetMatrixAsync");
	}
	assert(lcublasSetMatrixAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetMatrixAsync(rows, cols, elemSize, A, lda, B, ldb, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetMatrixAsync);
	}
	return res;
}

cublasStatus_t cublasSetMatrixAsync_64(int64_t  rows, int64_t  cols, int64_t  elemSize, const void*  A, int64_t  lda, void*  B, int64_t  ldb, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasSetMatrixAsync_64) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t );
	if (!lcublasSetMatrixAsync_64) {
		lcublasSetMatrixAsync_64 = (cublasStatus_t (*) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasSetMatrixAsync_64");
		tracer._kernel_map[(void *) lcublasSetMatrixAsync_64] = std::string("cublasSetMatrixAsync_64");
	}
	assert(lcublasSetMatrixAsync_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSetMatrixAsync_64(rows, cols, elemSize, A, lda, B, ldb, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSetMatrixAsync_64);
	}
	return res;
}

cublasStatus_t cublasGetMatrixAsync(int  rows, int  cols, int  elemSize, const void*  A, int  lda, void*  B, int  ldb, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasGetMatrixAsync) (int , int , int , const void* , int , void* , int , cudaStream_t );
	if (!lcublasGetMatrixAsync) {
		lcublasGetMatrixAsync = (cublasStatus_t (*) (int , int , int , const void* , int , void* , int , cudaStream_t )) dlsym(RTLD_NEXT, "cublasGetMatrixAsync");
		tracer._kernel_map[(void *) lcublasGetMatrixAsync] = std::string("cublasGetMatrixAsync");
	}
	assert(lcublasGetMatrixAsync);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetMatrixAsync(rows, cols, elemSize, A, lda, B, ldb, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetMatrixAsync);
	}
	return res;
}

cublasStatus_t cublasGetMatrixAsync_64(int64_t  rows, int64_t  cols, int64_t  elemSize, const void*  A, int64_t  lda, void*  B, int64_t  ldb, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasGetMatrixAsync_64) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t );
	if (!lcublasGetMatrixAsync_64) {
		lcublasGetMatrixAsync_64 = (cublasStatus_t (*) (int64_t , int64_t , int64_t , const void* , int64_t , void* , int64_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasGetMatrixAsync_64");
		tracer._kernel_map[(void *) lcublasGetMatrixAsync_64] = std::string("cublasGetMatrixAsync_64");
	}
	assert(lcublasGetMatrixAsync_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGetMatrixAsync_64(rows, cols, elemSize, A, lda, B, ldb, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGetMatrixAsync_64);
	}
	return res;
}

void cublasXerbla(const char*  srName, int  info)
{
	static void (*lcublasXerbla) (const char* , int );
	if (!lcublasXerbla) {
		lcublasXerbla = (void (*) (const char* , int )) dlsym(RTLD_NEXT, "cublasXerbla");
		tracer._kernel_map[(void *) lcublasXerbla] = std::string("cublasXerbla");
	}
	assert(lcublasXerbla);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
		lcublasXerbla(srName, info);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasXerbla);
	}
}

cublasStatus_t cublasNrm2Ex(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasNrm2Ex) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType );
	if (!lcublasNrm2Ex) {
		lcublasNrm2Ex = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasNrm2Ex");
		tracer._kernel_map[(void *) lcublasNrm2Ex] = std::string("cublasNrm2Ex");
	}
	assert(lcublasNrm2Ex);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasNrm2Ex(handle, n, x, xType, incx, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasNrm2Ex);
	}
	return res;
}

cublasStatus_t cublasNrm2Ex_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasNrm2Ex_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType );
	if (!lcublasNrm2Ex_64) {
		lcublasNrm2Ex_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasNrm2Ex_64");
		tracer._kernel_map[(void *) lcublasNrm2Ex_64] = std::string("cublasNrm2Ex_64");
	}
	assert(lcublasNrm2Ex_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasNrm2Ex_64(handle, n, x, xType, incx, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasNrm2Ex_64);
	}
	return res;
}

cublasStatus_t cublasSnrm2_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, float*  result)
{
	static cublasStatus_t (*lcublasSnrm2_v2) (cublasHandle_t , int , const float* , int , float* );
	if (!lcublasSnrm2_v2) {
		lcublasSnrm2_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasSnrm2_v2");
		tracer._kernel_map[(void *) lcublasSnrm2_v2] = std::string("cublasSnrm2_v2");
	}
	assert(lcublasSnrm2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSnrm2_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSnrm2_v2);
	}
	return res;
}

cublasStatus_t cublasSnrm2_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, float*  result)
{
	static cublasStatus_t (*lcublasSnrm2_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , float* );
	if (!lcublasSnrm2_v2_64) {
		lcublasSnrm2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasSnrm2_v2_64");
		tracer._kernel_map[(void *) lcublasSnrm2_v2_64] = std::string("cublasSnrm2_v2_64");
	}
	assert(lcublasSnrm2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSnrm2_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSnrm2_v2_64);
	}
	return res;
}

cublasStatus_t cublasDnrm2_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, double*  result)
{
	static cublasStatus_t (*lcublasDnrm2_v2) (cublasHandle_t , int , const double* , int , double* );
	if (!lcublasDnrm2_v2) {
		lcublasDnrm2_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDnrm2_v2");
		tracer._kernel_map[(void *) lcublasDnrm2_v2] = std::string("cublasDnrm2_v2");
	}
	assert(lcublasDnrm2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDnrm2_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDnrm2_v2);
	}
	return res;
}

cublasStatus_t cublasDnrm2_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, double*  result)
{
	static cublasStatus_t (*lcublasDnrm2_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , double* );
	if (!lcublasDnrm2_v2_64) {
		lcublasDnrm2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDnrm2_v2_64");
		tracer._kernel_map[(void *) lcublasDnrm2_v2_64] = std::string("cublasDnrm2_v2_64");
	}
	assert(lcublasDnrm2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDnrm2_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDnrm2_v2_64);
	}
	return res;
}

cublasStatus_t cublasScnrm2_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, float*  result)
{
	static cublasStatus_t (*lcublasScnrm2_v2) (cublasHandle_t , int , const cuComplex* , int , float* );
	if (!lcublasScnrm2_v2) {
		lcublasScnrm2_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , float* )) dlsym(RTLD_NEXT, "cublasScnrm2_v2");
		tracer._kernel_map[(void *) lcublasScnrm2_v2] = std::string("cublasScnrm2_v2");
	}
	assert(lcublasScnrm2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScnrm2_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScnrm2_v2);
	}
	return res;
}

cublasStatus_t cublasScnrm2_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, float*  result)
{
	static cublasStatus_t (*lcublasScnrm2_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , float* );
	if (!lcublasScnrm2_v2_64) {
		lcublasScnrm2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasScnrm2_v2_64");
		tracer._kernel_map[(void *) lcublasScnrm2_v2_64] = std::string("cublasScnrm2_v2_64");
	}
	assert(lcublasScnrm2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScnrm2_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScnrm2_v2_64);
	}
	return res;
}

cublasStatus_t cublasDznrm2_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, double*  result)
{
	static cublasStatus_t (*lcublasDznrm2_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , double* );
	if (!lcublasDznrm2_v2) {
		lcublasDznrm2_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , double* )) dlsym(RTLD_NEXT, "cublasDznrm2_v2");
		tracer._kernel_map[(void *) lcublasDznrm2_v2] = std::string("cublasDznrm2_v2");
	}
	assert(lcublasDznrm2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDznrm2_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDznrm2_v2);
	}
	return res;
}

cublasStatus_t cublasDznrm2_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, double*  result)
{
	static cublasStatus_t (*lcublasDznrm2_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , double* );
	if (!lcublasDznrm2_v2_64) {
		lcublasDznrm2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDznrm2_v2_64");
		tracer._kernel_map[(void *) lcublasDznrm2_v2_64] = std::string("cublasDznrm2_v2_64");
	}
	assert(lcublasDznrm2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDznrm2_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDznrm2_v2_64);
	}
	return res;
}

cublasStatus_t cublasDotEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, const void*  y, cudaDataType  yType, int  incy, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasDotEx) (cublasHandle_t , int , const void* , cudaDataType , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType );
	if (!lcublasDotEx) {
		lcublasDotEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasDotEx");
		tracer._kernel_map[(void *) lcublasDotEx] = std::string("cublasDotEx");
	}
	assert(lcublasDotEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDotEx(handle, n, x, xType, incx, y, yType, incy, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDotEx);
	}
	return res;
}

cublasStatus_t cublasDotEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, const void*  y, cudaDataType  yType, int64_t  incy, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasDotEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType );
	if (!lcublasDotEx_64) {
		lcublasDotEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasDotEx_64");
		tracer._kernel_map[(void *) lcublasDotEx_64] = std::string("cublasDotEx_64");
	}
	assert(lcublasDotEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDotEx_64(handle, n, x, xType, incx, y, yType, incy, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDotEx_64);
	}
	return res;
}

cublasStatus_t cublasDotcEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, const void*  y, cudaDataType  yType, int  incy, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasDotcEx) (cublasHandle_t , int , const void* , cudaDataType , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType );
	if (!lcublasDotcEx) {
		lcublasDotcEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasDotcEx");
		tracer._kernel_map[(void *) lcublasDotcEx] = std::string("cublasDotcEx");
	}
	assert(lcublasDotcEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDotcEx(handle, n, x, xType, incx, y, yType, incy, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDotcEx);
	}
	return res;
}

cublasStatus_t cublasDotcEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, const void*  y, cudaDataType  yType, int64_t  incy, void*  result, cudaDataType  resultType, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasDotcEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType );
	if (!lcublasDotcEx_64) {
		lcublasDotcEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasDotcEx_64");
		tracer._kernel_map[(void *) lcublasDotcEx_64] = std::string("cublasDotcEx_64");
	}
	assert(lcublasDotcEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDotcEx_64(handle, n, x, xType, incx, y, yType, incy, result, resultType, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDotcEx_64);
	}
	return res;
}

cublasStatus_t cublasSdot_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, const float*  y, int  incy, float*  result)
{
	static cublasStatus_t (*lcublasSdot_v2) (cublasHandle_t , int , const float* , int , const float* , int , float* );
	if (!lcublasSdot_v2) {
		lcublasSdot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasSdot_v2");
		tracer._kernel_map[(void *) lcublasSdot_v2] = std::string("cublasSdot_v2");
	}
	assert(lcublasSdot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSdot_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSdot_v2);
	}
	return res;
}

cublasStatus_t cublasSdot_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, const float*  y, int64_t  incy, float*  result)
{
	static cublasStatus_t (*lcublasSdot_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , const float* , int64_t , float* );
	if (!lcublasSdot_v2_64) {
		lcublasSdot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , const float* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasSdot_v2_64");
		tracer._kernel_map[(void *) lcublasSdot_v2_64] = std::string("cublasSdot_v2_64");
	}
	assert(lcublasSdot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSdot_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSdot_v2_64);
	}
	return res;
}

cublasStatus_t cublasDdot_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, const double*  y, int  incy, double*  result)
{
	static cublasStatus_t (*lcublasDdot_v2) (cublasHandle_t , int , const double* , int , const double* , int , double* );
	if (!lcublasDdot_v2) {
		lcublasDdot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDdot_v2");
		tracer._kernel_map[(void *) lcublasDdot_v2] = std::string("cublasDdot_v2");
	}
	assert(lcublasDdot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDdot_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDdot_v2);
	}
	return res;
}

cublasStatus_t cublasDdot_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, const double*  y, int64_t  incy, double*  result)
{
	static cublasStatus_t (*lcublasDdot_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , const double* , int64_t , double* );
	if (!lcublasDdot_v2_64) {
		lcublasDdot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , const double* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDdot_v2_64");
		tracer._kernel_map[(void *) lcublasDdot_v2_64] = std::string("cublasDdot_v2_64");
	}
	assert(lcublasDdot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDdot_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDdot_v2_64);
	}
	return res;
}

cublasStatus_t cublasCdotu_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  result)
{
	static cublasStatus_t (*lcublasCdotu_v2) (cublasHandle_t , int , const cuComplex* , int , const cuComplex* , int , cuComplex* );
	if (!lcublasCdotu_v2) {
		lcublasCdotu_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , const cuComplex* , int , cuComplex* )) dlsym(RTLD_NEXT, "cublasCdotu_v2");
		tracer._kernel_map[(void *) lcublasCdotu_v2] = std::string("cublasCdotu_v2");
	}
	assert(lcublasCdotu_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdotu_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdotu_v2);
	}
	return res;
}

cublasStatus_t cublasCdotu_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  result)
{
	static cublasStatus_t (*lcublasCdotu_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* );
	if (!lcublasCdotu_v2_64) {
		lcublasCdotu_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* )) dlsym(RTLD_NEXT, "cublasCdotu_v2_64");
		tracer._kernel_map[(void *) lcublasCdotu_v2_64] = std::string("cublasCdotu_v2_64");
	}
	assert(lcublasCdotu_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdotu_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdotu_v2_64);
	}
	return res;
}

cublasStatus_t cublasCdotc_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  result)
{
	static cublasStatus_t (*lcublasCdotc_v2) (cublasHandle_t , int , const cuComplex* , int , const cuComplex* , int , cuComplex* );
	if (!lcublasCdotc_v2) {
		lcublasCdotc_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , const cuComplex* , int , cuComplex* )) dlsym(RTLD_NEXT, "cublasCdotc_v2");
		tracer._kernel_map[(void *) lcublasCdotc_v2] = std::string("cublasCdotc_v2");
	}
	assert(lcublasCdotc_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdotc_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdotc_v2);
	}
	return res;
}

cublasStatus_t cublasCdotc_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  result)
{
	static cublasStatus_t (*lcublasCdotc_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* );
	if (!lcublasCdotc_v2_64) {
		lcublasCdotc_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* )) dlsym(RTLD_NEXT, "cublasCdotc_v2_64");
		tracer._kernel_map[(void *) lcublasCdotc_v2_64] = std::string("cublasCdotc_v2_64");
	}
	assert(lcublasCdotc_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdotc_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdotc_v2_64);
	}
	return res;
}

cublasStatus_t cublasZdotu_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  result)
{
	static cublasStatus_t (*lcublasZdotu_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* );
	if (!lcublasZdotu_v2) {
		lcublasZdotu_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZdotu_v2");
		tracer._kernel_map[(void *) lcublasZdotu_v2] = std::string("cublasZdotu_v2");
	}
	assert(lcublasZdotu_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdotu_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdotu_v2);
	}
	return res;
}

cublasStatus_t cublasZdotu_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  result)
{
	static cublasStatus_t (*lcublasZdotu_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* );
	if (!lcublasZdotu_v2_64) {
		lcublasZdotu_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZdotu_v2_64");
		tracer._kernel_map[(void *) lcublasZdotu_v2_64] = std::string("cublasZdotu_v2_64");
	}
	assert(lcublasZdotu_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdotu_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdotu_v2_64);
	}
	return res;
}

cublasStatus_t cublasZdotc_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  result)
{
	static cublasStatus_t (*lcublasZdotc_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* );
	if (!lcublasZdotc_v2) {
		lcublasZdotc_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZdotc_v2");
		tracer._kernel_map[(void *) lcublasZdotc_v2] = std::string("cublasZdotc_v2");
	}
	assert(lcublasZdotc_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdotc_v2(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdotc_v2);
	}
	return res;
}

cublasStatus_t cublasZdotc_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  result)
{
	static cublasStatus_t (*lcublasZdotc_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* );
	if (!lcublasZdotc_v2_64) {
		lcublasZdotc_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZdotc_v2_64");
		tracer._kernel_map[(void *) lcublasZdotc_v2_64] = std::string("cublasZdotc_v2_64");
	}
	assert(lcublasZdotc_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdotc_v2_64(handle, n, x, incx, y, incy, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdotc_v2_64);
	}
	return res;
}

cublasStatus_t cublasScalEx(cublasHandle_t  handle, int  n, const void*  alpha, cudaDataType  alphaType, void*  x, cudaDataType  xType, int  incx, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasScalEx) (cublasHandle_t , int , const void* , cudaDataType , void* , cudaDataType , int , cudaDataType );
	if (!lcublasScalEx) {
		lcublasScalEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , void* , cudaDataType , int , cudaDataType )) dlsym(RTLD_NEXT, "cublasScalEx");
		tracer._kernel_map[(void *) lcublasScalEx] = std::string("cublasScalEx");
	}
	assert(lcublasScalEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScalEx(handle, n, alpha, alphaType, x, xType, incx, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScalEx);
	}
	return res;
}

cublasStatus_t cublasScalEx_64(cublasHandle_t  handle, int64_t  n, const void*  alpha, cudaDataType  alphaType, void*  x, cudaDataType  xType, int64_t  incx, cudaDataType  executionType)
{
	static cublasStatus_t (*lcublasScalEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , void* , cudaDataType , int64_t , cudaDataType );
	if (!lcublasScalEx_64) {
		lcublasScalEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , void* , cudaDataType , int64_t , cudaDataType )) dlsym(RTLD_NEXT, "cublasScalEx_64");
		tracer._kernel_map[(void *) lcublasScalEx_64] = std::string("cublasScalEx_64");
	}
	assert(lcublasScalEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScalEx_64(handle, n, alpha, alphaType, x, xType, incx, executionType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScalEx_64);
	}
	return res;
}

cublasStatus_t cublasSscal_v2(cublasHandle_t  handle, int  n, const float*  alpha, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasSscal_v2) (cublasHandle_t , int , const float* , float* , int );
	if (!lcublasSscal_v2) {
		lcublasSscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSscal_v2");
		tracer._kernel_map[(void *) lcublasSscal_v2] = std::string("cublasSscal_v2");
	}
	assert(lcublasSscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSscal_v2);
	}
	return res;
}

cublasStatus_t cublasSscal_v2_64(cublasHandle_t  handle, int64_t  n, const float*  alpha, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasSscal_v2_64) (cublasHandle_t , int64_t , const float* , float* , int64_t );
	if (!lcublasSscal_v2_64) {
		lcublasSscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSscal_v2_64");
		tracer._kernel_map[(void *) lcublasSscal_v2_64] = std::string("cublasSscal_v2_64");
	}
	assert(lcublasSscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasDscal_v2(cublasHandle_t  handle, int  n, const double*  alpha, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDscal_v2) (cublasHandle_t , int , const double* , double* , int );
	if (!lcublasDscal_v2) {
		lcublasDscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDscal_v2");
		tracer._kernel_map[(void *) lcublasDscal_v2] = std::string("cublasDscal_v2");
	}
	assert(lcublasDscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDscal_v2);
	}
	return res;
}

cublasStatus_t cublasDscal_v2_64(cublasHandle_t  handle, int64_t  n, const double*  alpha, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDscal_v2_64) (cublasHandle_t , int64_t , const double* , double* , int64_t );
	if (!lcublasDscal_v2_64) {
		lcublasDscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDscal_v2_64");
		tracer._kernel_map[(void *) lcublasDscal_v2_64] = std::string("cublasDscal_v2_64");
	}
	assert(lcublasDscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasCscal_v2(cublasHandle_t  handle, int  n, const cuComplex*  alpha, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCscal_v2) (cublasHandle_t , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCscal_v2) {
		lcublasCscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCscal_v2");
		tracer._kernel_map[(void *) lcublasCscal_v2] = std::string("cublasCscal_v2");
	}
	assert(lcublasCscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCscal_v2);
	}
	return res;
}

cublasStatus_t cublasCscal_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  alpha, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCscal_v2_64) (cublasHandle_t , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCscal_v2_64) {
		lcublasCscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCscal_v2_64");
		tracer._kernel_map[(void *) lcublasCscal_v2_64] = std::string("cublasCscal_v2_64");
	}
	assert(lcublasCscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsscal_v2(cublasHandle_t  handle, int  n, const float*  alpha, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCsscal_v2) (cublasHandle_t , int , const float* , cuComplex* , int );
	if (!lcublasCsscal_v2) {
		lcublasCsscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsscal_v2");
		tracer._kernel_map[(void *) lcublasCsscal_v2] = std::string("cublasCsscal_v2");
	}
	assert(lcublasCsscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsscal_v2);
	}
	return res;
}

cublasStatus_t cublasCsscal_v2_64(cublasHandle_t  handle, int64_t  n, const float*  alpha, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCsscal_v2_64) (cublasHandle_t , int64_t , const float* , cuComplex* , int64_t );
	if (!lcublasCsscal_v2_64) {
		lcublasCsscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsscal_v2_64");
		tracer._kernel_map[(void *) lcublasCsscal_v2_64] = std::string("cublasCsscal_v2_64");
	}
	assert(lcublasCsscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasZscal_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  alpha, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZscal_v2) (cublasHandle_t , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZscal_v2) {
		lcublasZscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZscal_v2");
		tracer._kernel_map[(void *) lcublasZscal_v2] = std::string("cublasZscal_v2");
	}
	assert(lcublasZscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZscal_v2);
	}
	return res;
}

cublasStatus_t cublasZscal_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  alpha, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZscal_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZscal_v2_64) {
		lcublasZscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZscal_v2_64");
		tracer._kernel_map[(void *) lcublasZscal_v2_64] = std::string("cublasZscal_v2_64");
	}
	assert(lcublasZscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasZdscal_v2(cublasHandle_t  handle, int  n, const double*  alpha, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZdscal_v2) (cublasHandle_t , int , const double* , cuDoubleComplex* , int );
	if (!lcublasZdscal_v2) {
		lcublasZdscal_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZdscal_v2");
		tracer._kernel_map[(void *) lcublasZdscal_v2] = std::string("cublasZdscal_v2");
	}
	assert(lcublasZdscal_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdscal_v2(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdscal_v2);
	}
	return res;
}

cublasStatus_t cublasZdscal_v2_64(cublasHandle_t  handle, int64_t  n, const double*  alpha, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZdscal_v2_64) (cublasHandle_t , int64_t , const double* , cuDoubleComplex* , int64_t );
	if (!lcublasZdscal_v2_64) {
		lcublasZdscal_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZdscal_v2_64");
		tracer._kernel_map[(void *) lcublasZdscal_v2_64] = std::string("cublasZdscal_v2_64");
	}
	assert(lcublasZdscal_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdscal_v2_64(handle, n, alpha, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdscal_v2_64);
	}
	return res;
}

cublasStatus_t cublasAxpyEx(cublasHandle_t  handle, int  n, const void*  alpha, cudaDataType  alphaType, const void*  x, cudaDataType  xType, int  incx, void*  y, cudaDataType  yType, int  incy, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasAxpyEx) (cublasHandle_t , int , const void* , cudaDataType , const void* , cudaDataType , int , void* , cudaDataType , int , cudaDataType );
	if (!lcublasAxpyEx) {
		lcublasAxpyEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , const void* , cudaDataType , int , void* , cudaDataType , int , cudaDataType )) dlsym(RTLD_NEXT, "cublasAxpyEx");
		tracer._kernel_map[(void *) lcublasAxpyEx] = std::string("cublasAxpyEx");
	}
	assert(lcublasAxpyEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasAxpyEx(handle, n, alpha, alphaType, x, xType, incx, y, yType, incy, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasAxpyEx);
	}
	return res;
}

cublasStatus_t cublasAxpyEx_64(cublasHandle_t  handle, int64_t  n, const void*  alpha, cudaDataType  alphaType, const void*  x, cudaDataType  xType, int64_t  incx, void*  y, cudaDataType  yType, int64_t  incy, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasAxpyEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , const void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , cudaDataType );
	if (!lcublasAxpyEx_64) {
		lcublasAxpyEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , const void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , cudaDataType )) dlsym(RTLD_NEXT, "cublasAxpyEx_64");
		tracer._kernel_map[(void *) lcublasAxpyEx_64] = std::string("cublasAxpyEx_64");
	}
	assert(lcublasAxpyEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasAxpyEx_64(handle, n, alpha, alphaType, x, xType, incx, y, yType, incy, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasAxpyEx_64);
	}
	return res;
}

cublasStatus_t cublasSaxpy_v2(cublasHandle_t  handle, int  n, const float*  alpha, const float*  x, int  incx, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSaxpy_v2) (cublasHandle_t , int , const float* , const float* , int , float* , int );
	if (!lcublasSaxpy_v2) {
		lcublasSaxpy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSaxpy_v2");
		tracer._kernel_map[(void *) lcublasSaxpy_v2] = std::string("cublasSaxpy_v2");
	}
	assert(lcublasSaxpy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSaxpy_v2(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSaxpy_v2);
	}
	return res;
}

cublasStatus_t cublasSaxpy_v2_64(cublasHandle_t  handle, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSaxpy_v2_64) (cublasHandle_t , int64_t , const float* , const float* , int64_t , float* , int64_t );
	if (!lcublasSaxpy_v2_64) {
		lcublasSaxpy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSaxpy_v2_64");
		tracer._kernel_map[(void *) lcublasSaxpy_v2_64] = std::string("cublasSaxpy_v2_64");
	}
	assert(lcublasSaxpy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSaxpy_v2_64(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSaxpy_v2_64);
	}
	return res;
}

cublasStatus_t cublasDaxpy_v2(cublasHandle_t  handle, int  n, const double*  alpha, const double*  x, int  incx, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDaxpy_v2) (cublasHandle_t , int , const double* , const double* , int , double* , int );
	if (!lcublasDaxpy_v2) {
		lcublasDaxpy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDaxpy_v2");
		tracer._kernel_map[(void *) lcublasDaxpy_v2] = std::string("cublasDaxpy_v2");
	}
	assert(lcublasDaxpy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDaxpy_v2(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDaxpy_v2);
	}
	return res;
}

cublasStatus_t cublasDaxpy_v2_64(cublasHandle_t  handle, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDaxpy_v2_64) (cublasHandle_t , int64_t , const double* , const double* , int64_t , double* , int64_t );
	if (!lcublasDaxpy_v2_64) {
		lcublasDaxpy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDaxpy_v2_64");
		tracer._kernel_map[(void *) lcublasDaxpy_v2_64] = std::string("cublasDaxpy_v2_64");
	}
	assert(lcublasDaxpy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDaxpy_v2_64(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDaxpy_v2_64);
	}
	return res;
}

cublasStatus_t cublasCaxpy_v2(cublasHandle_t  handle, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCaxpy_v2) (cublasHandle_t , int , const cuComplex* , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCaxpy_v2) {
		lcublasCaxpy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCaxpy_v2");
		tracer._kernel_map[(void *) lcublasCaxpy_v2] = std::string("cublasCaxpy_v2");
	}
	assert(lcublasCaxpy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCaxpy_v2(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCaxpy_v2);
	}
	return res;
}

cublasStatus_t cublasCaxpy_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCaxpy_v2_64) (cublasHandle_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCaxpy_v2_64) {
		lcublasCaxpy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCaxpy_v2_64");
		tracer._kernel_map[(void *) lcublasCaxpy_v2_64] = std::string("cublasCaxpy_v2_64");
	}
	assert(lcublasCaxpy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCaxpy_v2_64(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCaxpy_v2_64);
	}
	return res;
}

cublasStatus_t cublasZaxpy_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZaxpy_v2) (cublasHandle_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZaxpy_v2) {
		lcublasZaxpy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZaxpy_v2");
		tracer._kernel_map[(void *) lcublasZaxpy_v2] = std::string("cublasZaxpy_v2");
	}
	assert(lcublasZaxpy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZaxpy_v2(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZaxpy_v2);
	}
	return res;
}

cublasStatus_t cublasZaxpy_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZaxpy_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZaxpy_v2_64) {
		lcublasZaxpy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZaxpy_v2_64");
		tracer._kernel_map[(void *) lcublasZaxpy_v2_64] = std::string("cublasZaxpy_v2_64");
	}
	assert(lcublasZaxpy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZaxpy_v2_64(handle, n, alpha, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZaxpy_v2_64);
	}
	return res;
}

cublasStatus_t cublasCopyEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, void*  y, cudaDataType  yType, int  incy)
{
	static cublasStatus_t (*lcublasCopyEx) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , int );
	if (!lcublasCopyEx) {
		lcublasCopyEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCopyEx");
		tracer._kernel_map[(void *) lcublasCopyEx] = std::string("cublasCopyEx");
	}
	assert(lcublasCopyEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCopyEx(handle, n, x, xType, incx, y, yType, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCopyEx);
	}
	return res;
}

cublasStatus_t cublasCopyEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, void*  y, cudaDataType  yType, int64_t  incy)
{
	static cublasStatus_t (*lcublasCopyEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , int64_t );
	if (!lcublasCopyEx_64) {
		lcublasCopyEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCopyEx_64");
		tracer._kernel_map[(void *) lcublasCopyEx_64] = std::string("cublasCopyEx_64");
	}
	assert(lcublasCopyEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCopyEx_64(handle, n, x, xType, incx, y, yType, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCopyEx_64);
	}
	return res;
}

cublasStatus_t cublasScopy_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasScopy_v2) (cublasHandle_t , int , const float* , int , float* , int );
	if (!lcublasScopy_v2) {
		lcublasScopy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasScopy_v2");
		tracer._kernel_map[(void *) lcublasScopy_v2] = std::string("cublasScopy_v2");
	}
	assert(lcublasScopy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScopy_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScopy_v2);
	}
	return res;
}

cublasStatus_t cublasScopy_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasScopy_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasScopy_v2_64) {
		lcublasScopy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasScopy_v2_64");
		tracer._kernel_map[(void *) lcublasScopy_v2_64] = std::string("cublasScopy_v2_64");
	}
	assert(lcublasScopy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScopy_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScopy_v2_64);
	}
	return res;
}

cublasStatus_t cublasDcopy_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDcopy_v2) (cublasHandle_t , int , const double* , int , double* , int );
	if (!lcublasDcopy_v2) {
		lcublasDcopy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDcopy_v2");
		tracer._kernel_map[(void *) lcublasDcopy_v2] = std::string("cublasDcopy_v2");
	}
	assert(lcublasDcopy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDcopy_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDcopy_v2);
	}
	return res;
}

cublasStatus_t cublasDcopy_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDcopy_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDcopy_v2_64) {
		lcublasDcopy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDcopy_v2_64");
		tracer._kernel_map[(void *) lcublasDcopy_v2_64] = std::string("cublasDcopy_v2_64");
	}
	assert(lcublasDcopy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDcopy_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDcopy_v2_64);
	}
	return res;
}

cublasStatus_t cublasCcopy_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCcopy_v2) (cublasHandle_t , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCcopy_v2) {
		lcublasCcopy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCcopy_v2");
		tracer._kernel_map[(void *) lcublasCcopy_v2] = std::string("cublasCcopy_v2");
	}
	assert(lcublasCcopy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCcopy_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCcopy_v2);
	}
	return res;
}

cublasStatus_t cublasCcopy_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCcopy_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCcopy_v2_64) {
		lcublasCcopy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCcopy_v2_64");
		tracer._kernel_map[(void *) lcublasCcopy_v2_64] = std::string("cublasCcopy_v2_64");
	}
	assert(lcublasCcopy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCcopy_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCcopy_v2_64);
	}
	return res;
}

cublasStatus_t cublasZcopy_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZcopy_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZcopy_v2) {
		lcublasZcopy_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZcopy_v2");
		tracer._kernel_map[(void *) lcublasZcopy_v2] = std::string("cublasZcopy_v2");
	}
	assert(lcublasZcopy_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZcopy_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZcopy_v2);
	}
	return res;
}

cublasStatus_t cublasZcopy_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZcopy_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZcopy_v2_64) {
		lcublasZcopy_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZcopy_v2_64");
		tracer._kernel_map[(void *) lcublasZcopy_v2_64] = std::string("cublasZcopy_v2_64");
	}
	assert(lcublasZcopy_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZcopy_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZcopy_v2_64);
	}
	return res;
}

cublasStatus_t cublasSswap_v2(cublasHandle_t  handle, int  n, float*  x, int  incx, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSswap_v2) (cublasHandle_t , int , float* , int , float* , int );
	if (!lcublasSswap_v2) {
		lcublasSswap_v2 = (cublasStatus_t (*) (cublasHandle_t , int , float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSswap_v2");
		tracer._kernel_map[(void *) lcublasSswap_v2] = std::string("cublasSswap_v2");
	}
	assert(lcublasSswap_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSswap_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSswap_v2);
	}
	return res;
}

cublasStatus_t cublasSswap_v2_64(cublasHandle_t  handle, int64_t  n, float*  x, int64_t  incx, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSswap_v2_64) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t );
	if (!lcublasSswap_v2_64) {
		lcublasSswap_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSswap_v2_64");
		tracer._kernel_map[(void *) lcublasSswap_v2_64] = std::string("cublasSswap_v2_64");
	}
	assert(lcublasSswap_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSswap_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSswap_v2_64);
	}
	return res;
}

cublasStatus_t cublasDswap_v2(cublasHandle_t  handle, int  n, double*  x, int  incx, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDswap_v2) (cublasHandle_t , int , double* , int , double* , int );
	if (!lcublasDswap_v2) {
		lcublasDswap_v2 = (cublasStatus_t (*) (cublasHandle_t , int , double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDswap_v2");
		tracer._kernel_map[(void *) lcublasDswap_v2] = std::string("cublasDswap_v2");
	}
	assert(lcublasDswap_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDswap_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDswap_v2);
	}
	return res;
}

cublasStatus_t cublasDswap_v2_64(cublasHandle_t  handle, int64_t  n, double*  x, int64_t  incx, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDswap_v2_64) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t );
	if (!lcublasDswap_v2_64) {
		lcublasDswap_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDswap_v2_64");
		tracer._kernel_map[(void *) lcublasDswap_v2_64] = std::string("cublasDswap_v2_64");
	}
	assert(lcublasDswap_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDswap_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDswap_v2_64);
	}
	return res;
}

cublasStatus_t cublasCswap_v2(cublasHandle_t  handle, int  n, cuComplex*  x, int  incx, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCswap_v2) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int );
	if (!lcublasCswap_v2) {
		lcublasCswap_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCswap_v2");
		tracer._kernel_map[(void *) lcublasCswap_v2] = std::string("cublasCswap_v2");
	}
	assert(lcublasCswap_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCswap_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCswap_v2);
	}
	return res;
}

cublasStatus_t cublasCswap_v2_64(cublasHandle_t  handle, int64_t  n, cuComplex*  x, int64_t  incx, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCswap_v2_64) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCswap_v2_64) {
		lcublasCswap_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCswap_v2_64");
		tracer._kernel_map[(void *) lcublasCswap_v2_64] = std::string("cublasCswap_v2_64");
	}
	assert(lcublasCswap_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCswap_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCswap_v2_64);
	}
	return res;
}

cublasStatus_t cublasZswap_v2(cublasHandle_t  handle, int  n, cuDoubleComplex*  x, int  incx, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZswap_v2) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZswap_v2) {
		lcublasZswap_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZswap_v2");
		tracer._kernel_map[(void *) lcublasZswap_v2] = std::string("cublasZswap_v2");
	}
	assert(lcublasZswap_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZswap_v2(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZswap_v2);
	}
	return res;
}

cublasStatus_t cublasZswap_v2_64(cublasHandle_t  handle, int64_t  n, cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZswap_v2_64) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZswap_v2_64) {
		lcublasZswap_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZswap_v2_64");
		tracer._kernel_map[(void *) lcublasZswap_v2_64] = std::string("cublasZswap_v2_64");
	}
	assert(lcublasZswap_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZswap_v2_64(handle, n, x, incx, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZswap_v2_64);
	}
	return res;
}

cublasStatus_t cublasSwapEx(cublasHandle_t  handle, int  n, void*  x, cudaDataType  xType, int  incx, void*  y, cudaDataType  yType, int  incy)
{
	static cublasStatus_t (*lcublasSwapEx) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int );
	if (!lcublasSwapEx) {
		lcublasSwapEx = (cublasStatus_t (*) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasSwapEx");
		tracer._kernel_map[(void *) lcublasSwapEx] = std::string("cublasSwapEx");
	}
	assert(lcublasSwapEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSwapEx(handle, n, x, xType, incx, y, yType, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSwapEx);
	}
	return res;
}

cublasStatus_t cublasSwapEx_64(cublasHandle_t  handle, int64_t  n, void*  x, cudaDataType  xType, int64_t  incx, void*  y, cudaDataType  yType, int64_t  incy)
{
	static cublasStatus_t (*lcublasSwapEx_64) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t );
	if (!lcublasSwapEx_64) {
		lcublasSwapEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasSwapEx_64");
		tracer._kernel_map[(void *) lcublasSwapEx_64] = std::string("cublasSwapEx_64");
	}
	assert(lcublasSwapEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSwapEx_64(handle, n, x, xType, incx, y, yType, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSwapEx_64);
	}
	return res;
}

cublasStatus_t cublasIsamax_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIsamax_v2) (cublasHandle_t , int , const float* , int , int* );
	if (!lcublasIsamax_v2) {
		lcublasIsamax_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , int* )) dlsym(RTLD_NEXT, "cublasIsamax_v2");
		tracer._kernel_map[(void *) lcublasIsamax_v2] = std::string("cublasIsamax_v2");
	}
	assert(lcublasIsamax_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIsamax_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIsamax_v2);
	}
	return res;
}

cublasStatus_t cublasIsamax_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIsamax_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , int64_t* );
	if (!lcublasIsamax_v2_64) {
		lcublasIsamax_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIsamax_v2_64");
		tracer._kernel_map[(void *) lcublasIsamax_v2_64] = std::string("cublasIsamax_v2_64");
	}
	assert(lcublasIsamax_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIsamax_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIsamax_v2_64);
	}
	return res;
}

cublasStatus_t cublasIdamax_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIdamax_v2) (cublasHandle_t , int , const double* , int , int* );
	if (!lcublasIdamax_v2) {
		lcublasIdamax_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , int* )) dlsym(RTLD_NEXT, "cublasIdamax_v2");
		tracer._kernel_map[(void *) lcublasIdamax_v2] = std::string("cublasIdamax_v2");
	}
	assert(lcublasIdamax_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIdamax_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIdamax_v2);
	}
	return res;
}

cublasStatus_t cublasIdamax_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIdamax_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , int64_t* );
	if (!lcublasIdamax_v2_64) {
		lcublasIdamax_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIdamax_v2_64");
		tracer._kernel_map[(void *) lcublasIdamax_v2_64] = std::string("cublasIdamax_v2_64");
	}
	assert(lcublasIdamax_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIdamax_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIdamax_v2_64);
	}
	return res;
}

cublasStatus_t cublasIcamax_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIcamax_v2) (cublasHandle_t , int , const cuComplex* , int , int* );
	if (!lcublasIcamax_v2) {
		lcublasIcamax_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , int* )) dlsym(RTLD_NEXT, "cublasIcamax_v2");
		tracer._kernel_map[(void *) lcublasIcamax_v2] = std::string("cublasIcamax_v2");
	}
	assert(lcublasIcamax_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIcamax_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIcamax_v2);
	}
	return res;
}

cublasStatus_t cublasIcamax_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIcamax_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , int64_t* );
	if (!lcublasIcamax_v2_64) {
		lcublasIcamax_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIcamax_v2_64");
		tracer._kernel_map[(void *) lcublasIcamax_v2_64] = std::string("cublasIcamax_v2_64");
	}
	assert(lcublasIcamax_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIcamax_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIcamax_v2_64);
	}
	return res;
}

cublasStatus_t cublasIzamax_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIzamax_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , int* );
	if (!lcublasIzamax_v2) {
		lcublasIzamax_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , int* )) dlsym(RTLD_NEXT, "cublasIzamax_v2");
		tracer._kernel_map[(void *) lcublasIzamax_v2] = std::string("cublasIzamax_v2");
	}
	assert(lcublasIzamax_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIzamax_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIzamax_v2);
	}
	return res;
}

cublasStatus_t cublasIzamax_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIzamax_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , int64_t* );
	if (!lcublasIzamax_v2_64) {
		lcublasIzamax_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIzamax_v2_64");
		tracer._kernel_map[(void *) lcublasIzamax_v2_64] = std::string("cublasIzamax_v2_64");
	}
	assert(lcublasIzamax_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIzamax_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIzamax_v2_64);
	}
	return res;
}

cublasStatus_t cublasIamaxEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIamaxEx) (cublasHandle_t , int , const void* , cudaDataType , int , int* );
	if (!lcublasIamaxEx) {
		lcublasIamaxEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , int* )) dlsym(RTLD_NEXT, "cublasIamaxEx");
		tracer._kernel_map[(void *) lcublasIamaxEx] = std::string("cublasIamaxEx");
	}
	assert(lcublasIamaxEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIamaxEx(handle, n, x, xType, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIamaxEx);
	}
	return res;
}

cublasStatus_t cublasIamaxEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIamaxEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , int64_t* );
	if (!lcublasIamaxEx_64) {
		lcublasIamaxEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIamaxEx_64");
		tracer._kernel_map[(void *) lcublasIamaxEx_64] = std::string("cublasIamaxEx_64");
	}
	assert(lcublasIamaxEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIamaxEx_64(handle, n, x, xType, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIamaxEx_64);
	}
	return res;
}

cublasStatus_t cublasIsamin_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIsamin_v2) (cublasHandle_t , int , const float* , int , int* );
	if (!lcublasIsamin_v2) {
		lcublasIsamin_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , int* )) dlsym(RTLD_NEXT, "cublasIsamin_v2");
		tracer._kernel_map[(void *) lcublasIsamin_v2] = std::string("cublasIsamin_v2");
	}
	assert(lcublasIsamin_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIsamin_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIsamin_v2);
	}
	return res;
}

cublasStatus_t cublasIsamin_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIsamin_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , int64_t* );
	if (!lcublasIsamin_v2_64) {
		lcublasIsamin_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIsamin_v2_64");
		tracer._kernel_map[(void *) lcublasIsamin_v2_64] = std::string("cublasIsamin_v2_64");
	}
	assert(lcublasIsamin_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIsamin_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIsamin_v2_64);
	}
	return res;
}

cublasStatus_t cublasIdamin_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIdamin_v2) (cublasHandle_t , int , const double* , int , int* );
	if (!lcublasIdamin_v2) {
		lcublasIdamin_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , int* )) dlsym(RTLD_NEXT, "cublasIdamin_v2");
		tracer._kernel_map[(void *) lcublasIdamin_v2] = std::string("cublasIdamin_v2");
	}
	assert(lcublasIdamin_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIdamin_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIdamin_v2);
	}
	return res;
}

cublasStatus_t cublasIdamin_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIdamin_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , int64_t* );
	if (!lcublasIdamin_v2_64) {
		lcublasIdamin_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIdamin_v2_64");
		tracer._kernel_map[(void *) lcublasIdamin_v2_64] = std::string("cublasIdamin_v2_64");
	}
	assert(lcublasIdamin_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIdamin_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIdamin_v2_64);
	}
	return res;
}

cublasStatus_t cublasIcamin_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIcamin_v2) (cublasHandle_t , int , const cuComplex* , int , int* );
	if (!lcublasIcamin_v2) {
		lcublasIcamin_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , int* )) dlsym(RTLD_NEXT, "cublasIcamin_v2");
		tracer._kernel_map[(void *) lcublasIcamin_v2] = std::string("cublasIcamin_v2");
	}
	assert(lcublasIcamin_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIcamin_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIcamin_v2);
	}
	return res;
}

cublasStatus_t cublasIcamin_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIcamin_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , int64_t* );
	if (!lcublasIcamin_v2_64) {
		lcublasIcamin_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIcamin_v2_64");
		tracer._kernel_map[(void *) lcublasIcamin_v2_64] = std::string("cublasIcamin_v2_64");
	}
	assert(lcublasIcamin_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIcamin_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIcamin_v2_64);
	}
	return res;
}

cublasStatus_t cublasIzamin_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIzamin_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , int* );
	if (!lcublasIzamin_v2) {
		lcublasIzamin_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , int* )) dlsym(RTLD_NEXT, "cublasIzamin_v2");
		tracer._kernel_map[(void *) lcublasIzamin_v2] = std::string("cublasIzamin_v2");
	}
	assert(lcublasIzamin_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIzamin_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIzamin_v2);
	}
	return res;
}

cublasStatus_t cublasIzamin_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIzamin_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , int64_t* );
	if (!lcublasIzamin_v2_64) {
		lcublasIzamin_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIzamin_v2_64");
		tracer._kernel_map[(void *) lcublasIzamin_v2_64] = std::string("cublasIzamin_v2_64");
	}
	assert(lcublasIzamin_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIzamin_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIzamin_v2_64);
	}
	return res;
}

cublasStatus_t cublasIaminEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, int*  result)
{
	static cublasStatus_t (*lcublasIaminEx) (cublasHandle_t , int , const void* , cudaDataType , int , int* );
	if (!lcublasIaminEx) {
		lcublasIaminEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , int* )) dlsym(RTLD_NEXT, "cublasIaminEx");
		tracer._kernel_map[(void *) lcublasIaminEx] = std::string("cublasIaminEx");
	}
	assert(lcublasIaminEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIaminEx(handle, n, x, xType, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIaminEx);
	}
	return res;
}

cublasStatus_t cublasIaminEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, int64_t*  result)
{
	static cublasStatus_t (*lcublasIaminEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , int64_t* );
	if (!lcublasIaminEx_64) {
		lcublasIaminEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , int64_t* )) dlsym(RTLD_NEXT, "cublasIaminEx_64");
		tracer._kernel_map[(void *) lcublasIaminEx_64] = std::string("cublasIaminEx_64");
	}
	assert(lcublasIaminEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasIaminEx_64(handle, n, x, xType, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasIaminEx_64);
	}
	return res;
}

cublasStatus_t cublasAsumEx(cublasHandle_t  handle, int  n, const void*  x, cudaDataType  xType, int  incx, void*  result, cudaDataType  resultType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasAsumEx) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType );
	if (!lcublasAsumEx) {
		lcublasAsumEx = (cublasStatus_t (*) (cublasHandle_t , int , const void* , cudaDataType , int , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasAsumEx");
		tracer._kernel_map[(void *) lcublasAsumEx] = std::string("cublasAsumEx");
	}
	assert(lcublasAsumEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasAsumEx(handle, n, x, xType, incx, result, resultType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasAsumEx);
	}
	return res;
}

cublasStatus_t cublasAsumEx_64(cublasHandle_t  handle, int64_t  n, const void*  x, cudaDataType  xType, int64_t  incx, void*  result, cudaDataType  resultType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasAsumEx_64) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType );
	if (!lcublasAsumEx_64) {
		lcublasAsumEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const void* , cudaDataType , int64_t , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasAsumEx_64");
		tracer._kernel_map[(void *) lcublasAsumEx_64] = std::string("cublasAsumEx_64");
	}
	assert(lcublasAsumEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasAsumEx_64(handle, n, x, xType, incx, result, resultType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasAsumEx_64);
	}
	return res;
}

cublasStatus_t cublasSasum_v2(cublasHandle_t  handle, int  n, const float*  x, int  incx, float*  result)
{
	static cublasStatus_t (*lcublasSasum_v2) (cublasHandle_t , int , const float* , int , float* );
	if (!lcublasSasum_v2) {
		lcublasSasum_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasSasum_v2");
		tracer._kernel_map[(void *) lcublasSasum_v2] = std::string("cublasSasum_v2");
	}
	assert(lcublasSasum_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSasum_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSasum_v2);
	}
	return res;
}

cublasStatus_t cublasSasum_v2_64(cublasHandle_t  handle, int64_t  n, const float*  x, int64_t  incx, float*  result)
{
	static cublasStatus_t (*lcublasSasum_v2_64) (cublasHandle_t , int64_t , const float* , int64_t , float* );
	if (!lcublasSasum_v2_64) {
		lcublasSasum_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const float* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasSasum_v2_64");
		tracer._kernel_map[(void *) lcublasSasum_v2_64] = std::string("cublasSasum_v2_64");
	}
	assert(lcublasSasum_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSasum_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSasum_v2_64);
	}
	return res;
}

cublasStatus_t cublasDasum_v2(cublasHandle_t  handle, int  n, const double*  x, int  incx, double*  result)
{
	static cublasStatus_t (*lcublasDasum_v2) (cublasHandle_t , int , const double* , int , double* );
	if (!lcublasDasum_v2) {
		lcublasDasum_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDasum_v2");
		tracer._kernel_map[(void *) lcublasDasum_v2] = std::string("cublasDasum_v2");
	}
	assert(lcublasDasum_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDasum_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDasum_v2);
	}
	return res;
}

cublasStatus_t cublasDasum_v2_64(cublasHandle_t  handle, int64_t  n, const double*  x, int64_t  incx, double*  result)
{
	static cublasStatus_t (*lcublasDasum_v2_64) (cublasHandle_t , int64_t , const double* , int64_t , double* );
	if (!lcublasDasum_v2_64) {
		lcublasDasum_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const double* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDasum_v2_64");
		tracer._kernel_map[(void *) lcublasDasum_v2_64] = std::string("cublasDasum_v2_64");
	}
	assert(lcublasDasum_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDasum_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDasum_v2_64);
	}
	return res;
}

cublasStatus_t cublasScasum_v2(cublasHandle_t  handle, int  n, const cuComplex*  x, int  incx, float*  result)
{
	static cublasStatus_t (*lcublasScasum_v2) (cublasHandle_t , int , const cuComplex* , int , float* );
	if (!lcublasScasum_v2) {
		lcublasScasum_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* , int , float* )) dlsym(RTLD_NEXT, "cublasScasum_v2");
		tracer._kernel_map[(void *) lcublasScasum_v2] = std::string("cublasScasum_v2");
	}
	assert(lcublasScasum_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScasum_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScasum_v2);
	}
	return res;
}

cublasStatus_t cublasScasum_v2_64(cublasHandle_t  handle, int64_t  n, const cuComplex*  x, int64_t  incx, float*  result)
{
	static cublasStatus_t (*lcublasScasum_v2_64) (cublasHandle_t , int64_t , const cuComplex* , int64_t , float* );
	if (!lcublasScasum_v2_64) {
		lcublasScasum_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuComplex* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasScasum_v2_64");
		tracer._kernel_map[(void *) lcublasScasum_v2_64] = std::string("cublasScasum_v2_64");
	}
	assert(lcublasScasum_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasScasum_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasScasum_v2_64);
	}
	return res;
}

cublasStatus_t cublasDzasum_v2(cublasHandle_t  handle, int  n, const cuDoubleComplex*  x, int  incx, double*  result)
{
	static cublasStatus_t (*lcublasDzasum_v2) (cublasHandle_t , int , const cuDoubleComplex* , int , double* );
	if (!lcublasDzasum_v2) {
		lcublasDzasum_v2 = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* , int , double* )) dlsym(RTLD_NEXT, "cublasDzasum_v2");
		tracer._kernel_map[(void *) lcublasDzasum_v2] = std::string("cublasDzasum_v2");
	}
	assert(lcublasDzasum_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDzasum_v2(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDzasum_v2);
	}
	return res;
}

cublasStatus_t cublasDzasum_v2_64(cublasHandle_t  handle, int64_t  n, const cuDoubleComplex*  x, int64_t  incx, double*  result)
{
	static cublasStatus_t (*lcublasDzasum_v2_64) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , double* );
	if (!lcublasDzasum_v2_64) {
		lcublasDzasum_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , const cuDoubleComplex* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDzasum_v2_64");
		tracer._kernel_map[(void *) lcublasDzasum_v2_64] = std::string("cublasDzasum_v2_64");
	}
	assert(lcublasDzasum_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDzasum_v2_64(handle, n, x, incx, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDzasum_v2_64);
	}
	return res;
}

cublasStatus_t cublasSrot_v2(cublasHandle_t  handle, int  n, float*  x, int  incx, float*  y, int  incy, const float*  c, const float*  s)
{
	static cublasStatus_t (*lcublasSrot_v2) (cublasHandle_t , int , float* , int , float* , int , const float* , const float* );
	if (!lcublasSrot_v2) {
		lcublasSrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , float* , int , float* , int , const float* , const float* )) dlsym(RTLD_NEXT, "cublasSrot_v2");
		tracer._kernel_map[(void *) lcublasSrot_v2] = std::string("cublasSrot_v2");
	}
	assert(lcublasSrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrot_v2);
	}
	return res;
}

cublasStatus_t cublasSrot_v2_64(cublasHandle_t  handle, int64_t  n, float*  x, int64_t  incx, float*  y, int64_t  incy, const float*  c, const float*  s)
{
	static cublasStatus_t (*lcublasSrot_v2_64) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t , const float* , const float* );
	if (!lcublasSrot_v2_64) {
		lcublasSrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t , const float* , const float* )) dlsym(RTLD_NEXT, "cublasSrot_v2_64");
		tracer._kernel_map[(void *) lcublasSrot_v2_64] = std::string("cublasSrot_v2_64");
	}
	assert(lcublasSrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasDrot_v2(cublasHandle_t  handle, int  n, double*  x, int  incx, double*  y, int  incy, const double*  c, const double*  s)
{
	static cublasStatus_t (*lcublasDrot_v2) (cublasHandle_t , int , double* , int , double* , int , const double* , const double* );
	if (!lcublasDrot_v2) {
		lcublasDrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , double* , int , double* , int , const double* , const double* )) dlsym(RTLD_NEXT, "cublasDrot_v2");
		tracer._kernel_map[(void *) lcublasDrot_v2] = std::string("cublasDrot_v2");
	}
	assert(lcublasDrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrot_v2);
	}
	return res;
}

cublasStatus_t cublasDrot_v2_64(cublasHandle_t  handle, int64_t  n, double*  x, int64_t  incx, double*  y, int64_t  incy, const double*  c, const double*  s)
{
	static cublasStatus_t (*lcublasDrot_v2_64) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t , const double* , const double* );
	if (!lcublasDrot_v2_64) {
		lcublasDrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t , const double* , const double* )) dlsym(RTLD_NEXT, "cublasDrot_v2_64");
		tracer._kernel_map[(void *) lcublasDrot_v2_64] = std::string("cublasDrot_v2_64");
	}
	assert(lcublasDrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasCrot_v2(cublasHandle_t  handle, int  n, cuComplex*  x, int  incx, cuComplex*  y, int  incy, const float*  c, const cuComplex*  s)
{
	static cublasStatus_t (*lcublasCrot_v2) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int , const float* , const cuComplex* );
	if (!lcublasCrot_v2) {
		lcublasCrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int , const float* , const cuComplex* )) dlsym(RTLD_NEXT, "cublasCrot_v2");
		tracer._kernel_map[(void *) lcublasCrot_v2] = std::string("cublasCrot_v2");
	}
	assert(lcublasCrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCrot_v2);
	}
	return res;
}

cublasStatus_t cublasCrot_v2_64(cublasHandle_t  handle, int64_t  n, cuComplex*  x, int64_t  incx, cuComplex*  y, int64_t  incy, const float*  c, const cuComplex*  s)
{
	static cublasStatus_t (*lcublasCrot_v2_64) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t , const float* , const cuComplex* );
	if (!lcublasCrot_v2_64) {
		lcublasCrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t , const float* , const cuComplex* )) dlsym(RTLD_NEXT, "cublasCrot_v2_64");
		tracer._kernel_map[(void *) lcublasCrot_v2_64] = std::string("cublasCrot_v2_64");
	}
	assert(lcublasCrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsrot_v2(cublasHandle_t  handle, int  n, cuComplex*  x, int  incx, cuComplex*  y, int  incy, const float*  c, const float*  s)
{
	static cublasStatus_t (*lcublasCsrot_v2) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int , const float* , const float* );
	if (!lcublasCsrot_v2) {
		lcublasCsrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuComplex* , int , cuComplex* , int , const float* , const float* )) dlsym(RTLD_NEXT, "cublasCsrot_v2");
		tracer._kernel_map[(void *) lcublasCsrot_v2] = std::string("cublasCsrot_v2");
	}
	assert(lcublasCsrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsrot_v2);
	}
	return res;
}

cublasStatus_t cublasCsrot_v2_64(cublasHandle_t  handle, int64_t  n, cuComplex*  x, int64_t  incx, cuComplex*  y, int64_t  incy, const float*  c, const float*  s)
{
	static cublasStatus_t (*lcublasCsrot_v2_64) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t , const float* , const float* );
	if (!lcublasCsrot_v2_64) {
		lcublasCsrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuComplex* , int64_t , cuComplex* , int64_t , const float* , const float* )) dlsym(RTLD_NEXT, "cublasCsrot_v2_64");
		tracer._kernel_map[(void *) lcublasCsrot_v2_64] = std::string("cublasCsrot_v2_64");
	}
	assert(lcublasCsrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasZrot_v2(cublasHandle_t  handle, int  n, cuDoubleComplex*  x, int  incx, cuDoubleComplex*  y, int  incy, const double*  c, const cuDoubleComplex*  s)
{
	static cublasStatus_t (*lcublasZrot_v2) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int , const double* , const cuDoubleComplex* );
	if (!lcublasZrot_v2) {
		lcublasZrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int , const double* , const cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZrot_v2");
		tracer._kernel_map[(void *) lcublasZrot_v2] = std::string("cublasZrot_v2");
	}
	assert(lcublasZrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZrot_v2);
	}
	return res;
}

cublasStatus_t cublasZrot_v2_64(cublasHandle_t  handle, int64_t  n, cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  y, int64_t  incy, const double*  c, const cuDoubleComplex*  s)
{
	static cublasStatus_t (*lcublasZrot_v2_64) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t , const double* , const cuDoubleComplex* );
	if (!lcublasZrot_v2_64) {
		lcublasZrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t , const double* , const cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZrot_v2_64");
		tracer._kernel_map[(void *) lcublasZrot_v2_64] = std::string("cublasZrot_v2_64");
	}
	assert(lcublasZrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasZdrot_v2(cublasHandle_t  handle, int  n, cuDoubleComplex*  x, int  incx, cuDoubleComplex*  y, int  incy, const double*  c, const double*  s)
{
	static cublasStatus_t (*lcublasZdrot_v2) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int , const double* , const double* );
	if (!lcublasZdrot_v2) {
		lcublasZdrot_v2 = (cublasStatus_t (*) (cublasHandle_t , int , cuDoubleComplex* , int , cuDoubleComplex* , int , const double* , const double* )) dlsym(RTLD_NEXT, "cublasZdrot_v2");
		tracer._kernel_map[(void *) lcublasZdrot_v2] = std::string("cublasZdrot_v2");
	}
	assert(lcublasZdrot_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdrot_v2(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdrot_v2);
	}
	return res;
}

cublasStatus_t cublasZdrot_v2_64(cublasHandle_t  handle, int64_t  n, cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  y, int64_t  incy, const double*  c, const double*  s)
{
	static cublasStatus_t (*lcublasZdrot_v2_64) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t , const double* , const double* );
	if (!lcublasZdrot_v2_64) {
		lcublasZdrot_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t , const double* , const double* )) dlsym(RTLD_NEXT, "cublasZdrot_v2_64");
		tracer._kernel_map[(void *) lcublasZdrot_v2_64] = std::string("cublasZdrot_v2_64");
	}
	assert(lcublasZdrot_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdrot_v2_64(handle, n, x, incx, y, incy, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdrot_v2_64);
	}
	return res;
}

cublasStatus_t cublasRotEx(cublasHandle_t  handle, int  n, void*  x, cudaDataType  xType, int  incx, void*  y, cudaDataType  yType, int  incy, const void*  c, const void*  s, cudaDataType  csType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotEx) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int , const void* , const void* , cudaDataType , cudaDataType );
	if (!lcublasRotEx) {
		lcublasRotEx = (cublasStatus_t (*) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int , const void* , const void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotEx");
		tracer._kernel_map[(void *) lcublasRotEx] = std::string("cublasRotEx");
	}
	assert(lcublasRotEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotEx(handle, n, x, xType, incx, y, yType, incy, c, s, csType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotEx);
	}
	return res;
}

cublasStatus_t cublasRotEx_64(cublasHandle_t  handle, int64_t  n, void*  x, cudaDataType  xType, int64_t  incx, void*  y, cudaDataType  yType, int64_t  incy, const void*  c, const void*  s, cudaDataType  csType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotEx_64) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , const void* , const void* , cudaDataType , cudaDataType );
	if (!lcublasRotEx_64) {
		lcublasRotEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , const void* , const void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotEx_64");
		tracer._kernel_map[(void *) lcublasRotEx_64] = std::string("cublasRotEx_64");
	}
	assert(lcublasRotEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotEx_64(handle, n, x, xType, incx, y, yType, incy, c, s, csType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotEx_64);
	}
	return res;
}

cublasStatus_t cublasSrotg_v2(cublasHandle_t  handle, float*  a, float*  b, float*  c, float*  s)
{
	static cublasStatus_t (*lcublasSrotg_v2) (cublasHandle_t , float* , float* , float* , float* );
	if (!lcublasSrotg_v2) {
		lcublasSrotg_v2 = (cublasStatus_t (*) (cublasHandle_t , float* , float* , float* , float* )) dlsym(RTLD_NEXT, "cublasSrotg_v2");
		tracer._kernel_map[(void *) lcublasSrotg_v2] = std::string("cublasSrotg_v2");
	}
	assert(lcublasSrotg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrotg_v2(handle, a, b, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrotg_v2);
	}
	return res;
}

cublasStatus_t cublasDrotg_v2(cublasHandle_t  handle, double*  a, double*  b, double*  c, double*  s)
{
	static cublasStatus_t (*lcublasDrotg_v2) (cublasHandle_t , double* , double* , double* , double* );
	if (!lcublasDrotg_v2) {
		lcublasDrotg_v2 = (cublasStatus_t (*) (cublasHandle_t , double* , double* , double* , double* )) dlsym(RTLD_NEXT, "cublasDrotg_v2");
		tracer._kernel_map[(void *) lcublasDrotg_v2] = std::string("cublasDrotg_v2");
	}
	assert(lcublasDrotg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrotg_v2(handle, a, b, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrotg_v2);
	}
	return res;
}

cublasStatus_t cublasCrotg_v2(cublasHandle_t  handle, cuComplex*  a, cuComplex*  b, float*  c, cuComplex*  s)
{
	static cublasStatus_t (*lcublasCrotg_v2) (cublasHandle_t , cuComplex* , cuComplex* , float* , cuComplex* );
	if (!lcublasCrotg_v2) {
		lcublasCrotg_v2 = (cublasStatus_t (*) (cublasHandle_t , cuComplex* , cuComplex* , float* , cuComplex* )) dlsym(RTLD_NEXT, "cublasCrotg_v2");
		tracer._kernel_map[(void *) lcublasCrotg_v2] = std::string("cublasCrotg_v2");
	}
	assert(lcublasCrotg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCrotg_v2(handle, a, b, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCrotg_v2);
	}
	return res;
}

cublasStatus_t cublasZrotg_v2(cublasHandle_t  handle, cuDoubleComplex*  a, cuDoubleComplex*  b, double*  c, cuDoubleComplex*  s)
{
	static cublasStatus_t (*lcublasZrotg_v2) (cublasHandle_t , cuDoubleComplex* , cuDoubleComplex* , double* , cuDoubleComplex* );
	if (!lcublasZrotg_v2) {
		lcublasZrotg_v2 = (cublasStatus_t (*) (cublasHandle_t , cuDoubleComplex* , cuDoubleComplex* , double* , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZrotg_v2");
		tracer._kernel_map[(void *) lcublasZrotg_v2] = std::string("cublasZrotg_v2");
	}
	assert(lcublasZrotg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZrotg_v2(handle, a, b, c, s);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZrotg_v2);
	}
	return res;
}

cublasStatus_t cublasRotgEx(cublasHandle_t  handle, void*  a, void*  b, cudaDataType  abType, void*  c, void*  s, cudaDataType  csType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotgEx) (cublasHandle_t , void* , void* , cudaDataType , void* , void* , cudaDataType , cudaDataType );
	if (!lcublasRotgEx) {
		lcublasRotgEx = (cublasStatus_t (*) (cublasHandle_t , void* , void* , cudaDataType , void* , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotgEx");
		tracer._kernel_map[(void *) lcublasRotgEx] = std::string("cublasRotgEx");
	}
	assert(lcublasRotgEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotgEx(handle, a, b, abType, c, s, csType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotgEx);
	}
	return res;
}

cublasStatus_t cublasSrotm_v2(cublasHandle_t  handle, int  n, float*  x, int  incx, float*  y, int  incy, const float*  param)
{
	static cublasStatus_t (*lcublasSrotm_v2) (cublasHandle_t , int , float* , int , float* , int , const float* );
	if (!lcublasSrotm_v2) {
		lcublasSrotm_v2 = (cublasStatus_t (*) (cublasHandle_t , int , float* , int , float* , int , const float* )) dlsym(RTLD_NEXT, "cublasSrotm_v2");
		tracer._kernel_map[(void *) lcublasSrotm_v2] = std::string("cublasSrotm_v2");
	}
	assert(lcublasSrotm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrotm_v2(handle, n, x, incx, y, incy, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrotm_v2);
	}
	return res;
}

cublasStatus_t cublasSrotm_v2_64(cublasHandle_t  handle, int64_t  n, float*  x, int64_t  incx, float*  y, int64_t  incy, const float*  param)
{
	static cublasStatus_t (*lcublasSrotm_v2_64) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t , const float* );
	if (!lcublasSrotm_v2_64) {
		lcublasSrotm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , float* , int64_t , float* , int64_t , const float* )) dlsym(RTLD_NEXT, "cublasSrotm_v2_64");
		tracer._kernel_map[(void *) lcublasSrotm_v2_64] = std::string("cublasSrotm_v2_64");
	}
	assert(lcublasSrotm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrotm_v2_64(handle, n, x, incx, y, incy, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrotm_v2_64);
	}
	return res;
}

cublasStatus_t cublasDrotm_v2(cublasHandle_t  handle, int  n, double*  x, int  incx, double*  y, int  incy, const double*  param)
{
	static cublasStatus_t (*lcublasDrotm_v2) (cublasHandle_t , int , double* , int , double* , int , const double* );
	if (!lcublasDrotm_v2) {
		lcublasDrotm_v2 = (cublasStatus_t (*) (cublasHandle_t , int , double* , int , double* , int , const double* )) dlsym(RTLD_NEXT, "cublasDrotm_v2");
		tracer._kernel_map[(void *) lcublasDrotm_v2] = std::string("cublasDrotm_v2");
	}
	assert(lcublasDrotm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrotm_v2(handle, n, x, incx, y, incy, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrotm_v2);
	}
	return res;
}

cublasStatus_t cublasDrotm_v2_64(cublasHandle_t  handle, int64_t  n, double*  x, int64_t  incx, double*  y, int64_t  incy, const double*  param)
{
	static cublasStatus_t (*lcublasDrotm_v2_64) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t , const double* );
	if (!lcublasDrotm_v2_64) {
		lcublasDrotm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , double* , int64_t , double* , int64_t , const double* )) dlsym(RTLD_NEXT, "cublasDrotm_v2_64");
		tracer._kernel_map[(void *) lcublasDrotm_v2_64] = std::string("cublasDrotm_v2_64");
	}
	assert(lcublasDrotm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrotm_v2_64(handle, n, x, incx, y, incy, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrotm_v2_64);
	}
	return res;
}

cublasStatus_t cublasRotmEx(cublasHandle_t  handle, int  n, void*  x, cudaDataType  xType, int  incx, void*  y, cudaDataType  yType, int  incy, const void*  param, cudaDataType  paramType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotmEx) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int , const void* , cudaDataType , cudaDataType );
	if (!lcublasRotmEx) {
		lcublasRotmEx = (cublasStatus_t (*) (cublasHandle_t , int , void* , cudaDataType , int , void* , cudaDataType , int , const void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotmEx");
		tracer._kernel_map[(void *) lcublasRotmEx] = std::string("cublasRotmEx");
	}
	assert(lcublasRotmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotmEx(handle, n, x, xType, incx, y, yType, incy, param, paramType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotmEx);
	}
	return res;
}

cublasStatus_t cublasRotmEx_64(cublasHandle_t  handle, int64_t  n, void*  x, cudaDataType  xType, int64_t  incx, void*  y, cudaDataType  yType, int64_t  incy, const void*  param, cudaDataType  paramType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotmEx_64) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , const void* , cudaDataType , cudaDataType );
	if (!lcublasRotmEx_64) {
		lcublasRotmEx_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , void* , cudaDataType , int64_t , void* , cudaDataType , int64_t , const void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotmEx_64");
		tracer._kernel_map[(void *) lcublasRotmEx_64] = std::string("cublasRotmEx_64");
	}
	assert(lcublasRotmEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotmEx_64(handle, n, x, xType, incx, y, yType, incy, param, paramType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotmEx_64);
	}
	return res;
}

cublasStatus_t cublasSrotmg_v2(cublasHandle_t  handle, float*  d1, float*  d2, float*  x1, const float*  y1, float*  param)
{
	static cublasStatus_t (*lcublasSrotmg_v2) (cublasHandle_t , float* , float* , float* , const float* , float* );
	if (!lcublasSrotmg_v2) {
		lcublasSrotmg_v2 = (cublasStatus_t (*) (cublasHandle_t , float* , float* , float* , const float* , float* )) dlsym(RTLD_NEXT, "cublasSrotmg_v2");
		tracer._kernel_map[(void *) lcublasSrotmg_v2] = std::string("cublasSrotmg_v2");
	}
	assert(lcublasSrotmg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSrotmg_v2(handle, d1, d2, x1, y1, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSrotmg_v2);
	}
	return res;
}

cublasStatus_t cublasDrotmg_v2(cublasHandle_t  handle, double*  d1, double*  d2, double*  x1, const double*  y1, double*  param)
{
	static cublasStatus_t (*lcublasDrotmg_v2) (cublasHandle_t , double* , double* , double* , const double* , double* );
	if (!lcublasDrotmg_v2) {
		lcublasDrotmg_v2 = (cublasStatus_t (*) (cublasHandle_t , double* , double* , double* , const double* , double* )) dlsym(RTLD_NEXT, "cublasDrotmg_v2");
		tracer._kernel_map[(void *) lcublasDrotmg_v2] = std::string("cublasDrotmg_v2");
	}
	assert(lcublasDrotmg_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDrotmg_v2(handle, d1, d2, x1, y1, param);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDrotmg_v2);
	}
	return res;
}

cublasStatus_t cublasRotmgEx(cublasHandle_t  handle, void*  d1, cudaDataType  d1Type, void*  d2, cudaDataType  d2Type, void*  x1, cudaDataType  x1Type, const void*  y1, cudaDataType  y1Type, void*  param, cudaDataType  paramType, cudaDataType  executiontype)
{
	static cublasStatus_t (*lcublasRotmgEx) (cublasHandle_t , void* , cudaDataType , void* , cudaDataType , void* , cudaDataType , const void* , cudaDataType , void* , cudaDataType , cudaDataType );
	if (!lcublasRotmgEx) {
		lcublasRotmgEx = (cublasStatus_t (*) (cublasHandle_t , void* , cudaDataType , void* , cudaDataType , void* , cudaDataType , const void* , cudaDataType , void* , cudaDataType , cudaDataType )) dlsym(RTLD_NEXT, "cublasRotmgEx");
		tracer._kernel_map[(void *) lcublasRotmgEx] = std::string("cublasRotmgEx");
	}
	assert(lcublasRotmgEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasRotmgEx(handle, d1, d1Type, d2, d2Type, x1, x1Type, y1, y1Type, param, paramType, executiontype);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasRotmgEx);
	}
	return res;
}

cublasStatus_t cublasSgemv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const float*  A, int  lda, const float*  x, int  incx, const float*  beta, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSgemv_v2) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSgemv_v2) {
		lcublasSgemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSgemv_v2");
		tracer._kernel_map[(void *) lcublasSgemv_v2] = std::string("cublasSgemv_v2");
	}
	assert(lcublasSgemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemv_v2(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemv_v2);
	}
	return res;
}

cublasStatus_t cublasSgemv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, const float*  x, int64_t  incx, const float*  beta, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSgemv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSgemv_v2_64) {
		lcublasSgemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSgemv_v2_64");
		tracer._kernel_map[(void *) lcublasSgemv_v2_64] = std::string("cublasSgemv_v2_64");
	}
	assert(lcublasSgemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemv_v2_64(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDgemv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const double*  alpha, const double*  A, int  lda, const double*  x, int  incx, const double*  beta, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDgemv_v2) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDgemv_v2) {
		lcublasDgemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDgemv_v2");
		tracer._kernel_map[(void *) lcublasDgemv_v2] = std::string("cublasDgemv_v2");
	}
	assert(lcublasDgemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemv_v2(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemv_v2);
	}
	return res;
}

cublasStatus_t cublasDgemv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, const double*  x, int64_t  incx, const double*  beta, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDgemv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDgemv_v2_64) {
		lcublasDgemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDgemv_v2_64");
		tracer._kernel_map[(void *) lcublasDgemv_v2_64] = std::string("cublasDgemv_v2_64");
	}
	assert(lcublasDgemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemv_v2_64(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgemv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCgemv_v2) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCgemv_v2) {
		lcublasCgemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgemv_v2");
		tracer._kernel_map[(void *) lcublasCgemv_v2] = std::string("cublasCgemv_v2");
	}
	assert(lcublasCgemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemv_v2(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemv_v2);
	}
	return res;
}

cublasStatus_t cublasCgemv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCgemv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCgemv_v2_64) {
		lcublasCgemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgemv_v2_64");
		tracer._kernel_map[(void *) lcublasCgemv_v2_64] = std::string("cublasCgemv_v2_64");
	}
	assert(lcublasCgemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemv_v2_64(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZgemv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZgemv_v2) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZgemv_v2) {
		lcublasZgemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgemv_v2");
		tracer._kernel_map[(void *) lcublasZgemv_v2] = std::string("cublasZgemv_v2");
	}
	assert(lcublasZgemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemv_v2(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemv_v2);
	}
	return res;
}

cublasStatus_t cublasZgemv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZgemv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZgemv_v2_64) {
		lcublasZgemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgemv_v2_64");
		tracer._kernel_map[(void *) lcublasZgemv_v2_64] = std::string("cublasZgemv_v2_64");
	}
	assert(lcublasZgemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemv_v2_64(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasSgbmv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  kl, int  ku, const float*  alpha, const float*  A, int  lda, const float*  x, int  incx, const float*  beta, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSgbmv_v2) (cublasHandle_t , cublasOperation_t , int , int , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSgbmv_v2) {
		lcublasSgbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSgbmv_v2");
		tracer._kernel_map[(void *) lcublasSgbmv_v2] = std::string("cublasSgbmv_v2");
	}
	assert(lcublasSgbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgbmv_v2(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgbmv_v2);
	}
	return res;
}

cublasStatus_t cublasSgbmv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, int64_t  kl, int64_t  ku, const float*  alpha, const float*  A, int64_t  lda, const float*  x, int64_t  incx, const float*  beta, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSgbmv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSgbmv_v2_64) {
		lcublasSgbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSgbmv_v2_64");
		tracer._kernel_map[(void *) lcublasSgbmv_v2_64] = std::string("cublasSgbmv_v2_64");
	}
	assert(lcublasSgbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgbmv_v2_64(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDgbmv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  kl, int  ku, const double*  alpha, const double*  A, int  lda, const double*  x, int  incx, const double*  beta, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDgbmv_v2) (cublasHandle_t , cublasOperation_t , int , int , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDgbmv_v2) {
		lcublasDgbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDgbmv_v2");
		tracer._kernel_map[(void *) lcublasDgbmv_v2] = std::string("cublasDgbmv_v2");
	}
	assert(lcublasDgbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgbmv_v2(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgbmv_v2);
	}
	return res;
}

cublasStatus_t cublasDgbmv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, int64_t  kl, int64_t  ku, const double*  alpha, const double*  A, int64_t  lda, const double*  x, int64_t  incx, const double*  beta, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDgbmv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDgbmv_v2_64) {
		lcublasDgbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDgbmv_v2_64");
		tracer._kernel_map[(void *) lcublasDgbmv_v2_64] = std::string("cublasDgbmv_v2_64");
	}
	assert(lcublasDgbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgbmv_v2_64(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgbmv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  kl, int  ku, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCgbmv_v2) (cublasHandle_t , cublasOperation_t , int , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCgbmv_v2) {
		lcublasCgbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgbmv_v2");
		tracer._kernel_map[(void *) lcublasCgbmv_v2] = std::string("cublasCgbmv_v2");
	}
	assert(lcublasCgbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgbmv_v2(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgbmv_v2);
	}
	return res;
}

cublasStatus_t cublasCgbmv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, int64_t  kl, int64_t  ku, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCgbmv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCgbmv_v2_64) {
		lcublasCgbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgbmv_v2_64");
		tracer._kernel_map[(void *) lcublasCgbmv_v2_64] = std::string("cublasCgbmv_v2_64");
	}
	assert(lcublasCgbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgbmv_v2_64(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZgbmv_v2(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  kl, int  ku, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZgbmv_v2) (cublasHandle_t , cublasOperation_t , int , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZgbmv_v2) {
		lcublasZgbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgbmv_v2");
		tracer._kernel_map[(void *) lcublasZgbmv_v2] = std::string("cublasZgbmv_v2");
	}
	assert(lcublasZgbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgbmv_v2(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgbmv_v2);
	}
	return res;
}

cublasStatus_t cublasZgbmv_v2_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, int64_t  kl, int64_t  ku, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZgbmv_v2_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZgbmv_v2_64) {
		lcublasZgbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgbmv_v2_64");
		tracer._kernel_map[(void *) lcublasZgbmv_v2_64] = std::string("cublasZgbmv_v2_64");
	}
	assert(lcublasZgbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgbmv_v2_64(handle, trans, m, n, kl, ku, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStrmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const float*  A, int  lda, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStrmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , int , float* , int );
	if (!lcublasStrmv_v2) {
		lcublasStrmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStrmv_v2");
		tracer._kernel_map[(void *) lcublasStrmv_v2] = std::string("cublasStrmv_v2");
	}
	assert(lcublasStrmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrmv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrmv_v2);
	}
	return res;
}

cublasStatus_t cublasStrmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const float*  A, int64_t  lda, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStrmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasStrmv_v2_64) {
		lcublasStrmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStrmv_v2_64");
		tracer._kernel_map[(void *) lcublasStrmv_v2_64] = std::string("cublasStrmv_v2_64");
	}
	assert(lcublasStrmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrmv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtrmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const double*  A, int  lda, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtrmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , int , double* , int );
	if (!lcublasDtrmv_v2) {
		lcublasDtrmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtrmv_v2");
		tracer._kernel_map[(void *) lcublasDtrmv_v2] = std::string("cublasDtrmv_v2");
	}
	assert(lcublasDtrmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrmv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrmv_v2);
	}
	return res;
}

cublasStatus_t cublasDtrmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const double*  A, int64_t  lda, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtrmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDtrmv_v2_64) {
		lcublasDtrmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtrmv_v2_64");
		tracer._kernel_map[(void *) lcublasDtrmv_v2_64] = std::string("cublasDtrmv_v2_64");
	}
	assert(lcublasDtrmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrmv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtrmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuComplex*  A, int  lda, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtrmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtrmv_v2) {
		lcublasCtrmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtrmv_v2");
		tracer._kernel_map[(void *) lcublasCtrmv_v2] = std::string("cublasCtrmv_v2");
	}
	assert(lcublasCtrmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrmv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrmv_v2);
	}
	return res;
}

cublasStatus_t cublasCtrmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuComplex*  A, int64_t  lda, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtrmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtrmv_v2_64) {
		lcublasCtrmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtrmv_v2_64");
		tracer._kernel_map[(void *) lcublasCtrmv_v2_64] = std::string("cublasCtrmv_v2_64");
	}
	assert(lcublasCtrmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrmv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtrmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtrmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtrmv_v2) {
		lcublasZtrmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtrmv_v2");
		tracer._kernel_map[(void *) lcublasZtrmv_v2] = std::string("cublasZtrmv_v2");
	}
	assert(lcublasZtrmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrmv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrmv_v2);
	}
	return res;
}

cublasStatus_t cublasZtrmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuDoubleComplex*  A, int64_t  lda, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtrmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtrmv_v2_64) {
		lcublasZtrmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtrmv_v2_64");
		tracer._kernel_map[(void *) lcublasZtrmv_v2_64] = std::string("cublasZtrmv_v2_64");
	}
	assert(lcublasZtrmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrmv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const float*  A, int  lda, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStbmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , int , float* , int );
	if (!lcublasStbmv_v2) {
		lcublasStbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStbmv_v2");
		tracer._kernel_map[(void *) lcublasStbmv_v2] = std::string("cublasStbmv_v2");
	}
	assert(lcublasStbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStbmv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStbmv_v2);
	}
	return res;
}

cublasStatus_t cublasStbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const float*  A, int64_t  lda, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStbmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasStbmv_v2_64) {
		lcublasStbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStbmv_v2_64");
		tracer._kernel_map[(void *) lcublasStbmv_v2_64] = std::string("cublasStbmv_v2_64");
	}
	assert(lcublasStbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStbmv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const double*  A, int  lda, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtbmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , int , double* , int );
	if (!lcublasDtbmv_v2) {
		lcublasDtbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtbmv_v2");
		tracer._kernel_map[(void *) lcublasDtbmv_v2] = std::string("cublasDtbmv_v2");
	}
	assert(lcublasDtbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtbmv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtbmv_v2);
	}
	return res;
}

cublasStatus_t cublasDtbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const double*  A, int64_t  lda, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtbmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDtbmv_v2_64) {
		lcublasDtbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtbmv_v2_64");
		tracer._kernel_map[(void *) lcublasDtbmv_v2_64] = std::string("cublasDtbmv_v2_64");
	}
	assert(lcublasDtbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtbmv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const cuComplex*  A, int  lda, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtbmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtbmv_v2) {
		lcublasCtbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtbmv_v2");
		tracer._kernel_map[(void *) lcublasCtbmv_v2] = std::string("cublasCtbmv_v2");
	}
	assert(lcublasCtbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtbmv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtbmv_v2);
	}
	return res;
}

cublasStatus_t cublasCtbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const cuComplex*  A, int64_t  lda, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtbmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtbmv_v2_64) {
		lcublasCtbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtbmv_v2_64");
		tracer._kernel_map[(void *) lcublasCtbmv_v2_64] = std::string("cublasCtbmv_v2_64");
	}
	assert(lcublasCtbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtbmv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtbmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtbmv_v2) {
		lcublasZtbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtbmv_v2");
		tracer._kernel_map[(void *) lcublasZtbmv_v2] = std::string("cublasZtbmv_v2");
	}
	assert(lcublasZtbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtbmv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtbmv_v2);
	}
	return res;
}

cublasStatus_t cublasZtbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const cuDoubleComplex*  A, int64_t  lda, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtbmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtbmv_v2_64) {
		lcublasZtbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtbmv_v2_64");
		tracer._kernel_map[(void *) lcublasZtbmv_v2_64] = std::string("cublasZtbmv_v2_64");
	}
	assert(lcublasZtbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtbmv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const float*  AP, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStpmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , float* , int );
	if (!lcublasStpmv_v2) {
		lcublasStpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasStpmv_v2");
		tracer._kernel_map[(void *) lcublasStpmv_v2] = std::string("cublasStpmv_v2");
	}
	assert(lcublasStpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStpmv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStpmv_v2);
	}
	return res;
}

cublasStatus_t cublasStpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const float*  AP, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStpmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , float* , int64_t );
	if (!lcublasStpmv_v2_64) {
		lcublasStpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStpmv_v2_64");
		tracer._kernel_map[(void *) lcublasStpmv_v2_64] = std::string("cublasStpmv_v2_64");
	}
	assert(lcublasStpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStpmv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const double*  AP, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtpmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , double* , int );
	if (!lcublasDtpmv_v2) {
		lcublasDtpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDtpmv_v2");
		tracer._kernel_map[(void *) lcublasDtpmv_v2] = std::string("cublasDtpmv_v2");
	}
	assert(lcublasDtpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtpmv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtpmv_v2);
	}
	return res;
}

cublasStatus_t cublasDtpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const double*  AP, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtpmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , double* , int64_t );
	if (!lcublasDtpmv_v2_64) {
		lcublasDtpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtpmv_v2_64");
		tracer._kernel_map[(void *) lcublasDtpmv_v2_64] = std::string("cublasDtpmv_v2_64");
	}
	assert(lcublasDtpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtpmv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuComplex*  AP, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtpmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCtpmv_v2) {
		lcublasCtpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtpmv_v2");
		tracer._kernel_map[(void *) lcublasCtpmv_v2] = std::string("cublasCtpmv_v2");
	}
	assert(lcublasCtpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtpmv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtpmv_v2);
	}
	return res;
}

cublasStatus_t cublasCtpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuComplex*  AP, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtpmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCtpmv_v2_64) {
		lcublasCtpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtpmv_v2_64");
		tracer._kernel_map[(void *) lcublasCtpmv_v2_64] = std::string("cublasCtpmv_v2_64");
	}
	assert(lcublasCtpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtpmv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuDoubleComplex*  AP, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtpmv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZtpmv_v2) {
		lcublasZtpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtpmv_v2");
		tracer._kernel_map[(void *) lcublasZtpmv_v2] = std::string("cublasZtpmv_v2");
	}
	assert(lcublasZtpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtpmv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtpmv_v2);
	}
	return res;
}

cublasStatus_t cublasZtpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuDoubleComplex*  AP, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtpmv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZtpmv_v2_64) {
		lcublasZtpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtpmv_v2_64");
		tracer._kernel_map[(void *) lcublasZtpmv_v2_64] = std::string("cublasZtpmv_v2_64");
	}
	assert(lcublasZtpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtpmv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStrsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const float*  A, int  lda, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStrsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , int , float* , int );
	if (!lcublasStrsv_v2) {
		lcublasStrsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStrsv_v2");
		tracer._kernel_map[(void *) lcublasStrsv_v2] = std::string("cublasStrsv_v2");
	}
	assert(lcublasStrsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsv_v2);
	}
	return res;
}

cublasStatus_t cublasStrsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const float*  A, int64_t  lda, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStrsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasStrsv_v2_64) {
		lcublasStrsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStrsv_v2_64");
		tracer._kernel_map[(void *) lcublasStrsv_v2_64] = std::string("cublasStrsv_v2_64");
	}
	assert(lcublasStrsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtrsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const double*  A, int  lda, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtrsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , int , double* , int );
	if (!lcublasDtrsv_v2) {
		lcublasDtrsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtrsv_v2");
		tracer._kernel_map[(void *) lcublasDtrsv_v2] = std::string("cublasDtrsv_v2");
	}
	assert(lcublasDtrsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsv_v2);
	}
	return res;
}

cublasStatus_t cublasDtrsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const double*  A, int64_t  lda, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtrsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDtrsv_v2_64) {
		lcublasDtrsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtrsv_v2_64");
		tracer._kernel_map[(void *) lcublasDtrsv_v2_64] = std::string("cublasDtrsv_v2_64");
	}
	assert(lcublasDtrsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtrsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuComplex*  A, int  lda, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtrsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtrsv_v2) {
		lcublasCtrsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtrsv_v2");
		tracer._kernel_map[(void *) lcublasCtrsv_v2] = std::string("cublasCtrsv_v2");
	}
	assert(lcublasCtrsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsv_v2);
	}
	return res;
}

cublasStatus_t cublasCtrsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuComplex*  A, int64_t  lda, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtrsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtrsv_v2_64) {
		lcublasCtrsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtrsv_v2_64");
		tracer._kernel_map[(void *) lcublasCtrsv_v2_64] = std::string("cublasCtrsv_v2_64");
	}
	assert(lcublasCtrsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtrsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtrsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtrsv_v2) {
		lcublasZtrsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtrsv_v2");
		tracer._kernel_map[(void *) lcublasZtrsv_v2] = std::string("cublasZtrsv_v2");
	}
	assert(lcublasZtrsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsv_v2(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsv_v2);
	}
	return res;
}

cublasStatus_t cublasZtrsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuDoubleComplex*  A, int64_t  lda, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtrsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtrsv_v2_64) {
		lcublasZtrsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtrsv_v2_64");
		tracer._kernel_map[(void *) lcublasZtrsv_v2_64] = std::string("cublasZtrsv_v2_64");
	}
	assert(lcublasZtrsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsv_v2_64(handle, uplo, trans, diag, n, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStpsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const float*  AP, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStpsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , float* , int );
	if (!lcublasStpsv_v2) {
		lcublasStpsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasStpsv_v2");
		tracer._kernel_map[(void *) lcublasStpsv_v2] = std::string("cublasStpsv_v2");
	}
	assert(lcublasStpsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStpsv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStpsv_v2);
	}
	return res;
}

cublasStatus_t cublasStpsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const float*  AP, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStpsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , float* , int64_t );
	if (!lcublasStpsv_v2_64) {
		lcublasStpsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStpsv_v2_64");
		tracer._kernel_map[(void *) lcublasStpsv_v2_64] = std::string("cublasStpsv_v2_64");
	}
	assert(lcublasStpsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStpsv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStpsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtpsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const double*  AP, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtpsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , double* , int );
	if (!lcublasDtpsv_v2) {
		lcublasDtpsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDtpsv_v2");
		tracer._kernel_map[(void *) lcublasDtpsv_v2] = std::string("cublasDtpsv_v2");
	}
	assert(lcublasDtpsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtpsv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtpsv_v2);
	}
	return res;
}

cublasStatus_t cublasDtpsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const double*  AP, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtpsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , double* , int64_t );
	if (!lcublasDtpsv_v2_64) {
		lcublasDtpsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtpsv_v2_64");
		tracer._kernel_map[(void *) lcublasDtpsv_v2_64] = std::string("cublasDtpsv_v2_64");
	}
	assert(lcublasDtpsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtpsv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtpsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtpsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuComplex*  AP, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtpsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCtpsv_v2) {
		lcublasCtpsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtpsv_v2");
		tracer._kernel_map[(void *) lcublasCtpsv_v2] = std::string("cublasCtpsv_v2");
	}
	assert(lcublasCtpsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtpsv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtpsv_v2);
	}
	return res;
}

cublasStatus_t cublasCtpsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuComplex*  AP, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtpsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCtpsv_v2_64) {
		lcublasCtpsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtpsv_v2_64");
		tracer._kernel_map[(void *) lcublasCtpsv_v2_64] = std::string("cublasCtpsv_v2_64");
	}
	assert(lcublasCtpsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtpsv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtpsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtpsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, const cuDoubleComplex*  AP, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtpsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZtpsv_v2) {
		lcublasZtpsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtpsv_v2");
		tracer._kernel_map[(void *) lcublasZtpsv_v2] = std::string("cublasZtpsv_v2");
	}
	assert(lcublasZtpsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtpsv_v2(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtpsv_v2);
	}
	return res;
}

cublasStatus_t cublasZtpsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, const cuDoubleComplex*  AP, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtpsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZtpsv_v2_64) {
		lcublasZtpsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtpsv_v2_64");
		tracer._kernel_map[(void *) lcublasZtpsv_v2_64] = std::string("cublasZtpsv_v2_64");
	}
	assert(lcublasZtpsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtpsv_v2_64(handle, uplo, trans, diag, n, AP, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtpsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasStbsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const float*  A, int  lda, float*  x, int  incx)
{
	static cublasStatus_t (*lcublasStbsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , int , float* , int );
	if (!lcublasStbsv_v2) {
		lcublasStbsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStbsv_v2");
		tracer._kernel_map[(void *) lcublasStbsv_v2] = std::string("cublasStbsv_v2");
	}
	assert(lcublasStbsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStbsv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStbsv_v2);
	}
	return res;
}

cublasStatus_t cublasStbsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const float*  A, int64_t  lda, float*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasStbsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasStbsv_v2_64) {
		lcublasStbsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStbsv_v2_64");
		tracer._kernel_map[(void *) lcublasStbsv_v2_64] = std::string("cublasStbsv_v2_64");
	}
	assert(lcublasStbsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStbsv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStbsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtbsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const double*  A, int  lda, double*  x, int  incx)
{
	static cublasStatus_t (*lcublasDtbsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , int , double* , int );
	if (!lcublasDtbsv_v2) {
		lcublasDtbsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtbsv_v2");
		tracer._kernel_map[(void *) lcublasDtbsv_v2] = std::string("cublasDtbsv_v2");
	}
	assert(lcublasDtbsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtbsv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtbsv_v2);
	}
	return res;
}

cublasStatus_t cublasDtbsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const double*  A, int64_t  lda, double*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasDtbsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDtbsv_v2_64) {
		lcublasDtbsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtbsv_v2_64");
		tracer._kernel_map[(void *) lcublasDtbsv_v2_64] = std::string("cublasDtbsv_v2_64");
	}
	assert(lcublasDtbsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtbsv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtbsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtbsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const cuComplex*  A, int  lda, cuComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasCtbsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtbsv_v2) {
		lcublasCtbsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtbsv_v2");
		tracer._kernel_map[(void *) lcublasCtbsv_v2] = std::string("cublasCtbsv_v2");
	}
	assert(lcublasCtbsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtbsv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtbsv_v2);
	}
	return res;
}

cublasStatus_t cublasCtbsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const cuComplex*  A, int64_t  lda, cuComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasCtbsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtbsv_v2_64) {
		lcublasCtbsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtbsv_v2_64");
		tracer._kernel_map[(void *) lcublasCtbsv_v2_64] = std::string("cublasCtbsv_v2_64");
	}
	assert(lcublasCtbsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtbsv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtbsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtbsv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  n, int  k, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  x, int  incx)
{
	static cublasStatus_t (*lcublasZtbsv_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtbsv_v2) {
		lcublasZtbsv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtbsv_v2");
		tracer._kernel_map[(void *) lcublasZtbsv_v2] = std::string("cublasZtbsv_v2");
	}
	assert(lcublasZtbsv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtbsv_v2(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtbsv_v2);
	}
	return res;
}

cublasStatus_t cublasZtbsv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  n, int64_t  k, const cuDoubleComplex*  A, int64_t  lda, cuDoubleComplex*  x, int64_t  incx)
{
	static cublasStatus_t (*lcublasZtbsv_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtbsv_v2_64) {
		lcublasZtbsv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtbsv_v2_64");
		tracer._kernel_map[(void *) lcublasZtbsv_v2_64] = std::string("cublasZtbsv_v2_64");
	}
	assert(lcublasZtbsv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtbsv_v2_64(handle, uplo, trans, diag, n, k, A, lda, x, incx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtbsv_v2_64);
	}
	return res;
}

cublasStatus_t cublasSsymv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  A, int  lda, const float*  x, int  incx, const float*  beta, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSsymv_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSsymv_v2) {
		lcublasSsymv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsymv_v2");
		tracer._kernel_map[(void *) lcublasSsymv_v2] = std::string("cublasSsymv_v2");
	}
	assert(lcublasSsymv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsymv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsymv_v2);
	}
	return res;
}

cublasStatus_t cublasSsymv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, const float*  x, int64_t  incx, const float*  beta, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSsymv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsymv_v2_64) {
		lcublasSsymv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsymv_v2_64");
		tracer._kernel_map[(void *) lcublasSsymv_v2_64] = std::string("cublasSsymv_v2_64");
	}
	assert(lcublasSsymv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsymv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsymv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsymv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  A, int  lda, const double*  x, int  incx, const double*  beta, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDsymv_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDsymv_v2) {
		lcublasDsymv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsymv_v2");
		tracer._kernel_map[(void *) lcublasDsymv_v2] = std::string("cublasDsymv_v2");
	}
	assert(lcublasDsymv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsymv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsymv_v2);
	}
	return res;
}

cublasStatus_t cublasDsymv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, const double*  x, int64_t  incx, const double*  beta, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDsymv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsymv_v2_64) {
		lcublasDsymv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsymv_v2_64");
		tracer._kernel_map[(void *) lcublasDsymv_v2_64] = std::string("cublasDsymv_v2_64");
	}
	assert(lcublasDsymv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsymv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsymv_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsymv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasCsymv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCsymv_v2) {
		lcublasCsymv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsymv_v2");
		tracer._kernel_map[(void *) lcublasCsymv_v2] = std::string("cublasCsymv_v2");
	}
	assert(lcublasCsymv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsymv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsymv_v2);
	}
	return res;
}

cublasStatus_t cublasCsymv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasCsymv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCsymv_v2_64) {
		lcublasCsymv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsymv_v2_64");
		tracer._kernel_map[(void *) lcublasCsymv_v2_64] = std::string("cublasCsymv_v2_64");
	}
	assert(lcublasCsymv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsymv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsymv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsymv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZsymv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZsymv_v2) {
		lcublasZsymv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsymv_v2");
		tracer._kernel_map[(void *) lcublasZsymv_v2] = std::string("cublasZsymv_v2");
	}
	assert(lcublasZsymv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsymv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsymv_v2);
	}
	return res;
}

cublasStatus_t cublasZsymv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZsymv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZsymv_v2_64) {
		lcublasZsymv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsymv_v2_64");
		tracer._kernel_map[(void *) lcublasZsymv_v2_64] = std::string("cublasZsymv_v2_64");
	}
	assert(lcublasZsymv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsymv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsymv_v2_64);
	}
	return res;
}

cublasStatus_t cublasChemv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasChemv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasChemv_v2) {
		lcublasChemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasChemv_v2");
		tracer._kernel_map[(void *) lcublasChemv_v2] = std::string("cublasChemv_v2");
	}
	assert(lcublasChemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChemv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChemv_v2);
	}
	return res;
}

cublasStatus_t cublasChemv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasChemv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasChemv_v2_64) {
		lcublasChemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasChemv_v2_64");
		tracer._kernel_map[(void *) lcublasChemv_v2_64] = std::string("cublasChemv_v2_64");
	}
	assert(lcublasChemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChemv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhemv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZhemv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZhemv_v2) {
		lcublasZhemv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZhemv_v2");
		tracer._kernel_map[(void *) lcublasZhemv_v2] = std::string("cublasZhemv_v2");
	}
	assert(lcublasZhemv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhemv_v2(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhemv_v2);
	}
	return res;
}

cublasStatus_t cublasZhemv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZhemv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZhemv_v2_64) {
		lcublasZhemv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZhemv_v2_64");
		tracer._kernel_map[(void *) lcublasZhemv_v2_64] = std::string("cublasZhemv_v2_64");
	}
	assert(lcublasZhemv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhemv_v2_64(handle, uplo, n, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhemv_v2_64);
	}
	return res;
}

cublasStatus_t cublasSsbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, int  k, const float*  alpha, const float*  A, int  lda, const float*  x, int  incx, const float*  beta, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSsbmv_v2) (cublasHandle_t , cublasFillMode_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSsbmv_v2) {
		lcublasSsbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsbmv_v2");
		tracer._kernel_map[(void *) lcublasSsbmv_v2] = std::string("cublasSsbmv_v2");
	}
	assert(lcublasSsbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsbmv_v2(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsbmv_v2);
	}
	return res;
}

cublasStatus_t cublasSsbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, const float*  x, int64_t  incx, const float*  beta, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSsbmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsbmv_v2_64) {
		lcublasSsbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsbmv_v2_64");
		tracer._kernel_map[(void *) lcublasSsbmv_v2_64] = std::string("cublasSsbmv_v2_64");
	}
	assert(lcublasSsbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsbmv_v2_64(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, int  k, const double*  alpha, const double*  A, int  lda, const double*  x, int  incx, const double*  beta, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDsbmv_v2) (cublasHandle_t , cublasFillMode_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDsbmv_v2) {
		lcublasDsbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsbmv_v2");
		tracer._kernel_map[(void *) lcublasDsbmv_v2] = std::string("cublasDsbmv_v2");
	}
	assert(lcublasDsbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsbmv_v2(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsbmv_v2);
	}
	return res;
}

cublasStatus_t cublasDsbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, const double*  x, int64_t  incx, const double*  beta, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDsbmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsbmv_v2_64) {
		lcublasDsbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsbmv_v2_64");
		tracer._kernel_map[(void *) lcublasDsbmv_v2_64] = std::string("cublasDsbmv_v2_64");
	}
	assert(lcublasDsbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsbmv_v2_64(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasChbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasChbmv_v2) (cublasHandle_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasChbmv_v2) {
		lcublasChbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasChbmv_v2");
		tracer._kernel_map[(void *) lcublasChbmv_v2] = std::string("cublasChbmv_v2");
	}
	assert(lcublasChbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChbmv_v2(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChbmv_v2);
	}
	return res;
}

cublasStatus_t cublasChbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasChbmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasChbmv_v2_64) {
		lcublasChbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasChbmv_v2_64");
		tracer._kernel_map[(void *) lcublasChbmv_v2_64] = std::string("cublasChbmv_v2_64");
	}
	assert(lcublasChbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChbmv_v2_64(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhbmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZhbmv_v2) (cublasHandle_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZhbmv_v2) {
		lcublasZhbmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZhbmv_v2");
		tracer._kernel_map[(void *) lcublasZhbmv_v2] = std::string("cublasZhbmv_v2");
	}
	assert(lcublasZhbmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhbmv_v2(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhbmv_v2);
	}
	return res;
}

cublasStatus_t cublasZhbmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZhbmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZhbmv_v2_64) {
		lcublasZhbmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZhbmv_v2_64");
		tracer._kernel_map[(void *) lcublasZhbmv_v2_64] = std::string("cublasZhbmv_v2_64");
	}
	assert(lcublasZhbmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhbmv_v2_64(handle, uplo, n, k, alpha, A, lda, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhbmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasSspmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  AP, const float*  x, int  incx, const float*  beta, float*  y, int  incy)
{
	static cublasStatus_t (*lcublasSspmv_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , const float* , int , const float* , float* , int );
	if (!lcublasSspmv_v2) {
		lcublasSspmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSspmv_v2");
		tracer._kernel_map[(void *) lcublasSspmv_v2] = std::string("cublasSspmv_v2");
	}
	assert(lcublasSspmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspmv_v2(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspmv_v2);
	}
	return res;
}

cublasStatus_t cublasSspmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  AP, const float*  x, int64_t  incx, const float*  beta, float*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasSspmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSspmv_v2_64) {
		lcublasSspmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSspmv_v2_64");
		tracer._kernel_map[(void *) lcublasSspmv_v2_64] = std::string("cublasSspmv_v2_64");
	}
	assert(lcublasSspmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspmv_v2_64(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasDspmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  AP, const double*  x, int  incx, const double*  beta, double*  y, int  incy)
{
	static cublasStatus_t (*lcublasDspmv_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , const double* , int , const double* , double* , int );
	if (!lcublasDspmv_v2) {
		lcublasDspmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDspmv_v2");
		tracer._kernel_map[(void *) lcublasDspmv_v2] = std::string("cublasDspmv_v2");
	}
	assert(lcublasDspmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspmv_v2(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspmv_v2);
	}
	return res;
}

cublasStatus_t cublasDspmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  AP, const double*  x, int64_t  incx, const double*  beta, double*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasDspmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDspmv_v2_64) {
		lcublasDspmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDspmv_v2_64");
		tracer._kernel_map[(void *) lcublasDspmv_v2_64] = std::string("cublasDspmv_v2_64");
	}
	assert(lcublasDspmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspmv_v2_64(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasChpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  AP, const cuComplex*  x, int  incx, const cuComplex*  beta, cuComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasChpmv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasChpmv_v2) {
		lcublasChpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasChpmv_v2");
		tracer._kernel_map[(void *) lcublasChpmv_v2] = std::string("cublasChpmv_v2");
	}
	assert(lcublasChpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpmv_v2(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpmv_v2);
	}
	return res;
}

cublasStatus_t cublasChpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  AP, const cuComplex*  x, int64_t  incx, const cuComplex*  beta, cuComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasChpmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasChpmv_v2_64) {
		lcublasChpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasChpmv_v2_64");
		tracer._kernel_map[(void *) lcublasChpmv_v2_64] = std::string("cublasChpmv_v2_64");
	}
	assert(lcublasChpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpmv_v2_64(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhpmv_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  AP, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy)
{
	static cublasStatus_t (*lcublasZhpmv_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZhpmv_v2) {
		lcublasZhpmv_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZhpmv_v2");
		tracer._kernel_map[(void *) lcublasZhpmv_v2] = std::string("cublasZhpmv_v2");
	}
	assert(lcublasZhpmv_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpmv_v2(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpmv_v2);
	}
	return res;
}

cublasStatus_t cublasZhpmv_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  AP, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy)
{
	static cublasStatus_t (*lcublasZhpmv_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZhpmv_v2_64) {
		lcublasZhpmv_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZhpmv_v2_64");
		tracer._kernel_map[(void *) lcublasZhpmv_v2_64] = std::string("cublasZhpmv_v2_64");
	}
	assert(lcublasZhpmv_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpmv_v2_64(handle, uplo, n, alpha, AP, x, incx, beta, y, incy);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpmv_v2_64);
	}
	return res;
}

cublasStatus_t cublasSger_v2(cublasHandle_t  handle, int  m, int  n, const float*  alpha, const float*  x, int  incx, const float*  y, int  incy, float*  A, int  lda)
{
	static cublasStatus_t (*lcublasSger_v2) (cublasHandle_t , int , int , const float* , const float* , int , const float* , int , float* , int );
	if (!lcublasSger_v2) {
		lcublasSger_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const float* , const float* , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSger_v2");
		tracer._kernel_map[(void *) lcublasSger_v2] = std::string("cublasSger_v2");
	}
	assert(lcublasSger_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSger_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSger_v2);
	}
	return res;
}

cublasStatus_t cublasSger_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, const float*  y, int64_t  incy, float*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasSger_v2_64) (cublasHandle_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasSger_v2_64) {
		lcublasSger_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSger_v2_64");
		tracer._kernel_map[(void *) lcublasSger_v2_64] = std::string("cublasSger_v2_64");
	}
	assert(lcublasSger_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSger_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSger_v2_64);
	}
	return res;
}

cublasStatus_t cublasDger_v2(cublasHandle_t  handle, int  m, int  n, const double*  alpha, const double*  x, int  incx, const double*  y, int  incy, double*  A, int  lda)
{
	static cublasStatus_t (*lcublasDger_v2) (cublasHandle_t , int , int , const double* , const double* , int , const double* , int , double* , int );
	if (!lcublasDger_v2) {
		lcublasDger_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const double* , const double* , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDger_v2");
		tracer._kernel_map[(void *) lcublasDger_v2] = std::string("cublasDger_v2");
	}
	assert(lcublasDger_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDger_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDger_v2);
	}
	return res;
}

cublasStatus_t cublasDger_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, const double*  y, int64_t  incy, double*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasDger_v2_64) (cublasHandle_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDger_v2_64) {
		lcublasDger_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDger_v2_64");
		tracer._kernel_map[(void *) lcublasDger_v2_64] = std::string("cublasDger_v2_64");
	}
	assert(lcublasDger_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDger_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDger_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgeru_v2(cublasHandle_t  handle, int  m, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCgeru_v2) (cublasHandle_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCgeru_v2) {
		lcublasCgeru_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgeru_v2");
		tracer._kernel_map[(void *) lcublasCgeru_v2] = std::string("cublasCgeru_v2");
	}
	assert(lcublasCgeru_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgeru_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgeru_v2);
	}
	return res;
}

cublasStatus_t cublasCgeru_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCgeru_v2_64) (cublasHandle_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCgeru_v2_64) {
		lcublasCgeru_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgeru_v2_64");
		tracer._kernel_map[(void *) lcublasCgeru_v2_64] = std::string("cublasCgeru_v2_64");
	}
	assert(lcublasCgeru_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgeru_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgeru_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgerc_v2(cublasHandle_t  handle, int  m, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCgerc_v2) (cublasHandle_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCgerc_v2) {
		lcublasCgerc_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgerc_v2");
		tracer._kernel_map[(void *) lcublasCgerc_v2] = std::string("cublasCgerc_v2");
	}
	assert(lcublasCgerc_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgerc_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgerc_v2);
	}
	return res;
}

cublasStatus_t cublasCgerc_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCgerc_v2_64) (cublasHandle_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCgerc_v2_64) {
		lcublasCgerc_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgerc_v2_64");
		tracer._kernel_map[(void *) lcublasCgerc_v2_64] = std::string("cublasCgerc_v2_64");
	}
	assert(lcublasCgerc_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgerc_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgerc_v2_64);
	}
	return res;
}

cublasStatus_t cublasZgeru_v2(cublasHandle_t  handle, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZgeru_v2) (cublasHandle_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZgeru_v2) {
		lcublasZgeru_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgeru_v2");
		tracer._kernel_map[(void *) lcublasZgeru_v2] = std::string("cublasZgeru_v2");
	}
	assert(lcublasZgeru_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgeru_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgeru_v2);
	}
	return res;
}

cublasStatus_t cublasZgeru_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZgeru_v2_64) (cublasHandle_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZgeru_v2_64) {
		lcublasZgeru_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgeru_v2_64");
		tracer._kernel_map[(void *) lcublasZgeru_v2_64] = std::string("cublasZgeru_v2_64");
	}
	assert(lcublasZgeru_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgeru_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgeru_v2_64);
	}
	return res;
}

cublasStatus_t cublasZgerc_v2(cublasHandle_t  handle, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZgerc_v2) (cublasHandle_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZgerc_v2) {
		lcublasZgerc_v2 = (cublasStatus_t (*) (cublasHandle_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgerc_v2");
		tracer._kernel_map[(void *) lcublasZgerc_v2] = std::string("cublasZgerc_v2");
	}
	assert(lcublasZgerc_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgerc_v2(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgerc_v2);
	}
	return res;
}

cublasStatus_t cublasZgerc_v2_64(cublasHandle_t  handle, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZgerc_v2_64) (cublasHandle_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZgerc_v2_64) {
		lcublasZgerc_v2_64 = (cublasStatus_t (*) (cublasHandle_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgerc_v2_64");
		tracer._kernel_map[(void *) lcublasZgerc_v2_64] = std::string("cublasZgerc_v2_64");
	}
	assert(lcublasZgerc_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgerc_v2_64(handle, m, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgerc_v2_64);
	}
	return res;
}

cublasStatus_t cublasSsyr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  x, int  incx, float*  A, int  lda)
{
	static cublasStatus_t (*lcublasSsyr_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , float* , int );
	if (!lcublasSsyr_v2) {
		lcublasSsyr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSsyr_v2");
		tracer._kernel_map[(void *) lcublasSsyr_v2] = std::string("cublasSsyr_v2");
	}
	assert(lcublasSsyr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr_v2);
	}
	return res;
}

cublasStatus_t cublasSsyr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, float*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasSsyr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , float* , int64_t );
	if (!lcublasSsyr_v2_64) {
		lcublasSsyr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsyr_v2_64");
		tracer._kernel_map[(void *) lcublasSsyr_v2_64] = std::string("cublasSsyr_v2_64");
	}
	assert(lcublasSsyr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsyr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  x, int  incx, double*  A, int  lda)
{
	static cublasStatus_t (*lcublasDsyr_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , double* , int );
	if (!lcublasDsyr_v2) {
		lcublasDsyr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDsyr_v2");
		tracer._kernel_map[(void *) lcublasDsyr_v2] = std::string("cublasDsyr_v2");
	}
	assert(lcublasDsyr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr_v2);
	}
	return res;
}

cublasStatus_t cublasDsyr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, double*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasDsyr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , double* , int64_t );
	if (!lcublasDsyr_v2_64) {
		lcublasDsyr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsyr_v2_64");
		tracer._kernel_map[(void *) lcublasDsyr_v2_64] = std::string("cublasDsyr_v2_64");
	}
	assert(lcublasDsyr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsyr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCsyr_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCsyr_v2) {
		lcublasCsyr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsyr_v2");
		tracer._kernel_map[(void *) lcublasCsyr_v2] = std::string("cublasCsyr_v2");
	}
	assert(lcublasCsyr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr_v2);
	}
	return res;
}

cublasStatus_t cublasCsyr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCsyr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCsyr_v2_64) {
		lcublasCsyr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsyr_v2_64");
		tracer._kernel_map[(void *) lcublasCsyr_v2_64] = std::string("cublasCsyr_v2_64");
	}
	assert(lcublasCsyr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsyr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZsyr_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZsyr_v2) {
		lcublasZsyr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsyr_v2");
		tracer._kernel_map[(void *) lcublasZsyr_v2] = std::string("cublasZsyr_v2");
	}
	assert(lcublasZsyr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr_v2);
	}
	return res;
}

cublasStatus_t cublasZsyr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZsyr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZsyr_v2_64) {
		lcublasZsyr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsyr_v2_64");
		tracer._kernel_map[(void *) lcublasZsyr_v2_64] = std::string("cublasZsyr_v2_64");
	}
	assert(lcublasZsyr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr_v2_64);
	}
	return res;
}

cublasStatus_t cublasCher_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const cuComplex*  x, int  incx, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCher_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCher_v2) {
		lcublasCher_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCher_v2");
		tracer._kernel_map[(void *) lcublasCher_v2] = std::string("cublasCher_v2");
	}
	assert(lcublasCher_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher_v2);
	}
	return res;
}

cublasStatus_t cublasCher_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const cuComplex*  x, int64_t  incx, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCher_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCher_v2_64) {
		lcublasCher_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCher_v2_64");
		tracer._kernel_map[(void *) lcublasCher_v2_64] = std::string("cublasCher_v2_64");
	}
	assert(lcublasCher_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher_v2_64);
	}
	return res;
}

cublasStatus_t cublasZher_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZher_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZher_v2) {
		lcublasZher_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZher_v2");
		tracer._kernel_map[(void *) lcublasZher_v2] = std::string("cublasZher_v2");
	}
	assert(lcublasZher_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher_v2(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher_v2);
	}
	return res;
}

cublasStatus_t cublasZher_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZher_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZher_v2_64) {
		lcublasZher_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZher_v2_64");
		tracer._kernel_map[(void *) lcublasZher_v2_64] = std::string("cublasZher_v2_64");
	}
	assert(lcublasZher_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher_v2_64(handle, uplo, n, alpha, x, incx, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher_v2_64);
	}
	return res;
}

cublasStatus_t cublasSspr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  x, int  incx, float*  AP)
{
	static cublasStatus_t (*lcublasSspr_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , float* );
	if (!lcublasSspr_v2) {
		lcublasSspr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasSspr_v2");
		tracer._kernel_map[(void *) lcublasSspr_v2] = std::string("cublasSspr_v2");
	}
	assert(lcublasSspr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspr_v2(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspr_v2);
	}
	return res;
}

cublasStatus_t cublasSspr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, float*  AP)
{
	static cublasStatus_t (*lcublasSspr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , float* );
	if (!lcublasSspr_v2_64) {
		lcublasSspr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasSspr_v2_64");
		tracer._kernel_map[(void *) lcublasSspr_v2_64] = std::string("cublasSspr_v2_64");
	}
	assert(lcublasSspr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspr_v2_64(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspr_v2_64);
	}
	return res;
}

cublasStatus_t cublasDspr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  x, int  incx, double*  AP)
{
	static cublasStatus_t (*lcublasDspr_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , double* );
	if (!lcublasDspr_v2) {
		lcublasDspr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDspr_v2");
		tracer._kernel_map[(void *) lcublasDspr_v2] = std::string("cublasDspr_v2");
	}
	assert(lcublasDspr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspr_v2(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspr_v2);
	}
	return res;
}

cublasStatus_t cublasDspr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, double*  AP)
{
	static cublasStatus_t (*lcublasDspr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , double* );
	if (!lcublasDspr_v2_64) {
		lcublasDspr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDspr_v2_64");
		tracer._kernel_map[(void *) lcublasDspr_v2_64] = std::string("cublasDspr_v2_64");
	}
	assert(lcublasDspr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspr_v2_64(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspr_v2_64);
	}
	return res;
}

cublasStatus_t cublasChpr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const cuComplex*  x, int  incx, cuComplex*  AP)
{
	static cublasStatus_t (*lcublasChpr_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const cuComplex* , int , cuComplex* );
	if (!lcublasChpr_v2) {
		lcublasChpr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const cuComplex* , int , cuComplex* )) dlsym(RTLD_NEXT, "cublasChpr_v2");
		tracer._kernel_map[(void *) lcublasChpr_v2] = std::string("cublasChpr_v2");
	}
	assert(lcublasChpr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpr_v2(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpr_v2);
	}
	return res;
}

cublasStatus_t cublasChpr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const cuComplex*  x, int64_t  incx, cuComplex*  AP)
{
	static cublasStatus_t (*lcublasChpr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const cuComplex* , int64_t , cuComplex* );
	if (!lcublasChpr_v2_64) {
		lcublasChpr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const cuComplex* , int64_t , cuComplex* )) dlsym(RTLD_NEXT, "cublasChpr_v2_64");
		tracer._kernel_map[(void *) lcublasChpr_v2_64] = std::string("cublasChpr_v2_64");
	}
	assert(lcublasChpr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpr_v2_64(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpr_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhpr_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  AP)
{
	static cublasStatus_t (*lcublasZhpr_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const cuDoubleComplex* , int , cuDoubleComplex* );
	if (!lcublasZhpr_v2) {
		lcublasZhpr_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const cuDoubleComplex* , int , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZhpr_v2");
		tracer._kernel_map[(void *) lcublasZhpr_v2] = std::string("cublasZhpr_v2");
	}
	assert(lcublasZhpr_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpr_v2(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpr_v2);
	}
	return res;
}

cublasStatus_t cublasZhpr_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  AP)
{
	static cublasStatus_t (*lcublasZhpr_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const cuDoubleComplex* , int64_t , cuDoubleComplex* );
	if (!lcublasZhpr_v2_64) {
		lcublasZhpr_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const cuDoubleComplex* , int64_t , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZhpr_v2_64");
		tracer._kernel_map[(void *) lcublasZhpr_v2_64] = std::string("cublasZhpr_v2_64");
	}
	assert(lcublasZhpr_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpr_v2_64(handle, uplo, n, alpha, x, incx, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpr_v2_64);
	}
	return res;
}

cublasStatus_t cublasSsyr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  x, int  incx, const float*  y, int  incy, float*  A, int  lda)
{
	static cublasStatus_t (*lcublasSsyr2_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , float* , int );
	if (!lcublasSsyr2_v2) {
		lcublasSsyr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSsyr2_v2");
		tracer._kernel_map[(void *) lcublasSsyr2_v2] = std::string("cublasSsyr2_v2");
	}
	assert(lcublasSsyr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr2_v2);
	}
	return res;
}

cublasStatus_t cublasSsyr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, const float*  y, int64_t  incy, float*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasSsyr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasSsyr2_v2_64) {
		lcublasSsyr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsyr2_v2_64");
		tracer._kernel_map[(void *) lcublasSsyr2_v2_64] = std::string("cublasSsyr2_v2_64");
	}
	assert(lcublasSsyr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsyr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  x, int  incx, const double*  y, int  incy, double*  A, int  lda)
{
	static cublasStatus_t (*lcublasDsyr2_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , double* , int );
	if (!lcublasDsyr2_v2) {
		lcublasDsyr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDsyr2_v2");
		tracer._kernel_map[(void *) lcublasDsyr2_v2] = std::string("cublasDsyr2_v2");
	}
	assert(lcublasDsyr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr2_v2);
	}
	return res;
}

cublasStatus_t cublasDsyr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, const double*  y, int64_t  incy, double*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasDsyr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDsyr2_v2_64) {
		lcublasDsyr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsyr2_v2_64");
		tracer._kernel_map[(void *) lcublasDsyr2_v2_64] = std::string("cublasDsyr2_v2_64");
	}
	assert(lcublasDsyr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsyr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCsyr2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCsyr2_v2) {
		lcublasCsyr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsyr2_v2");
		tracer._kernel_map[(void *) lcublasCsyr2_v2] = std::string("cublasCsyr2_v2");
	}
	assert(lcublasCsyr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr2_v2);
	}
	return res;
}

cublasStatus_t cublasCsyr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCsyr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCsyr2_v2_64) {
		lcublasCsyr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsyr2_v2_64");
		tracer._kernel_map[(void *) lcublasCsyr2_v2_64] = std::string("cublasCsyr2_v2_64");
	}
	assert(lcublasCsyr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsyr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZsyr2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZsyr2_v2) {
		lcublasZsyr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsyr2_v2");
		tracer._kernel_map[(void *) lcublasZsyr2_v2] = std::string("cublasZsyr2_v2");
	}
	assert(lcublasZsyr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr2_v2);
	}
	return res;
}

cublasStatus_t cublasZsyr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZsyr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZsyr2_v2_64) {
		lcublasZsyr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsyr2_v2_64");
		tracer._kernel_map[(void *) lcublasZsyr2_v2_64] = std::string("cublasZsyr2_v2_64");
	}
	assert(lcublasZsyr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasCher2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCher2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCher2_v2) {
		lcublasCher2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCher2_v2");
		tracer._kernel_map[(void *) lcublasCher2_v2] = std::string("cublasCher2_v2");
	}
	assert(lcublasCher2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher2_v2);
	}
	return res;
}

cublasStatus_t cublasCher2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasCher2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCher2_v2_64) {
		lcublasCher2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCher2_v2_64");
		tracer._kernel_map[(void *) lcublasCher2_v2_64] = std::string("cublasCher2_v2_64");
	}
	assert(lcublasCher2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher2_v2_64);
	}
	return res;
}

cublasStatus_t cublasZher2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZher2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZher2_v2) {
		lcublasZher2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZher2_v2");
		tracer._kernel_map[(void *) lcublasZher2_v2] = std::string("cublasZher2_v2");
	}
	assert(lcublasZher2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher2_v2(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher2_v2);
	}
	return res;
}

cublasStatus_t cublasZher2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  A, int64_t  lda)
{
	static cublasStatus_t (*lcublasZher2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZher2_v2_64) {
		lcublasZher2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZher2_v2_64");
		tracer._kernel_map[(void *) lcublasZher2_v2_64] = std::string("cublasZher2_v2_64");
	}
	assert(lcublasZher2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher2_v2_64);
	}
	return res;
}

cublasStatus_t cublasSspr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  alpha, const float*  x, int  incx, const float*  y, int  incy, float*  AP)
{
	static cublasStatus_t (*lcublasSspr2_v2) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , float* );
	if (!lcublasSspr2_v2) {
		lcublasSspr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , const float* , int , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasSspr2_v2");
		tracer._kernel_map[(void *) lcublasSspr2_v2] = std::string("cublasSspr2_v2");
	}
	assert(lcublasSspr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspr2_v2(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspr2_v2);
	}
	return res;
}

cublasStatus_t cublasSspr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const float*  alpha, const float*  x, int64_t  incx, const float*  y, int64_t  incy, float*  AP)
{
	static cublasStatus_t (*lcublasSspr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* );
	if (!lcublasSspr2_v2_64) {
		lcublasSspr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* )) dlsym(RTLD_NEXT, "cublasSspr2_v2_64");
		tracer._kernel_map[(void *) lcublasSspr2_v2_64] = std::string("cublasSspr2_v2_64");
	}
	assert(lcublasSspr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSspr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSspr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasDspr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  alpha, const double*  x, int  incx, const double*  y, int  incy, double*  AP)
{
	static cublasStatus_t (*lcublasDspr2_v2) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , double* );
	if (!lcublasDspr2_v2) {
		lcublasDspr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , const double* , int , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDspr2_v2");
		tracer._kernel_map[(void *) lcublasDspr2_v2] = std::string("cublasDspr2_v2");
	}
	assert(lcublasDspr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspr2_v2(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspr2_v2);
	}
	return res;
}

cublasStatus_t cublasDspr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const double*  alpha, const double*  x, int64_t  incx, const double*  y, int64_t  incy, double*  AP)
{
	static cublasStatus_t (*lcublasDspr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* );
	if (!lcublasDspr2_v2_64) {
		lcublasDspr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* )) dlsym(RTLD_NEXT, "cublasDspr2_v2_64");
		tracer._kernel_map[(void *) lcublasDspr2_v2_64] = std::string("cublasDspr2_v2_64");
	}
	assert(lcublasDspr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDspr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDspr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasChpr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  alpha, const cuComplex*  x, int  incx, const cuComplex*  y, int  incy, cuComplex*  AP)
{
	static cublasStatus_t (*lcublasChpr2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* );
	if (!lcublasChpr2_v2) {
		lcublasChpr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* )) dlsym(RTLD_NEXT, "cublasChpr2_v2");
		tracer._kernel_map[(void *) lcublasChpr2_v2] = std::string("cublasChpr2_v2");
	}
	assert(lcublasChpr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpr2_v2(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpr2_v2);
	}
	return res;
}

cublasStatus_t cublasChpr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuComplex*  alpha, const cuComplex*  x, int64_t  incx, const cuComplex*  y, int64_t  incy, cuComplex*  AP)
{
	static cublasStatus_t (*lcublasChpr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* );
	if (!lcublasChpr2_v2_64) {
		lcublasChpr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* )) dlsym(RTLD_NEXT, "cublasChpr2_v2_64");
		tracer._kernel_map[(void *) lcublasChpr2_v2_64] = std::string("cublasChpr2_v2_64");
	}
	assert(lcublasChpr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChpr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChpr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhpr2_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int  incx, const cuDoubleComplex*  y, int  incy, cuDoubleComplex*  AP)
{
	static cublasStatus_t (*lcublasZhpr2_v2) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* );
	if (!lcublasZhpr2_v2) {
		lcublasZhpr2_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZhpr2_v2");
		tracer._kernel_map[(void *) lcublasZhpr2_v2] = std::string("cublasZhpr2_v2");
	}
	assert(lcublasZhpr2_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpr2_v2(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpr2_v2);
	}
	return res;
}

cublasStatus_t cublasZhpr2_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  x, int64_t  incx, const cuDoubleComplex*  y, int64_t  incy, cuDoubleComplex*  AP)
{
	static cublasStatus_t (*lcublasZhpr2_v2_64) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* );
	if (!lcublasZhpr2_v2_64) {
		lcublasZhpr2_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZhpr2_v2_64");
		tracer._kernel_map[(void *) lcublasZhpr2_v2_64] = std::string("cublasZhpr2_v2_64");
	}
	assert(lcublasZhpr2_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhpr2_v2_64(handle, uplo, n, alpha, x, incx, y, incy, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhpr2_v2_64);
	}
	return res;
}

cublasStatus_t cublasSgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const float* const  Aarray[], int  lda, const float* const  xarray[], int  incx, const float*  beta, float* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasSgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* const [], int , const float* const [], int , const float* , float* const [], int , int );
	if (!lcublasSgemvBatched) {
		lcublasSgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* const [], int , const float* const [], int , const float* , float* const [], int , int )) dlsym(RTLD_NEXT, "cublasSgemvBatched");
		tracer._kernel_map[(void *) lcublasSgemvBatched] = std::string("cublasSgemvBatched");
	}
	assert(lcublasSgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemvBatched);
	}
	return res;
}

cublasStatus_t cublasSgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const float* const  Aarray[], int64_t  lda, const float* const  xarray[], int64_t  incx, const float*  beta, float* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasSgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* const [], int64_t , const float* const [], int64_t , const float* , float* const [], int64_t , int64_t );
	if (!lcublasSgemvBatched_64) {
		lcublasSgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* const [], int64_t , const float* const [], int64_t , const float* , float* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasSgemvBatched_64");
		tracer._kernel_map[(void *) lcublasSgemvBatched_64] = std::string("cublasSgemvBatched_64");
	}
	assert(lcublasSgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasDgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const double*  alpha, const double* const  Aarray[], int  lda, const double* const  xarray[], int  incx, const double*  beta, double* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasDgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* const [], int , const double* const [], int , const double* , double* const [], int , int );
	if (!lcublasDgemvBatched) {
		lcublasDgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* const [], int , const double* const [], int , const double* , double* const [], int , int )) dlsym(RTLD_NEXT, "cublasDgemvBatched");
		tracer._kernel_map[(void *) lcublasDgemvBatched] = std::string("cublasDgemvBatched");
	}
	assert(lcublasDgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemvBatched);
	}
	return res;
}

cublasStatus_t cublasDgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const double*  alpha, const double* const  Aarray[], int64_t  lda, const double* const  xarray[], int64_t  incx, const double*  beta, double* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasDgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* const [], int64_t , const double* const [], int64_t , const double* , double* const [], int64_t , int64_t );
	if (!lcublasDgemvBatched_64) {
		lcublasDgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* const [], int64_t , const double* const [], int64_t , const double* , double* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasDgemvBatched_64");
		tracer._kernel_map[(void *) lcublasDgemvBatched_64] = std::string("cublasDgemvBatched_64");
	}
	assert(lcublasDgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuComplex*  alpha, const cuComplex* const  Aarray[], int  lda, const cuComplex* const  xarray[], int  incx, const cuComplex*  beta, cuComplex* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int );
	if (!lcublasCgemvBatched) {
		lcublasCgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasCgemvBatched");
		tracer._kernel_map[(void *) lcublasCgemvBatched] = std::string("cublasCgemvBatched");
	}
	assert(lcublasCgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemvBatched);
	}
	return res;
}

cublasStatus_t cublasCgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex* const  Aarray[], int64_t  lda, const cuComplex* const  xarray[], int64_t  incx, const cuComplex*  beta, cuComplex* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t );
	if (!lcublasCgemvBatched_64) {
		lcublasCgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasCgemvBatched_64");
		tracer._kernel_map[(void *) lcublasCgemvBatched_64] = std::string("cublasCgemvBatched_64");
	}
	assert(lcublasCgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasZgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  Aarray[], int  lda, const cuDoubleComplex* const  xarray[], int  incx, const cuDoubleComplex*  beta, cuDoubleComplex* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasZgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , const cuDoubleComplex* const [], int , const cuDoubleComplex* , cuDoubleComplex* const [], int , int );
	if (!lcublasZgemvBatched) {
		lcublasZgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , const cuDoubleComplex* const [], int , const cuDoubleComplex* , cuDoubleComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasZgemvBatched");
		tracer._kernel_map[(void *) lcublasZgemvBatched] = std::string("cublasZgemvBatched");
	}
	assert(lcublasZgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemvBatched);
	}
	return res;
}

cublasStatus_t cublasZgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  Aarray[], int64_t  lda, const cuDoubleComplex* const  xarray[], int64_t  incx, const cuDoubleComplex*  beta, cuDoubleComplex* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasZgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* , cuDoubleComplex* const [], int64_t , int64_t );
	if (!lcublasZgemvBatched_64) {
		lcublasZgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* , cuDoubleComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasZgemvBatched_64");
		tracer._kernel_map[(void *) lcublasZgemvBatched_64] = std::string("cublasZgemvBatched_64");
	}
	assert(lcublasZgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasHSHgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __half* const  Aarray[], int  lda, const __half* const  xarray[], int  incx, const float*  beta, __half* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasHSHgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* const [], int , const __half* const [], int , const float* , __half* const [], int , int );
	if (!lcublasHSHgemvBatched) {
		lcublasHSHgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* const [], int , const __half* const [], int , const float* , __half* const [], int , int )) dlsym(RTLD_NEXT, "cublasHSHgemvBatched");
		tracer._kernel_map[(void *) lcublasHSHgemvBatched] = std::string("cublasHSHgemvBatched");
	}
	assert(lcublasHSHgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSHgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSHgemvBatched);
	}
	return res;
}

cublasStatus_t cublasHSHgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __half* const  Aarray[], int64_t  lda, const __half* const  xarray[], int64_t  incx, const float*  beta, __half* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHSHgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* const [], int64_t , const __half* const [], int64_t , const float* , __half* const [], int64_t , int64_t );
	if (!lcublasHSHgemvBatched_64) {
		lcublasHSHgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* const [], int64_t , const __half* const [], int64_t , const float* , __half* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasHSHgemvBatched_64");
		tracer._kernel_map[(void *) lcublasHSHgemvBatched_64] = std::string("cublasHSHgemvBatched_64");
	}
	assert(lcublasHSHgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSHgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSHgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasHSSgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __half* const  Aarray[], int  lda, const __half* const  xarray[], int  incx, const float*  beta, float* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasHSSgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* const [], int , const __half* const [], int , const float* , float* const [], int , int );
	if (!lcublasHSSgemvBatched) {
		lcublasHSSgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* const [], int , const __half* const [], int , const float* , float* const [], int , int )) dlsym(RTLD_NEXT, "cublasHSSgemvBatched");
		tracer._kernel_map[(void *) lcublasHSSgemvBatched] = std::string("cublasHSSgemvBatched");
	}
	assert(lcublasHSSgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSSgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSSgemvBatched);
	}
	return res;
}

cublasStatus_t cublasHSSgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __half* const  Aarray[], int64_t  lda, const __half* const  xarray[], int64_t  incx, const float*  beta, float* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHSSgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* const [], int64_t , const __half* const [], int64_t , const float* , float* const [], int64_t , int64_t );
	if (!lcublasHSSgemvBatched_64) {
		lcublasHSSgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* const [], int64_t , const __half* const [], int64_t , const float* , float* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasHSSgemvBatched_64");
		tracer._kernel_map[(void *) lcublasHSSgemvBatched_64] = std::string("cublasHSSgemvBatched_64");
	}
	assert(lcublasHSSgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSSgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSSgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasTSTgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __nv_bfloat16* const  Aarray[], int  lda, const __nv_bfloat16* const  xarray[], int  incx, const float*  beta, __nv_bfloat16* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasTSTgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* const [], int , const __nv_bfloat16* const [], int , const float* , __nv_bfloat16* const [], int , int );
	if (!lcublasTSTgemvBatched) {
		lcublasTSTgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* const [], int , const __nv_bfloat16* const [], int , const float* , __nv_bfloat16* const [], int , int )) dlsym(RTLD_NEXT, "cublasTSTgemvBatched");
		tracer._kernel_map[(void *) lcublasTSTgemvBatched] = std::string("cublasTSTgemvBatched");
	}
	assert(lcublasTSTgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSTgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSTgemvBatched);
	}
	return res;
}

cublasStatus_t cublasTSTgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __nv_bfloat16* const  Aarray[], int64_t  lda, const __nv_bfloat16* const  xarray[], int64_t  incx, const float*  beta, __nv_bfloat16* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasTSTgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* const [], int64_t , const __nv_bfloat16* const [], int64_t , const float* , __nv_bfloat16* const [], int64_t , int64_t );
	if (!lcublasTSTgemvBatched_64) {
		lcublasTSTgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* const [], int64_t , const __nv_bfloat16* const [], int64_t , const float* , __nv_bfloat16* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasTSTgemvBatched_64");
		tracer._kernel_map[(void *) lcublasTSTgemvBatched_64] = std::string("cublasTSTgemvBatched_64");
	}
	assert(lcublasTSTgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSTgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSTgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasTSSgemvBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __nv_bfloat16* const  Aarray[], int  lda, const __nv_bfloat16* const  xarray[], int  incx, const float*  beta, float* const  yarray[], int  incy, int  batchCount)
{
	static cublasStatus_t (*lcublasTSSgemvBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* const [], int , const __nv_bfloat16* const [], int , const float* , float* const [], int , int );
	if (!lcublasTSSgemvBatched) {
		lcublasTSSgemvBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* const [], int , const __nv_bfloat16* const [], int , const float* , float* const [], int , int )) dlsym(RTLD_NEXT, "cublasTSSgemvBatched");
		tracer._kernel_map[(void *) lcublasTSSgemvBatched] = std::string("cublasTSSgemvBatched");
	}
	assert(lcublasTSSgemvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSSgemvBatched(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSSgemvBatched);
	}
	return res;
}

cublasStatus_t cublasTSSgemvBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __nv_bfloat16* const  Aarray[], int64_t  lda, const __nv_bfloat16* const  xarray[], int64_t  incx, const float*  beta, float* const  yarray[], int64_t  incy, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasTSSgemvBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* const [], int64_t , const __nv_bfloat16* const [], int64_t , const float* , float* const [], int64_t , int64_t );
	if (!lcublasTSSgemvBatched_64) {
		lcublasTSSgemvBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* const [], int64_t , const __nv_bfloat16* const [], int64_t , const float* , float* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasTSSgemvBatched_64");
		tracer._kernel_map[(void *) lcublasTSSgemvBatched_64] = std::string("cublasTSSgemvBatched_64");
	}
	assert(lcublasTSSgemvBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSSgemvBatched_64(handle, trans, m, n, alpha, Aarray, lda, xarray, incx, beta, yarray, incy, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSSgemvBatched_64);
	}
	return res;
}

cublasStatus_t cublasSgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const float*  A, int  lda, long long int  strideA, const float*  x, int  incx, long long int  stridex, const float*  beta, float*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasSgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* , int , long long int , const float* , int , long long int , const float* , float* , int , long long int , int );
	if (!lcublasSgemvStridedBatched) {
		lcublasSgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const float* , int , long long int , const float* , int , long long int , const float* , float* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasSgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasSgemvStridedBatched] = std::string("cublasSgemvStridedBatched");
	}
	assert(lcublasSgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasSgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, long long int  strideA, const float*  x, int64_t  incx, long long int  stridex, const float*  beta, float*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasSgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , long long int , const float* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t );
	if (!lcublasSgemvStridedBatched_64) {
		lcublasSgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , long long int , const float* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasSgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasSgemvStridedBatched_64] = std::string("cublasSgemvStridedBatched_64");
	}
	assert(lcublasSgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasDgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const double*  alpha, const double*  A, int  lda, long long int  strideA, const double*  x, int  incx, long long int  stridex, const double*  beta, double*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasDgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* , int , long long int , const double* , int , long long int , const double* , double* , int , long long int , int );
	if (!lcublasDgemvStridedBatched) {
		lcublasDgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const double* , const double* , int , long long int , const double* , int , long long int , const double* , double* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasDgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasDgemvStridedBatched] = std::string("cublasDgemvStridedBatched");
	}
	assert(lcublasDgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasDgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, long long int  strideA, const double*  x, int64_t  incx, long long int  stridex, const double*  beta, double*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasDgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , long long int , const double* , int64_t , long long int , const double* , double* , int64_t , long long int , int64_t );
	if (!lcublasDgemvStridedBatched_64) {
		lcublasDgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , long long int , const double* , int64_t , long long int , const double* , double* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasDgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasDgemvStridedBatched_64] = std::string("cublasDgemvStridedBatched_64");
	}
	assert(lcublasDgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, long long int  strideA, const cuComplex*  x, int  incx, long long int  stridex, const cuComplex*  beta, cuComplex*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int );
	if (!lcublasCgemvStridedBatched) {
		lcublasCgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasCgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasCgemvStridedBatched] = std::string("cublasCgemvStridedBatched");
	}
	assert(lcublasCgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasCgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, long long int  strideA, const cuComplex*  x, int64_t  incx, long long int  stridex, const cuComplex*  beta, cuComplex*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t );
	if (!lcublasCgemvStridedBatched_64) {
		lcublasCgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasCgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasCgemvStridedBatched_64] = std::string("cublasCgemvStridedBatched_64");
	}
	assert(lcublasCgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasZgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, long long int  strideA, const cuDoubleComplex*  x, int  incx, long long int  stridex, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasZgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , cuDoubleComplex* , int , long long int , int );
	if (!lcublasZgemvStridedBatched) {
		lcublasZgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , cuDoubleComplex* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasZgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasZgemvStridedBatched] = std::string("cublasZgemvStridedBatched");
	}
	assert(lcublasZgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasZgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, long long int  strideA, const cuDoubleComplex*  x, int64_t  incx, long long int  stridex, const cuDoubleComplex*  beta, cuDoubleComplex*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasZgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , cuDoubleComplex* , int64_t , long long int , int64_t );
	if (!lcublasZgemvStridedBatched_64) {
		lcublasZgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , cuDoubleComplex* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasZgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasZgemvStridedBatched_64] = std::string("cublasZgemvStridedBatched_64");
	}
	assert(lcublasZgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasHSHgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __half*  A, int  lda, long long int  strideA, const __half*  x, int  incx, long long int  stridex, const float*  beta, __half*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasHSHgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* , int , long long int , const __half* , int , long long int , const float* , __half* , int , long long int , int );
	if (!lcublasHSHgemvStridedBatched) {
		lcublasHSHgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* , int , long long int , const __half* , int , long long int , const float* , __half* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasHSHgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasHSHgemvStridedBatched] = std::string("cublasHSHgemvStridedBatched");
	}
	assert(lcublasHSHgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSHgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSHgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasHSHgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __half*  A, int64_t  lda, long long int  strideA, const __half*  x, int64_t  incx, long long int  stridex, const float*  beta, __half*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHSHgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const float* , __half* , int64_t , long long int , int64_t );
	if (!lcublasHSHgemvStridedBatched_64) {
		lcublasHSHgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const float* , __half* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasHSHgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasHSHgemvStridedBatched_64] = std::string("cublasHSHgemvStridedBatched_64");
	}
	assert(lcublasHSHgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSHgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSHgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasHSSgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __half*  A, int  lda, long long int  strideA, const __half*  x, int  incx, long long int  stridex, const float*  beta, float*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasHSSgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* , int , long long int , const __half* , int , long long int , const float* , float* , int , long long int , int );
	if (!lcublasHSSgemvStridedBatched) {
		lcublasHSSgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __half* , int , long long int , const __half* , int , long long int , const float* , float* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasHSSgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasHSSgemvStridedBatched] = std::string("cublasHSSgemvStridedBatched");
	}
	assert(lcublasHSSgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSSgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSSgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasHSSgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __half*  A, int64_t  lda, long long int  strideA, const __half*  x, int64_t  incx, long long int  stridex, const float*  beta, float*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHSSgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t );
	if (!lcublasHSSgemvStridedBatched_64) {
		lcublasHSSgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasHSSgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasHSSgemvStridedBatched_64] = std::string("cublasHSSgemvStridedBatched_64");
	}
	assert(lcublasHSSgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHSSgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHSSgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasTSTgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __nv_bfloat16*  A, int  lda, long long int  strideA, const __nv_bfloat16*  x, int  incx, long long int  stridex, const float*  beta, __nv_bfloat16*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasTSTgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* , int , long long int , const __nv_bfloat16* , int , long long int , const float* , __nv_bfloat16* , int , long long int , int );
	if (!lcublasTSTgemvStridedBatched) {
		lcublasTSTgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* , int , long long int , const __nv_bfloat16* , int , long long int , const float* , __nv_bfloat16* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasTSTgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasTSTgemvStridedBatched] = std::string("cublasTSTgemvStridedBatched");
	}
	assert(lcublasTSTgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSTgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSTgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasTSTgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __nv_bfloat16*  A, int64_t  lda, long long int  strideA, const __nv_bfloat16*  x, int64_t  incx, long long int  stridex, const float*  beta, __nv_bfloat16*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasTSTgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* , int64_t , long long int , const __nv_bfloat16* , int64_t , long long int , const float* , __nv_bfloat16* , int64_t , long long int , int64_t );
	if (!lcublasTSTgemvStridedBatched_64) {
		lcublasTSTgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* , int64_t , long long int , const __nv_bfloat16* , int64_t , long long int , const float* , __nv_bfloat16* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasTSTgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasTSTgemvStridedBatched_64] = std::string("cublasTSTgemvStridedBatched_64");
	}
	assert(lcublasTSTgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSTgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSTgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasTSSgemvStridedBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, const float*  alpha, const __nv_bfloat16*  A, int  lda, long long int  strideA, const __nv_bfloat16*  x, int  incx, long long int  stridex, const float*  beta, float*  y, int  incy, long long int  stridey, int  batchCount)
{
	static cublasStatus_t (*lcublasTSSgemvStridedBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* , int , long long int , const __nv_bfloat16* , int , long long int , const float* , float* , int , long long int , int );
	if (!lcublasTSSgemvStridedBatched) {
		lcublasTSSgemvStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* , const __nv_bfloat16* , int , long long int , const __nv_bfloat16* , int , long long int , const float* , float* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasTSSgemvStridedBatched");
		tracer._kernel_map[(void *) lcublasTSSgemvStridedBatched] = std::string("cublasTSSgemvStridedBatched");
	}
	assert(lcublasTSSgemvStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSSgemvStridedBatched(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSSgemvStridedBatched);
	}
	return res;
}

cublasStatus_t cublasTSSgemvStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  trans, int64_t  m, int64_t  n, const float*  alpha, const __nv_bfloat16*  A, int64_t  lda, long long int  strideA, const __nv_bfloat16*  x, int64_t  incx, long long int  stridex, const float*  beta, float*  y, int64_t  incy, long long int  stridey, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasTSSgemvStridedBatched_64) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* , int64_t , long long int , const __nv_bfloat16* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t );
	if (!lcublasTSSgemvStridedBatched_64) {
		lcublasTSSgemvStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int64_t , int64_t , const float* , const __nv_bfloat16* , int64_t , long long int , const __nv_bfloat16* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasTSSgemvStridedBatched_64");
		tracer._kernel_map[(void *) lcublasTSSgemvStridedBatched_64] = std::string("cublasTSSgemvStridedBatched_64");
	}
	assert(lcublasTSSgemvStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasTSSgemvStridedBatched_64(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasTSSgemvStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasSgemm_v2(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const float*  alpha, const float*  A, int  lda, const float*  B, int  ldb, const float*  beta, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSgemm_v2) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSgemm_v2) {
		lcublasSgemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSgemm_v2");
		tracer._kernel_map[(void *) lcublasSgemm_v2] = std::string("cublasSgemm_v2");
	}
	assert(lcublasSgemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemm_v2(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemm_v2);
	}
	return res;
}

cublasStatus_t cublasSgemm_v2_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, const float*  B, int64_t  ldb, const float*  beta, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSgemm_v2_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSgemm_v2_64) {
		lcublasSgemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSgemm_v2_64");
		tracer._kernel_map[(void *) lcublasSgemm_v2_64] = std::string("cublasSgemm_v2_64");
	}
	assert(lcublasSgemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemm_v2_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasDgemm_v2(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const double*  alpha, const double*  A, int  lda, const double*  B, int  ldb, const double*  beta, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDgemm_v2) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDgemm_v2) {
		lcublasDgemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDgemm_v2");
		tracer._kernel_map[(void *) lcublasDgemm_v2] = std::string("cublasDgemm_v2");
	}
	assert(lcublasDgemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemm_v2(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemm_v2);
	}
	return res;
}

cublasStatus_t cublasDgemm_v2_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, const double*  B, int64_t  ldb, const double*  beta, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDgemm_v2_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDgemm_v2_64) {
		lcublasDgemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDgemm_v2_64");
		tracer._kernel_map[(void *) lcublasDgemm_v2_64] = std::string("cublasDgemm_v2_64");
	}
	assert(lcublasDgemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemm_v2_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgemm_v2(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCgemm_v2) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCgemm_v2) {
		lcublasCgemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgemm_v2");
		tracer._kernel_map[(void *) lcublasCgemm_v2] = std::string("cublasCgemm_v2");
	}
	assert(lcublasCgemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm_v2(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm_v2);
	}
	return res;
}

cublasStatus_t cublasCgemm_v2_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCgemm_v2_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCgemm_v2_64) {
		lcublasCgemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgemm_v2_64");
		tracer._kernel_map[(void *) lcublasCgemm_v2_64] = std::string("cublasCgemm_v2_64");
	}
	assert(lcublasCgemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm_v2_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasCgemm3m(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCgemm3m) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCgemm3m) {
		lcublasCgemm3m = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgemm3m");
		tracer._kernel_map[(void *) lcublasCgemm3m] = std::string("cublasCgemm3m");
	}
	assert(lcublasCgemm3m);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3m(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3m);
	}
	return res;
}

cublasStatus_t cublasCgemm3m_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCgemm3m_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCgemm3m_64) {
		lcublasCgemm3m_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgemm3m_64");
		tracer._kernel_map[(void *) lcublasCgemm3m_64] = std::string("cublasCgemm3m_64");
	}
	assert(lcublasCgemm3m_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3m_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3m_64);
	}
	return res;
}

cublasStatus_t cublasCgemm3mEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int  lda, const void*  B, cudaDataType  Btype, int  ldb, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCgemm3mEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const void* , cudaDataType , int , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int );
	if (!lcublasCgemm3mEx) {
		lcublasCgemm3mEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const void* , cudaDataType , int , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCgemm3mEx");
		tracer._kernel_map[(void *) lcublasCgemm3mEx] = std::string("cublasCgemm3mEx");
	}
	assert(lcublasCgemm3mEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mEx);
	}
	return res;
}

cublasStatus_t cublasCgemm3mEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const void*  B, cudaDataType  Btype, int64_t  ldb, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCgemm3mEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t );
	if (!lcublasCgemm3mEx_64) {
		lcublasCgemm3mEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCgemm3mEx_64");
		tracer._kernel_map[(void *) lcublasCgemm3mEx_64] = std::string("cublasCgemm3mEx_64");
	}
	assert(lcublasCgemm3mEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mEx_64(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mEx_64);
	}
	return res;
}

cublasStatus_t cublasZgemm_v2(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZgemm_v2) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZgemm_v2) {
		lcublasZgemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgemm_v2");
		tracer._kernel_map[(void *) lcublasZgemm_v2] = std::string("cublasZgemm_v2");
	}
	assert(lcublasZgemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemm_v2(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemm_v2);
	}
	return res;
}

cublasStatus_t cublasZgemm_v2_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZgemm_v2_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZgemm_v2_64) {
		lcublasZgemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgemm_v2_64");
		tracer._kernel_map[(void *) lcublasZgemm_v2_64] = std::string("cublasZgemm_v2_64");
	}
	assert(lcublasZgemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemm_v2_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasZgemm3m(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZgemm3m) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZgemm3m) {
		lcublasZgemm3m = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgemm3m");
		tracer._kernel_map[(void *) lcublasZgemm3m] = std::string("cublasZgemm3m");
	}
	assert(lcublasZgemm3m);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemm3m(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemm3m);
	}
	return res;
}

cublasStatus_t cublasZgemm3m_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZgemm3m_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZgemm3m_64) {
		lcublasZgemm3m_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgemm3m_64");
		tracer._kernel_map[(void *) lcublasZgemm3m_64] = std::string("cublasZgemm3m_64");
	}
	assert(lcublasZgemm3m_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemm3m_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemm3m_64);
	}
	return res;
}

cublasStatus_t cublasHgemm(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const __half*  alpha, const __half*  A, int  lda, const __half*  B, int  ldb, const __half*  beta, __half*  C, int  ldc)
{
	static cublasStatus_t (*lcublasHgemm) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* , int , const __half* , int , const __half* , __half* , int );
	if (!lcublasHgemm) {
		lcublasHgemm = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* , int , const __half* , int , const __half* , __half* , int )) dlsym(RTLD_NEXT, "cublasHgemm");
		tracer._kernel_map[(void *) lcublasHgemm] = std::string("cublasHgemm");
	}
	assert(lcublasHgemm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemm(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemm);
	}
	return res;
}

cublasStatus_t cublasHgemm_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const __half*  alpha, const __half*  A, int64_t  lda, const __half*  B, int64_t  ldb, const __half*  beta, __half*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasHgemm_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* , int64_t , const __half* , int64_t , const __half* , __half* , int64_t );
	if (!lcublasHgemm_64) {
		lcublasHgemm_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* , int64_t , const __half* , int64_t , const __half* , __half* , int64_t )) dlsym(RTLD_NEXT, "cublasHgemm_64");
		tracer._kernel_map[(void *) lcublasHgemm_64] = std::string("cublasHgemm_64");
	}
	assert(lcublasHgemm_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemm_64(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemm_64);
	}
	return res;
}

cublasStatus_t cublasSgemmEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const float*  alpha, const void*  A, cudaDataType  Atype, int  lda, const void*  B, cudaDataType  Btype, int  ldb, const float*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasSgemmEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const void* , cudaDataType , int , const void* , cudaDataType , int , const float* , void* , cudaDataType , int );
	if (!lcublasSgemmEx) {
		lcublasSgemmEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const void* , cudaDataType , int , const void* , cudaDataType , int , const float* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasSgemmEx");
		tracer._kernel_map[(void *) lcublasSgemmEx] = std::string("cublasSgemmEx");
	}
	assert(lcublasSgemmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmEx);
	}
	return res;
}

cublasStatus_t cublasSgemmEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const float*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const void*  B, cudaDataType  Btype, int64_t  ldb, const float*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSgemmEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t );
	if (!lcublasSgemmEx_64) {
		lcublasSgemmEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasSgemmEx_64");
		tracer._kernel_map[(void *) lcublasSgemmEx_64] = std::string("cublasSgemmEx_64");
	}
	assert(lcublasSgemmEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmEx_64(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmEx_64);
	}
	return res;
}

cublasStatus_t cublasGemmEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const void*  alpha, const void*  A, cudaDataType  Atype, int  lda, const void*  B, cudaDataType  Btype, int  ldb, const void*  beta, void*  C, cudaDataType  Ctype, int  ldc, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* , cudaDataType , int , const void* , cudaDataType , int , const void* , void* , cudaDataType , int , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmEx) {
		lcublasGemmEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* , cudaDataType , int , const void* , cudaDataType , int , const void* , void* , cudaDataType , int , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmEx");
		tracer._kernel_map[(void *) lcublasGemmEx] = std::string("cublasGemmEx");
	}
	assert(lcublasGemmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmEx);
	}
	return res;
}

cublasStatus_t cublasGemmEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const void*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const void*  B, cudaDataType  Btype, int64_t  ldb, const void*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const void* , void* , cudaDataType , int64_t , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmEx_64) {
		lcublasGemmEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const void* , void* , cudaDataType , int64_t , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmEx_64");
		tracer._kernel_map[(void *) lcublasGemmEx_64] = std::string("cublasGemmEx_64");
	}
	assert(lcublasGemmEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmEx_64(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmEx_64);
	}
	return res;
}

cublasStatus_t cublasCgemmEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int  lda, const void*  B, cudaDataType  Btype, int  ldb, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCgemmEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const void* , cudaDataType , int , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int );
	if (!lcublasCgemmEx) {
		lcublasCgemmEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const void* , cudaDataType , int , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCgemmEx");
		tracer._kernel_map[(void *) lcublasCgemmEx] = std::string("cublasCgemmEx");
	}
	assert(lcublasCgemmEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmEx);
	}
	return res;
}

cublasStatus_t cublasCgemmEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const void*  B, cudaDataType  Btype, int64_t  ldb, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCgemmEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t );
	if (!lcublasCgemmEx_64) {
		lcublasCgemmEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCgemmEx_64");
		tracer._kernel_map[(void *) lcublasCgemmEx_64] = std::string("cublasCgemmEx_64");
	}
	assert(lcublasCgemmEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmEx_64(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmEx_64);
	}
	return res;
}

cublasStatus_t cublasSsyrk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const float*  A, int  lda, const float*  beta, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSsyrk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , float* , int );
	if (!lcublasSsyrk_v2) {
		lcublasSsyrk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsyrk_v2");
		tracer._kernel_map[(void *) lcublasSsyrk_v2] = std::string("cublasSsyrk_v2");
	}
	assert(lcublasSsyrk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyrk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyrk_v2);
	}
	return res;
}

cublasStatus_t cublasSsyrk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, const float*  beta, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSsyrk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsyrk_v2_64) {
		lcublasSsyrk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsyrk_v2_64");
		tracer._kernel_map[(void *) lcublasSsyrk_v2_64] = std::string("cublasSsyrk_v2_64");
	}
	assert(lcublasSsyrk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyrk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyrk_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsyrk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const double*  alpha, const double*  A, int  lda, const double*  beta, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDsyrk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , double* , int );
	if (!lcublasDsyrk_v2) {
		lcublasDsyrk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsyrk_v2");
		tracer._kernel_map[(void *) lcublasDsyrk_v2] = std::string("cublasDsyrk_v2");
	}
	assert(lcublasDsyrk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyrk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyrk_v2);
	}
	return res;
}

cublasStatus_t cublasDsyrk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, const double*  beta, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDsyrk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsyrk_v2_64) {
		lcublasDsyrk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsyrk_v2_64");
		tracer._kernel_map[(void *) lcublasDsyrk_v2_64] = std::string("cublasDsyrk_v2_64");
	}
	assert(lcublasDsyrk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyrk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyrk_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsyrk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCsyrk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCsyrk_v2) {
		lcublasCsyrk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsyrk_v2");
		tracer._kernel_map[(void *) lcublasCsyrk_v2] = std::string("cublasCsyrk_v2");
	}
	assert(lcublasCsyrk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrk_v2);
	}
	return res;
}

cublasStatus_t cublasCsyrk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsyrk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCsyrk_v2_64) {
		lcublasCsyrk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsyrk_v2_64");
		tracer._kernel_map[(void *) lcublasCsyrk_v2_64] = std::string("cublasCsyrk_v2_64");
	}
	assert(lcublasCsyrk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrk_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsyrk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZsyrk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZsyrk_v2) {
		lcublasZsyrk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsyrk_v2");
		tracer._kernel_map[(void *) lcublasZsyrk_v2] = std::string("cublasZsyrk_v2");
	}
	assert(lcublasZsyrk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyrk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyrk_v2);
	}
	return res;
}

cublasStatus_t cublasZsyrk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZsyrk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZsyrk_v2_64) {
		lcublasZsyrk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsyrk_v2_64");
		tracer._kernel_map[(void *) lcublasZsyrk_v2_64] = std::string("cublasZsyrk_v2_64");
	}
	assert(lcublasZsyrk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyrk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyrk_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsyrkEx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int  lda, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCsyrkEx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int );
	if (!lcublasCsyrkEx) {
		lcublasCsyrkEx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCsyrkEx");
		tracer._kernel_map[(void *) lcublasCsyrkEx] = std::string("cublasCsyrkEx");
	}
	assert(lcublasCsyrkEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrkEx(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrkEx);
	}
	return res;
}

cublasStatus_t cublasCsyrkEx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsyrkEx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t );
	if (!lcublasCsyrkEx_64) {
		lcublasCsyrkEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCsyrkEx_64");
		tracer._kernel_map[(void *) lcublasCsyrkEx_64] = std::string("cublasCsyrkEx_64");
	}
	assert(lcublasCsyrkEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrkEx_64(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrkEx_64);
	}
	return res;
}

cublasStatus_t cublasCsyrk3mEx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int  lda, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCsyrk3mEx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int );
	if (!lcublasCsyrk3mEx) {
		lcublasCsyrk3mEx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const void* , cudaDataType , int , const cuComplex* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCsyrk3mEx");
		tracer._kernel_map[(void *) lcublasCsyrk3mEx] = std::string("cublasCsyrk3mEx");
	}
	assert(lcublasCsyrk3mEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrk3mEx(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrk3mEx);
	}
	return res;
}

cublasStatus_t cublasCsyrk3mEx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const cuComplex*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsyrk3mEx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t );
	if (!lcublasCsyrk3mEx_64) {
		lcublasCsyrk3mEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const void* , cudaDataType , int64_t , const cuComplex* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCsyrk3mEx_64");
		tracer._kernel_map[(void *) lcublasCsyrk3mEx_64] = std::string("cublasCsyrk3mEx_64");
	}
	assert(lcublasCsyrk3mEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrk3mEx_64(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrk3mEx_64);
	}
	return res;
}

cublasStatus_t cublasCherk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const cuComplex*  A, int  lda, const float*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCherk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const cuComplex* , int , const float* , cuComplex* , int );
	if (!lcublasCherk_v2) {
		lcublasCherk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const cuComplex* , int , const float* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCherk_v2");
		tracer._kernel_map[(void *) lcublasCherk_v2] = std::string("cublasCherk_v2");
	}
	assert(lcublasCherk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherk_v2);
	}
	return res;
}

cublasStatus_t cublasCherk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const cuComplex*  A, int64_t  lda, const float*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCherk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const cuComplex* , int64_t , const float* , cuComplex* , int64_t );
	if (!lcublasCherk_v2_64) {
		lcublasCherk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const cuComplex* , int64_t , const float* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCherk_v2_64");
		tracer._kernel_map[(void *) lcublasCherk_v2_64] = std::string("cublasCherk_v2_64");
	}
	assert(lcublasCherk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherk_v2_64);
	}
	return res;
}

cublasStatus_t cublasZherk_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const double*  alpha, const cuDoubleComplex*  A, int  lda, const double*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZherk_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int );
	if (!lcublasZherk_v2) {
		lcublasZherk_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZherk_v2");
		tracer._kernel_map[(void *) lcublasZherk_v2] = std::string("cublasZherk_v2");
	}
	assert(lcublasZherk_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZherk_v2(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZherk_v2);
	}
	return res;
}

cublasStatus_t cublasZherk_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const double*  alpha, const cuDoubleComplex*  A, int64_t  lda, const double*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZherk_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t );
	if (!lcublasZherk_v2_64) {
		lcublasZherk_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZherk_v2_64");
		tracer._kernel_map[(void *) lcublasZherk_v2_64] = std::string("cublasZherk_v2_64");
	}
	assert(lcublasZherk_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZherk_v2_64(handle, uplo, trans, n, k, alpha, A, lda, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZherk_v2_64);
	}
	return res;
}

cublasStatus_t cublasCherkEx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const void*  A, cudaDataType  Atype, int  lda, const float*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCherkEx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const void* , cudaDataType , int , const float* , void* , cudaDataType , int );
	if (!lcublasCherkEx) {
		lcublasCherkEx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const void* , cudaDataType , int , const float* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCherkEx");
		tracer._kernel_map[(void *) lcublasCherkEx] = std::string("cublasCherkEx");
	}
	assert(lcublasCherkEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherkEx(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherkEx);
	}
	return res;
}

cublasStatus_t cublasCherkEx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const float*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCherkEx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t );
	if (!lcublasCherkEx_64) {
		lcublasCherkEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCherkEx_64");
		tracer._kernel_map[(void *) lcublasCherkEx_64] = std::string("cublasCherkEx_64");
	}
	assert(lcublasCherkEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherkEx_64(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherkEx_64);
	}
	return res;
}

cublasStatus_t cublasCherk3mEx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const void*  A, cudaDataType  Atype, int  lda, const float*  beta, void*  C, cudaDataType  Ctype, int  ldc)
{
	static cublasStatus_t (*lcublasCherk3mEx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const void* , cudaDataType , int , const float* , void* , cudaDataType , int );
	if (!lcublasCherk3mEx) {
		lcublasCherk3mEx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const void* , cudaDataType , int , const float* , void* , cudaDataType , int )) dlsym(RTLD_NEXT, "cublasCherk3mEx");
		tracer._kernel_map[(void *) lcublasCherk3mEx] = std::string("cublasCherk3mEx");
	}
	assert(lcublasCherk3mEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherk3mEx(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherk3mEx);
	}
	return res;
}

cublasStatus_t cublasCherk3mEx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, const float*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCherk3mEx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t );
	if (!lcublasCherk3mEx_64) {
		lcublasCherk3mEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const void* , cudaDataType , int64_t , const float* , void* , cudaDataType , int64_t )) dlsym(RTLD_NEXT, "cublasCherk3mEx_64");
		tracer._kernel_map[(void *) lcublasCherk3mEx_64] = std::string("cublasCherk3mEx_64");
	}
	assert(lcublasCherk3mEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherk3mEx_64(handle, uplo, trans, n, k, alpha, A, Atype, lda, beta, C, Ctype, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherk3mEx_64);
	}
	return res;
}

cublasStatus_t cublasSsyr2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const float*  A, int  lda, const float*  B, int  ldb, const float*  beta, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSsyr2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSsyr2k_v2) {
		lcublasSsyr2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsyr2k_v2");
		tracer._kernel_map[(void *) lcublasSsyr2k_v2] = std::string("cublasSsyr2k_v2");
	}
	assert(lcublasSsyr2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr2k_v2);
	}
	return res;
}

cublasStatus_t cublasSsyr2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, const float*  B, int64_t  ldb, const float*  beta, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSsyr2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsyr2k_v2_64) {
		lcublasSsyr2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsyr2k_v2_64");
		tracer._kernel_map[(void *) lcublasSsyr2k_v2_64] = std::string("cublasSsyr2k_v2_64");
	}
	assert(lcublasSsyr2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyr2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyr2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsyr2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const double*  alpha, const double*  A, int  lda, const double*  B, int  ldb, const double*  beta, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDsyr2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDsyr2k_v2) {
		lcublasDsyr2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsyr2k_v2");
		tracer._kernel_map[(void *) lcublasDsyr2k_v2] = std::string("cublasDsyr2k_v2");
	}
	assert(lcublasDsyr2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr2k_v2);
	}
	return res;
}

cublasStatus_t cublasDsyr2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, const double*  B, int64_t  ldb, const double*  beta, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDsyr2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsyr2k_v2_64) {
		lcublasDsyr2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsyr2k_v2_64");
		tracer._kernel_map[(void *) lcublasDsyr2k_v2_64] = std::string("cublasDsyr2k_v2_64");
	}
	assert(lcublasDsyr2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyr2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyr2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsyr2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCsyr2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCsyr2k_v2) {
		lcublasCsyr2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsyr2k_v2");
		tracer._kernel_map[(void *) lcublasCsyr2k_v2] = std::string("cublasCsyr2k_v2");
	}
	assert(lcublasCsyr2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr2k_v2);
	}
	return res;
}

cublasStatus_t cublasCsyr2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsyr2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCsyr2k_v2_64) {
		lcublasCsyr2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsyr2k_v2_64");
		tracer._kernel_map[(void *) lcublasCsyr2k_v2_64] = std::string("cublasCsyr2k_v2_64");
	}
	assert(lcublasCsyr2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyr2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyr2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsyr2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZsyr2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZsyr2k_v2) {
		lcublasZsyr2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsyr2k_v2");
		tracer._kernel_map[(void *) lcublasZsyr2k_v2] = std::string("cublasZsyr2k_v2");
	}
	assert(lcublasZsyr2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr2k_v2);
	}
	return res;
}

cublasStatus_t cublasZsyr2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZsyr2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZsyr2k_v2_64) {
		lcublasZsyr2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsyr2k_v2_64");
		tracer._kernel_map[(void *) lcublasZsyr2k_v2_64] = std::string("cublasZsyr2k_v2_64");
	}
	assert(lcublasZsyr2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyr2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyr2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasCher2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const float*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCher2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const float* , cuComplex* , int );
	if (!lcublasCher2k_v2) {
		lcublasCher2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const float* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCher2k_v2");
		tracer._kernel_map[(void *) lcublasCher2k_v2] = std::string("cublasCher2k_v2");
	}
	assert(lcublasCher2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher2k_v2);
	}
	return res;
}

cublasStatus_t cublasCher2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const float*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCher2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const float* , cuComplex* , int64_t );
	if (!lcublasCher2k_v2_64) {
		lcublasCher2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const float* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCher2k_v2_64");
		tracer._kernel_map[(void *) lcublasCher2k_v2_64] = std::string("cublasCher2k_v2_64");
	}
	assert(lcublasCher2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCher2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCher2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasZher2k_v2(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const double*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZher2k_v2) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int );
	if (!lcublasZher2k_v2) {
		lcublasZher2k_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZher2k_v2");
		tracer._kernel_map[(void *) lcublasZher2k_v2] = std::string("cublasZher2k_v2");
	}
	assert(lcublasZher2k_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher2k_v2(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher2k_v2);
	}
	return res;
}

cublasStatus_t cublasZher2k_v2_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const double*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZher2k_v2_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t );
	if (!lcublasZher2k_v2_64) {
		lcublasZher2k_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZher2k_v2_64");
		tracer._kernel_map[(void *) lcublasZher2k_v2_64] = std::string("cublasZher2k_v2_64");
	}
	assert(lcublasZher2k_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZher2k_v2_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZher2k_v2_64);
	}
	return res;
}

cublasStatus_t cublasSsyrkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const float*  alpha, const float*  A, int  lda, const float*  B, int  ldb, const float*  beta, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSsyrkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSsyrkx) {
		lcublasSsyrkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsyrkx");
		tracer._kernel_map[(void *) lcublasSsyrkx] = std::string("cublasSsyrkx");
	}
	assert(lcublasSsyrkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyrkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyrkx);
	}
	return res;
}

cublasStatus_t cublasSsyrkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, const float*  B, int64_t  ldb, const float*  beta, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSsyrkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsyrkx_64) {
		lcublasSsyrkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsyrkx_64");
		tracer._kernel_map[(void *) lcublasSsyrkx_64] = std::string("cublasSsyrkx_64");
	}
	assert(lcublasSsyrkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsyrkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsyrkx_64);
	}
	return res;
}

cublasStatus_t cublasDsyrkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const double*  alpha, const double*  A, int  lda, const double*  B, int  ldb, const double*  beta, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDsyrkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDsyrkx) {
		lcublasDsyrkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsyrkx");
		tracer._kernel_map[(void *) lcublasDsyrkx] = std::string("cublasDsyrkx");
	}
	assert(lcublasDsyrkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyrkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyrkx);
	}
	return res;
}

cublasStatus_t cublasDsyrkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, const double*  B, int64_t  ldb, const double*  beta, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDsyrkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsyrkx_64) {
		lcublasDsyrkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsyrkx_64");
		tracer._kernel_map[(void *) lcublasDsyrkx_64] = std::string("cublasDsyrkx_64");
	}
	assert(lcublasDsyrkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsyrkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsyrkx_64);
	}
	return res;
}

cublasStatus_t cublasCsyrkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCsyrkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCsyrkx) {
		lcublasCsyrkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsyrkx");
		tracer._kernel_map[(void *) lcublasCsyrkx] = std::string("cublasCsyrkx");
	}
	assert(lcublasCsyrkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrkx);
	}
	return res;
}

cublasStatus_t cublasCsyrkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsyrkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCsyrkx_64) {
		lcublasCsyrkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsyrkx_64");
		tracer._kernel_map[(void *) lcublasCsyrkx_64] = std::string("cublasCsyrkx_64");
	}
	assert(lcublasCsyrkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsyrkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsyrkx_64);
	}
	return res;
}

cublasStatus_t cublasZsyrkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZsyrkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZsyrkx) {
		lcublasZsyrkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsyrkx");
		tracer._kernel_map[(void *) lcublasZsyrkx] = std::string("cublasZsyrkx");
	}
	assert(lcublasZsyrkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyrkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyrkx);
	}
	return res;
}

cublasStatus_t cublasZsyrkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZsyrkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZsyrkx_64) {
		lcublasZsyrkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsyrkx_64");
		tracer._kernel_map[(void *) lcublasZsyrkx_64] = std::string("cublasZsyrkx_64");
	}
	assert(lcublasZsyrkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsyrkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsyrkx_64);
	}
	return res;
}

cublasStatus_t cublasCherkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const float*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCherkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const float* , cuComplex* , int );
	if (!lcublasCherkx) {
		lcublasCherkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const float* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCherkx");
		tracer._kernel_map[(void *) lcublasCherkx] = std::string("cublasCherkx");
	}
	assert(lcublasCherkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherkx);
	}
	return res;
}

cublasStatus_t cublasCherkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const float*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCherkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const float* , cuComplex* , int64_t );
	if (!lcublasCherkx_64) {
		lcublasCherkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const float* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCherkx_64");
		tracer._kernel_map[(void *) lcublasCherkx_64] = std::string("cublasCherkx_64");
	}
	assert(lcublasCherkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCherkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCherkx_64);
	}
	return res;
}

cublasStatus_t cublasZherkx(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const double*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZherkx) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int );
	if (!lcublasZherkx) {
		lcublasZherkx = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const double* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZherkx");
		tracer._kernel_map[(void *) lcublasZherkx] = std::string("cublasZherkx");
	}
	assert(lcublasZherkx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZherkx(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZherkx);
	}
	return res;
}

cublasStatus_t cublasZherkx_64(cublasHandle_t  handle, cublasFillMode_t  uplo, cublasOperation_t  trans, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const double*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZherkx_64) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t );
	if (!lcublasZherkx_64) {
		lcublasZherkx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const double* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZherkx_64");
		tracer._kernel_map[(void *) lcublasZherkx_64] = std::string("cublasZherkx_64");
	}
	assert(lcublasZherkx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZherkx_64(handle, uplo, trans, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZherkx_64);
	}
	return res;
}

cublasStatus_t cublasSsymm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const float*  alpha, const float*  A, int  lda, const float*  B, int  ldb, const float*  beta, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSsymm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int );
	if (!lcublasSsymm_v2) {
		lcublasSsymm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const float* , const float* , int , const float* , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasSsymm_v2");
		tracer._kernel_map[(void *) lcublasSsymm_v2] = std::string("cublasSsymm_v2");
	}
	assert(lcublasSsymm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsymm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsymm_v2);
	}
	return res;
}

cublasStatus_t cublasSsymm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, const float*  B, int64_t  ldb, const float*  beta, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSsymm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t );
	if (!lcublasSsymm_v2_64) {
		lcublasSsymm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , const float* , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSsymm_v2_64");
		tracer._kernel_map[(void *) lcublasSsymm_v2_64] = std::string("cublasSsymm_v2_64");
	}
	assert(lcublasSsymm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSsymm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSsymm_v2_64);
	}
	return res;
}

cublasStatus_t cublasDsymm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const double*  alpha, const double*  A, int  lda, const double*  B, int  ldb, const double*  beta, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDsymm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int );
	if (!lcublasDsymm_v2) {
		lcublasDsymm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const double* , const double* , int , const double* , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDsymm_v2");
		tracer._kernel_map[(void *) lcublasDsymm_v2] = std::string("cublasDsymm_v2");
	}
	assert(lcublasDsymm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsymm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsymm_v2);
	}
	return res;
}

cublasStatus_t cublasDsymm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, const double*  B, int64_t  ldb, const double*  beta, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDsymm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t );
	if (!lcublasDsymm_v2_64) {
		lcublasDsymm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , const double* , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDsymm_v2_64");
		tracer._kernel_map[(void *) lcublasDsymm_v2_64] = std::string("cublasDsymm_v2_64");
	}
	assert(lcublasDsymm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDsymm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDsymm_v2_64);
	}
	return res;
}

cublasStatus_t cublasCsymm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCsymm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCsymm_v2) {
		lcublasCsymm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCsymm_v2");
		tracer._kernel_map[(void *) lcublasCsymm_v2] = std::string("cublasCsymm_v2");
	}
	assert(lcublasCsymm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsymm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsymm_v2);
	}
	return res;
}

cublasStatus_t cublasCsymm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCsymm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasCsymm_v2_64) {
		lcublasCsymm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCsymm_v2_64");
		tracer._kernel_map[(void *) lcublasCsymm_v2_64] = std::string("cublasCsymm_v2_64");
	}
	assert(lcublasCsymm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCsymm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCsymm_v2_64);
	}
	return res;
}

cublasStatus_t cublasZsymm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZsymm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZsymm_v2) {
		lcublasZsymm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZsymm_v2");
		tracer._kernel_map[(void *) lcublasZsymm_v2] = std::string("cublasZsymm_v2");
	}
	assert(lcublasZsymm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsymm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsymm_v2);
	}
	return res;
}

cublasStatus_t cublasZsymm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZsymm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZsymm_v2_64) {
		lcublasZsymm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZsymm_v2_64");
		tracer._kernel_map[(void *) lcublasZsymm_v2_64] = std::string("cublasZsymm_v2_64");
	}
	assert(lcublasZsymm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZsymm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZsymm_v2_64);
	}
	return res;
}

cublasStatus_t cublasChemm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, const cuComplex*  beta, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasChemm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int );
	if (!lcublasChemm_v2) {
		lcublasChemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasChemm_v2");
		tracer._kernel_map[(void *) lcublasChemm_v2] = std::string("cublasChemm_v2");
	}
	assert(lcublasChemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChemm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChemm_v2);
	}
	return res;
}

cublasStatus_t cublasChemm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, const cuComplex*  beta, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasChemm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t );
	if (!lcublasChemm_v2_64) {
		lcublasChemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , const cuComplex* , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasChemm_v2_64");
		tracer._kernel_map[(void *) lcublasChemm_v2_64] = std::string("cublasChemm_v2_64");
	}
	assert(lcublasChemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasChemm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasChemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasZhemm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZhemm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZhemm_v2) {
		lcublasZhemm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZhemm_v2");
		tracer._kernel_map[(void *) lcublasZhemm_v2] = std::string("cublasZhemm_v2");
	}
	assert(lcublasZhemm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhemm_v2(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhemm_v2);
	}
	return res;
}

cublasStatus_t cublasZhemm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZhemm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t );
	if (!lcublasZhemm_v2_64) {
		lcublasZhemm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZhemm_v2_64");
		tracer._kernel_map[(void *) lcublasZhemm_v2_64] = std::string("cublasZhemm_v2_64");
	}
	assert(lcublasZhemm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZhemm_v2_64(handle, side, uplo, m, n, alpha, A, lda, B, ldb, beta, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZhemm_v2_64);
	}
	return res;
}

cublasStatus_t cublasStrsm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const float*  alpha, const float*  A, int  lda, float*  B, int  ldb)
{
	static cublasStatus_t (*lcublasStrsm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* , int , float* , int );
	if (!lcublasStrsm_v2) {
		lcublasStrsm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStrsm_v2");
		tracer._kernel_map[(void *) lcublasStrsm_v2] = std::string("cublasStrsm_v2");
	}
	assert(lcublasStrsm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsm_v2);
	}
	return res;
}

cublasStatus_t cublasStrsm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, float*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasStrsm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* , int64_t , float* , int64_t );
	if (!lcublasStrsm_v2_64) {
		lcublasStrsm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStrsm_v2_64");
		tracer._kernel_map[(void *) lcublasStrsm_v2_64] = std::string("cublasStrsm_v2_64");
	}
	assert(lcublasStrsm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsm_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtrsm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const double*  alpha, const double*  A, int  lda, double*  B, int  ldb)
{
	static cublasStatus_t (*lcublasDtrsm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* , int , double* , int );
	if (!lcublasDtrsm_v2) {
		lcublasDtrsm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtrsm_v2");
		tracer._kernel_map[(void *) lcublasDtrsm_v2] = std::string("cublasDtrsm_v2");
	}
	assert(lcublasDtrsm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsm_v2);
	}
	return res;
}

cublasStatus_t cublasDtrsm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, double*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasDtrsm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* , int64_t , double* , int64_t );
	if (!lcublasDtrsm_v2_64) {
		lcublasDtrsm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtrsm_v2_64");
		tracer._kernel_map[(void *) lcublasDtrsm_v2_64] = std::string("cublasDtrsm_v2_64");
	}
	assert(lcublasDtrsm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsm_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtrsm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, cuComplex*  B, int  ldb)
{
	static cublasStatus_t (*lcublasCtrsm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtrsm_v2) {
		lcublasCtrsm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtrsm_v2");
		tracer._kernel_map[(void *) lcublasCtrsm_v2] = std::string("cublasCtrsm_v2");
	}
	assert(lcublasCtrsm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsm_v2);
	}
	return res;
}

cublasStatus_t cublasCtrsm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, cuComplex*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasCtrsm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtrsm_v2_64) {
		lcublasCtrsm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtrsm_v2_64");
		tracer._kernel_map[(void *) lcublasCtrsm_v2_64] = std::string("cublasCtrsm_v2_64");
	}
	assert(lcublasCtrsm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsm_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtrsm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  B, int  ldb)
{
	static cublasStatus_t (*lcublasZtrsm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtrsm_v2) {
		lcublasZtrsm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtrsm_v2");
		tracer._kernel_map[(void *) lcublasZtrsm_v2] = std::string("cublasZtrsm_v2");
	}
	assert(lcublasZtrsm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsm_v2);
	}
	return res;
}

cublasStatus_t cublasZtrsm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, cuDoubleComplex*  B, int64_t  ldb)
{
	static cublasStatus_t (*lcublasZtrsm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtrsm_v2_64) {
		lcublasZtrsm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtrsm_v2_64");
		tracer._kernel_map[(void *) lcublasZtrsm_v2_64] = std::string("cublasZtrsm_v2_64");
	}
	assert(lcublasZtrsm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsm_v2_64);
	}
	return res;
}

cublasStatus_t cublasStrmm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const float*  alpha, const float*  A, int  lda, const float*  B, int  ldb, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasStrmm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* , int , const float* , int , float* , int );
	if (!lcublasStrmm_v2) {
		lcublasStrmm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasStrmm_v2");
		tracer._kernel_map[(void *) lcublasStrmm_v2] = std::string("cublasStrmm_v2");
	}
	assert(lcublasStrmm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrmm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrmm_v2);
	}
	return res;
}

cublasStatus_t cublasStrmm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, const float*  B, int64_t  ldb, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasStrmm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasStrmm_v2_64) {
		lcublasStrmm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasStrmm_v2_64");
		tracer._kernel_map[(void *) lcublasStrmm_v2_64] = std::string("cublasStrmm_v2_64");
	}
	assert(lcublasStrmm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrmm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrmm_v2_64);
	}
	return res;
}

cublasStatus_t cublasDtrmm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const double*  alpha, const double*  A, int  lda, const double*  B, int  ldb, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDtrmm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* , int , const double* , int , double* , int );
	if (!lcublasDtrmm_v2) {
		lcublasDtrmm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDtrmm_v2");
		tracer._kernel_map[(void *) lcublasDtrmm_v2] = std::string("cublasDtrmm_v2");
	}
	assert(lcublasDtrmm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrmm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrmm_v2);
	}
	return res;
}

cublasStatus_t cublasDtrmm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, const double*  B, int64_t  ldb, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDtrmm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDtrmm_v2_64) {
		lcublasDtrmm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDtrmm_v2_64");
		tracer._kernel_map[(void *) lcublasDtrmm_v2_64] = std::string("cublasDtrmm_v2_64");
	}
	assert(lcublasDtrmm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrmm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrmm_v2_64);
	}
	return res;
}

cublasStatus_t cublasCtrmm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  B, int  ldb, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCtrmm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCtrmm_v2) {
		lcublasCtrmm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtrmm_v2");
		tracer._kernel_map[(void *) lcublasCtrmm_v2] = std::string("cublasCtrmm_v2");
	}
	assert(lcublasCtrmm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrmm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrmm_v2);
	}
	return res;
}

cublasStatus_t cublasCtrmm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  B, int64_t  ldb, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCtrmm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCtrmm_v2_64) {
		lcublasCtrmm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCtrmm_v2_64");
		tracer._kernel_map[(void *) lcublasCtrmm_v2_64] = std::string("cublasCtrmm_v2_64");
	}
	assert(lcublasCtrmm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrmm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrmm_v2_64);
	}
	return res;
}

cublasStatus_t cublasZtrmm_v2(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  B, int  ldb, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZtrmm_v2) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZtrmm_v2) {
		lcublasZtrmm_v2 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtrmm_v2");
		tracer._kernel_map[(void *) lcublasZtrmm_v2] = std::string("cublasZtrmm_v2");
	}
	assert(lcublasZtrmm_v2);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrmm_v2(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrmm_v2);
	}
	return res;
}

cublasStatus_t cublasZtrmm_v2_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  B, int64_t  ldb, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZtrmm_v2_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZtrmm_v2_64) {
		lcublasZtrmm_v2_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZtrmm_v2_64");
		tracer._kernel_map[(void *) lcublasZtrmm_v2_64] = std::string("cublasZtrmm_v2_64");
	}
	assert(lcublasZtrmm_v2_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrmm_v2_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrmm_v2_64);
	}
	return res;
}

cublasStatus_t cublasHgemmBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const __half*  alpha, const __half* const  Aarray[], int  lda, const __half* const  Barray[], int  ldb, const __half*  beta, __half* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasHgemmBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* const [], int , const __half* const [], int , const __half* , __half* const [], int , int );
	if (!lcublasHgemmBatched) {
		lcublasHgemmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* const [], int , const __half* const [], int , const __half* , __half* const [], int , int )) dlsym(RTLD_NEXT, "cublasHgemmBatched");
		tracer._kernel_map[(void *) lcublasHgemmBatched] = std::string("cublasHgemmBatched");
	}
	assert(lcublasHgemmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemmBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemmBatched);
	}
	return res;
}

cublasStatus_t cublasHgemmBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const __half*  alpha, const __half* const  Aarray[], int64_t  lda, const __half* const  Barray[], int64_t  ldb, const __half*  beta, __half* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHgemmBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* const [], int64_t , const __half* const [], int64_t , const __half* , __half* const [], int64_t , int64_t );
	if (!lcublasHgemmBatched_64) {
		lcublasHgemmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* const [], int64_t , const __half* const [], int64_t , const __half* , __half* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasHgemmBatched_64");
		tracer._kernel_map[(void *) lcublasHgemmBatched_64] = std::string("cublasHgemmBatched_64");
	}
	assert(lcublasHgemmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemmBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemmBatched_64);
	}
	return res;
}

cublasStatus_t cublasSgemmBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const float*  alpha, const float* const  Aarray[], int  lda, const float* const  Barray[], int  ldb, const float*  beta, float* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasSgemmBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* const [], int , const float* const [], int , const float* , float* const [], int , int );
	if (!lcublasSgemmBatched) {
		lcublasSgemmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* const [], int , const float* const [], int , const float* , float* const [], int , int )) dlsym(RTLD_NEXT, "cublasSgemmBatched");
		tracer._kernel_map[(void *) lcublasSgemmBatched] = std::string("cublasSgemmBatched");
	}
	assert(lcublasSgemmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmBatched);
	}
	return res;
}

cublasStatus_t cublasSgemmBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const float*  alpha, const float* const  Aarray[], int64_t  lda, const float* const  Barray[], int64_t  ldb, const float*  beta, float* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasSgemmBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* const [], int64_t , const float* const [], int64_t , const float* , float* const [], int64_t , int64_t );
	if (!lcublasSgemmBatched_64) {
		lcublasSgemmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* const [], int64_t , const float* const [], int64_t , const float* , float* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasSgemmBatched_64");
		tracer._kernel_map[(void *) lcublasSgemmBatched_64] = std::string("cublasSgemmBatched_64");
	}
	assert(lcublasSgemmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmBatched_64);
	}
	return res;
}

cublasStatus_t cublasDgemmBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const double*  alpha, const double* const  Aarray[], int  lda, const double* const  Barray[], int  ldb, const double*  beta, double* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasDgemmBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* const [], int , const double* const [], int , const double* , double* const [], int , int );
	if (!lcublasDgemmBatched) {
		lcublasDgemmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* const [], int , const double* const [], int , const double* , double* const [], int , int )) dlsym(RTLD_NEXT, "cublasDgemmBatched");
		tracer._kernel_map[(void *) lcublasDgemmBatched] = std::string("cublasDgemmBatched");
	}
	assert(lcublasDgemmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemmBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemmBatched);
	}
	return res;
}

cublasStatus_t cublasDgemmBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const double*  alpha, const double* const  Aarray[], int64_t  lda, const double* const  Barray[], int64_t  ldb, const double*  beta, double* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasDgemmBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* const [], int64_t , const double* const [], int64_t , const double* , double* const [], int64_t , int64_t );
	if (!lcublasDgemmBatched_64) {
		lcublasDgemmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* const [], int64_t , const double* const [], int64_t , const double* , double* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasDgemmBatched_64");
		tracer._kernel_map[(void *) lcublasDgemmBatched_64] = std::string("cublasDgemmBatched_64");
	}
	assert(lcublasDgemmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemmBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemmBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemmBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex* const  Aarray[], int  lda, const cuComplex* const  Barray[], int  ldb, const cuComplex*  beta, cuComplex* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemmBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int );
	if (!lcublasCgemmBatched) {
		lcublasCgemmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasCgemmBatched");
		tracer._kernel_map[(void *) lcublasCgemmBatched] = std::string("cublasCgemmBatched");
	}
	assert(lcublasCgemmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmBatched);
	}
	return res;
}

cublasStatus_t cublasCgemmBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex* const  Aarray[], int64_t  lda, const cuComplex* const  Barray[], int64_t  ldb, const cuComplex*  beta, cuComplex* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemmBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t );
	if (!lcublasCgemmBatched_64) {
		lcublasCgemmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasCgemmBatched_64");
		tracer._kernel_map[(void *) lcublasCgemmBatched_64] = std::string("cublasCgemmBatched_64");
	}
	assert(lcublasCgemmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemm3mBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex* const  Aarray[], int  lda, const cuComplex* const  Barray[], int  ldb, const cuComplex*  beta, cuComplex* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemm3mBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int );
	if (!lcublasCgemm3mBatched) {
		lcublasCgemm3mBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* const [], int , const cuComplex* const [], int , const cuComplex* , cuComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasCgemm3mBatched");
		tracer._kernel_map[(void *) lcublasCgemm3mBatched] = std::string("cublasCgemm3mBatched");
	}
	assert(lcublasCgemm3mBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mBatched);
	}
	return res;
}

cublasStatus_t cublasCgemm3mBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex* const  Aarray[], int64_t  lda, const cuComplex* const  Barray[], int64_t  ldb, const cuComplex*  beta, cuComplex* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemm3mBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t );
	if (!lcublasCgemm3mBatched_64) {
		lcublasCgemm3mBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , const cuComplex* const [], int64_t , const cuComplex* , cuComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasCgemm3mBatched_64");
		tracer._kernel_map[(void *) lcublasCgemm3mBatched_64] = std::string("cublasCgemm3mBatched_64");
	}
	assert(lcublasCgemm3mBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mBatched_64);
	}
	return res;
}

cublasStatus_t cublasZgemmBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  Aarray[], int  lda, const cuDoubleComplex* const  Barray[], int  ldb, const cuDoubleComplex*  beta, cuDoubleComplex* const  Carray[], int  ldc, int  batchCount)
{
	static cublasStatus_t (*lcublasZgemmBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , const cuDoubleComplex* const [], int , const cuDoubleComplex* , cuDoubleComplex* const [], int , int );
	if (!lcublasZgemmBatched) {
		lcublasZgemmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , const cuDoubleComplex* const [], int , const cuDoubleComplex* , cuDoubleComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasZgemmBatched");
		tracer._kernel_map[(void *) lcublasZgemmBatched] = std::string("cublasZgemmBatched");
	}
	assert(lcublasZgemmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemmBatched(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemmBatched);
	}
	return res;
}

cublasStatus_t cublasZgemmBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  Aarray[], int64_t  lda, const cuDoubleComplex* const  Barray[], int64_t  ldb, const cuDoubleComplex*  beta, cuDoubleComplex* const  Carray[], int64_t  ldc, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasZgemmBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* , cuDoubleComplex* const [], int64_t , int64_t );
	if (!lcublasZgemmBatched_64) {
		lcublasZgemmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* const [], int64_t , const cuDoubleComplex* , cuDoubleComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasZgemmBatched_64");
		tracer._kernel_map[(void *) lcublasZgemmBatched_64] = std::string("cublasZgemmBatched_64");
	}
	assert(lcublasZgemmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemmBatched_64(handle, transa, transb, m, n, k, alpha, Aarray, lda, Barray, ldb, beta, Carray, ldc, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemmBatched_64);
	}
	return res;
}

cublasStatus_t cublasHgemmStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const __half*  alpha, const __half*  A, int  lda, long long int  strideA, const __half*  B, int  ldb, long long int  strideB, const __half*  beta, __half*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasHgemmStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* , int , long long int , const __half* , int , long long int , const __half* , __half* , int , long long int , int );
	if (!lcublasHgemmStridedBatched) {
		lcublasHgemmStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const __half* , const __half* , int , long long int , const __half* , int , long long int , const __half* , __half* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasHgemmStridedBatched");
		tracer._kernel_map[(void *) lcublasHgemmStridedBatched] = std::string("cublasHgemmStridedBatched");
	}
	assert(lcublasHgemmStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemmStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemmStridedBatched);
	}
	return res;
}

cublasStatus_t cublasHgemmStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const __half*  alpha, const __half*  A, int64_t  lda, long long int  strideA, const __half*  B, int64_t  ldb, long long int  strideB, const __half*  beta, __half*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasHgemmStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const __half* , __half* , int64_t , long long int , int64_t );
	if (!lcublasHgemmStridedBatched_64) {
		lcublasHgemmStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const __half* , const __half* , int64_t , long long int , const __half* , int64_t , long long int , const __half* , __half* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasHgemmStridedBatched_64");
		tracer._kernel_map[(void *) lcublasHgemmStridedBatched_64] = std::string("cublasHgemmStridedBatched_64");
	}
	assert(lcublasHgemmStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasHgemmStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasHgemmStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasSgemmStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const float*  alpha, const float*  A, int  lda, long long int  strideA, const float*  B, int  ldb, long long int  strideB, const float*  beta, float*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasSgemmStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* , int , long long int , const float* , int , long long int , const float* , float* , int , long long int , int );
	if (!lcublasSgemmStridedBatched) {
		lcublasSgemmStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const float* , const float* , int , long long int , const float* , int , long long int , const float* , float* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasSgemmStridedBatched");
		tracer._kernel_map[(void *) lcublasSgemmStridedBatched] = std::string("cublasSgemmStridedBatched");
	}
	assert(lcublasSgemmStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmStridedBatched);
	}
	return res;
}

cublasStatus_t cublasSgemmStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const float*  alpha, const float*  A, int64_t  lda, long long int  strideA, const float*  B, int64_t  ldb, long long int  strideB, const float*  beta, float*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasSgemmStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , long long int , const float* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t );
	if (!lcublasSgemmStridedBatched_64) {
		lcublasSgemmStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const float* , const float* , int64_t , long long int , const float* , int64_t , long long int , const float* , float* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasSgemmStridedBatched_64");
		tracer._kernel_map[(void *) lcublasSgemmStridedBatched_64] = std::string("cublasSgemmStridedBatched_64");
	}
	assert(lcublasSgemmStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgemmStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgemmStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasDgemmStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const double*  alpha, const double*  A, int  lda, long long int  strideA, const double*  B, int  ldb, long long int  strideB, const double*  beta, double*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasDgemmStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* , int , long long int , const double* , int , long long int , const double* , double* , int , long long int , int );
	if (!lcublasDgemmStridedBatched) {
		lcublasDgemmStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const double* , const double* , int , long long int , const double* , int , long long int , const double* , double* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasDgemmStridedBatched");
		tracer._kernel_map[(void *) lcublasDgemmStridedBatched] = std::string("cublasDgemmStridedBatched");
	}
	assert(lcublasDgemmStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemmStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemmStridedBatched);
	}
	return res;
}

cublasStatus_t cublasDgemmStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const double*  alpha, const double*  A, int64_t  lda, long long int  strideA, const double*  B, int64_t  ldb, long long int  strideB, const double*  beta, double*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasDgemmStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , long long int , const double* , int64_t , long long int , const double* , double* , int64_t , long long int , int64_t );
	if (!lcublasDgemmStridedBatched_64) {
		lcublasDgemmStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const double* , const double* , int64_t , long long int , const double* , int64_t , long long int , const double* , double* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasDgemmStridedBatched_64");
		tracer._kernel_map[(void *) lcublasDgemmStridedBatched_64] = std::string("cublasDgemmStridedBatched_64");
	}
	assert(lcublasDgemmStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgemmStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgemmStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemmStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, long long int  strideA, const cuComplex*  B, int  ldb, long long int  strideB, const cuComplex*  beta, cuComplex*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemmStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int );
	if (!lcublasCgemmStridedBatched) {
		lcublasCgemmStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasCgemmStridedBatched");
		tracer._kernel_map[(void *) lcublasCgemmStridedBatched] = std::string("cublasCgemmStridedBatched");
	}
	assert(lcublasCgemmStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmStridedBatched);
	}
	return res;
}

cublasStatus_t cublasCgemmStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, long long int  strideA, const cuComplex*  B, int64_t  ldb, long long int  strideB, const cuComplex*  beta, cuComplex*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemmStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t );
	if (!lcublasCgemmStridedBatched_64) {
		lcublasCgemmStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasCgemmStridedBatched_64");
		tracer._kernel_map[(void *) lcublasCgemmStridedBatched_64] = std::string("cublasCgemmStridedBatched_64");
	}
	assert(lcublasCgemmStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemmStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemmStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasCgemm3mStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuComplex*  alpha, const cuComplex*  A, int  lda, long long int  strideA, const cuComplex*  B, int  ldb, long long int  strideB, const cuComplex*  beta, cuComplex*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasCgemm3mStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int );
	if (!lcublasCgemm3mStridedBatched) {
		lcublasCgemm3mStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuComplex* , const cuComplex* , int , long long int , const cuComplex* , int , long long int , const cuComplex* , cuComplex* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasCgemm3mStridedBatched");
		tracer._kernel_map[(void *) lcublasCgemm3mStridedBatched] = std::string("cublasCgemm3mStridedBatched");
	}
	assert(lcublasCgemm3mStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mStridedBatched);
	}
	return res;
}

cublasStatus_t cublasCgemm3mStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, long long int  strideA, const cuComplex*  B, int64_t  ldb, long long int  strideB, const cuComplex*  beta, cuComplex*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCgemm3mStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t );
	if (!lcublasCgemm3mStridedBatched_64) {
		lcublasCgemm3mStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , long long int , const cuComplex* , int64_t , long long int , const cuComplex* , cuComplex* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasCgemm3mStridedBatched_64");
		tracer._kernel_map[(void *) lcublasCgemm3mStridedBatched_64] = std::string("cublasCgemm3mStridedBatched_64");
	}
	assert(lcublasCgemm3mStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgemm3mStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgemm3mStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasZgemmStridedBatched(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, long long int  strideA, const cuDoubleComplex*  B, int  ldb, long long int  strideB, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int  ldc, long long int  strideC, int  batchCount)
{
	static cublasStatus_t (*lcublasZgemmStridedBatched) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , cuDoubleComplex* , int , long long int , int );
	if (!lcublasZgemmStridedBatched) {
		lcublasZgemmStridedBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , int , long long int , const cuDoubleComplex* , cuDoubleComplex* , int , long long int , int )) dlsym(RTLD_NEXT, "cublasZgemmStridedBatched");
		tracer._kernel_map[(void *) lcublasZgemmStridedBatched] = std::string("cublasZgemmStridedBatched");
	}
	assert(lcublasZgemmStridedBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemmStridedBatched(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemmStridedBatched);
	}
	return res;
}

cublasStatus_t cublasZgemmStridedBatched_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, long long int  strideA, const cuDoubleComplex*  B, int64_t  ldb, long long int  strideB, const cuDoubleComplex*  beta, cuDoubleComplex*  C, int64_t  ldc, long long int  strideC, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasZgemmStridedBatched_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , cuDoubleComplex* , int64_t , long long int , int64_t );
	if (!lcublasZgemmStridedBatched_64) {
		lcublasZgemmStridedBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , int64_t , long long int , const cuDoubleComplex* , cuDoubleComplex* , int64_t , long long int , int64_t )) dlsym(RTLD_NEXT, "cublasZgemmStridedBatched_64");
		tracer._kernel_map[(void *) lcublasZgemmStridedBatched_64] = std::string("cublasZgemmStridedBatched_64");
	}
	assert(lcublasZgemmStridedBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgemmStridedBatched_64(handle, transa, transb, m, n, k, alpha, A, lda, strideA, B, ldb, strideB, beta, C, ldc, strideC, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgemmStridedBatched_64);
	}
	return res;
}

cublasStatus_t cublasGemmBatchedEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const void*  alpha, const void* const  Aarray[], cudaDataType  Atype, int  lda, const void* const  Barray[], cudaDataType  Btype, int  ldb, const void*  beta, void* const  Carray[], cudaDataType  Ctype, int  ldc, int  batchCount, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmBatchedEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* const [], cudaDataType , int , const void* const [], cudaDataType , int , const void* , void* const [], cudaDataType , int , int , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmBatchedEx) {
		lcublasGemmBatchedEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* const [], cudaDataType , int , const void* const [], cudaDataType , int , const void* , void* const [], cudaDataType , int , int , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmBatchedEx");
		tracer._kernel_map[(void *) lcublasGemmBatchedEx] = std::string("cublasGemmBatchedEx");
	}
	assert(lcublasGemmBatchedEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmBatchedEx(handle, transa, transb, m, n, k, alpha, Aarray, Atype, lda, Barray, Btype, ldb, beta, Carray, Ctype, ldc, batchCount, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmBatchedEx);
	}
	return res;
}

cublasStatus_t cublasGemmBatchedEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const void*  alpha, const void* const  Aarray[], cudaDataType  Atype, int64_t  lda, const void* const  Barray[], cudaDataType  Btype, int64_t  ldb, const void*  beta, void* const  Carray[], cudaDataType  Ctype, int64_t  ldc, int64_t  batchCount, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmBatchedEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* const [], cudaDataType , int64_t , const void* const [], cudaDataType , int64_t , const void* , void* const [], cudaDataType , int64_t , int64_t , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmBatchedEx_64) {
		lcublasGemmBatchedEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* const [], cudaDataType , int64_t , const void* const [], cudaDataType , int64_t , const void* , void* const [], cudaDataType , int64_t , int64_t , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmBatchedEx_64");
		tracer._kernel_map[(void *) lcublasGemmBatchedEx_64] = std::string("cublasGemmBatchedEx_64");
	}
	assert(lcublasGemmBatchedEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmBatchedEx_64(handle, transa, transb, m, n, k, alpha, Aarray, Atype, lda, Barray, Btype, ldb, beta, Carray, Ctype, ldc, batchCount, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmBatchedEx_64);
	}
	return res;
}

cublasStatus_t cublasGemmStridedBatchedEx(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, int  k, const void*  alpha, const void*  A, cudaDataType  Atype, int  lda, long long int  strideA, const void*  B, cudaDataType  Btype, int  ldb, long long int  strideB, const void*  beta, void*  C, cudaDataType  Ctype, int  ldc, long long int  strideC, int  batchCount, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmStridedBatchedEx) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* , cudaDataType , int , long long int , const void* , cudaDataType , int , long long int , const void* , void* , cudaDataType , int , long long int , int , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmStridedBatchedEx) {
		lcublasGemmStridedBatchedEx = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , int , const void* , const void* , cudaDataType , int , long long int , const void* , cudaDataType , int , long long int , const void* , void* , cudaDataType , int , long long int , int , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmStridedBatchedEx");
		tracer._kernel_map[(void *) lcublasGemmStridedBatchedEx] = std::string("cublasGemmStridedBatchedEx");
	}
	assert(lcublasGemmStridedBatchedEx);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, strideA, B, Btype, ldb, strideB, beta, C, Ctype, ldc, strideC, batchCount, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmStridedBatchedEx);
	}
	return res;
}

cublasStatus_t cublasGemmStridedBatchedEx_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, int64_t  k, const void*  alpha, const void*  A, cudaDataType  Atype, int64_t  lda, long long int  strideA, const void*  B, cudaDataType  Btype, int64_t  ldb, long long int  strideB, const void*  beta, void*  C, cudaDataType  Ctype, int64_t  ldc, long long int  strideC, int64_t  batchCount, cublasComputeType_t  computeType, cublasGemmAlgo_t  algo)
{
	static cublasStatus_t (*lcublasGemmStridedBatchedEx_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* , cudaDataType , int64_t , long long int , const void* , cudaDataType , int64_t , long long int , const void* , void* , cudaDataType , int64_t , long long int , int64_t , cublasComputeType_t , cublasGemmAlgo_t );
	if (!lcublasGemmStridedBatchedEx_64) {
		lcublasGemmStridedBatchedEx_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , int64_t , const void* , const void* , cudaDataType , int64_t , long long int , const void* , cudaDataType , int64_t , long long int , const void* , void* , cudaDataType , int64_t , long long int , int64_t , cublasComputeType_t , cublasGemmAlgo_t )) dlsym(RTLD_NEXT, "cublasGemmStridedBatchedEx_64");
		tracer._kernel_map[(void *) lcublasGemmStridedBatchedEx_64] = std::string("cublasGemmStridedBatchedEx_64");
	}
	assert(lcublasGemmStridedBatchedEx_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasGemmStridedBatchedEx_64(handle, transa, transb, m, n, k, alpha, A, Atype, lda, strideA, B, Btype, ldb, strideB, beta, C, Ctype, ldc, strideC, batchCount, computeType, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasGemmStridedBatchedEx_64);
	}
	return res;
}

cublasStatus_t cublasSgeam(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, const float*  alpha, const float*  A, int  lda, const float*  beta, const float*  B, int  ldb, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSgeam) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , const float* , int , float* , int );
	if (!lcublasSgeam) {
		lcublasSgeam = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const float* , const float* , int , const float* , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSgeam");
		tracer._kernel_map[(void *) lcublasSgeam] = std::string("cublasSgeam");
	}
	assert(lcublasSgeam);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgeam(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgeam);
	}
	return res;
}

cublasStatus_t cublasSgeam_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, const float*  alpha, const float*  A, int64_t  lda, const float*  beta, const float*  B, int64_t  ldb, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSgeam_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , const float* , int64_t , float* , int64_t );
	if (!lcublasSgeam_64) {
		lcublasSgeam_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const float* , const float* , int64_t , const float* , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSgeam_64");
		tracer._kernel_map[(void *) lcublasSgeam_64] = std::string("cublasSgeam_64");
	}
	assert(lcublasSgeam_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgeam_64(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgeam_64);
	}
	return res;
}

cublasStatus_t cublasDgeam(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, const double*  alpha, const double*  A, int  lda, const double*  beta, const double*  B, int  ldb, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDgeam) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , const double* , int , double* , int );
	if (!lcublasDgeam) {
		lcublasDgeam = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const double* , const double* , int , const double* , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDgeam");
		tracer._kernel_map[(void *) lcublasDgeam] = std::string("cublasDgeam");
	}
	assert(lcublasDgeam);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgeam(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgeam);
	}
	return res;
}

cublasStatus_t cublasDgeam_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, const double*  alpha, const double*  A, int64_t  lda, const double*  beta, const double*  B, int64_t  ldb, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDgeam_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , const double* , int64_t , double* , int64_t );
	if (!lcublasDgeam_64) {
		lcublasDgeam_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const double* , const double* , int64_t , const double* , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDgeam_64");
		tracer._kernel_map[(void *) lcublasDgeam_64] = std::string("cublasDgeam_64");
	}
	assert(lcublasDgeam_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgeam_64(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgeam_64);
	}
	return res;
}

cublasStatus_t cublasCgeam(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, const cuComplex*  alpha, const cuComplex*  A, int  lda, const cuComplex*  beta, const cuComplex*  B, int  ldb, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCgeam) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCgeam) {
		lcublasCgeam = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const cuComplex* , const cuComplex* , int , const cuComplex* , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCgeam");
		tracer._kernel_map[(void *) lcublasCgeam] = std::string("cublasCgeam");
	}
	assert(lcublasCgeam);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgeam(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgeam);
	}
	return res;
}

cublasStatus_t cublasCgeam_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex*  A, int64_t  lda, const cuComplex*  beta, const cuComplex*  B, int64_t  ldb, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCgeam_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCgeam_64) {
		lcublasCgeam_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const cuComplex* , const cuComplex* , int64_t , const cuComplex* , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCgeam_64");
		tracer._kernel_map[(void *) lcublasCgeam_64] = std::string("cublasCgeam_64");
	}
	assert(lcublasCgeam_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgeam_64(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgeam_64);
	}
	return res;
}

cublasStatus_t cublasZgeam(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  beta, const cuDoubleComplex*  B, int  ldb, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZgeam) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZgeam) {
		lcublasZgeam = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* , int , const cuDoubleComplex* , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZgeam");
		tracer._kernel_map[(void *) lcublasZgeam] = std::string("cublasZgeam");
	}
	assert(lcublasZgeam);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgeam(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgeam);
	}
	return res;
}

cublasStatus_t cublasZgeam_64(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  beta, const cuDoubleComplex*  B, int64_t  ldb, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZgeam_64) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZgeam_64) {
		lcublasZgeam_64 = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZgeam_64");
		tracer._kernel_map[(void *) lcublasZgeam_64] = std::string("cublasZgeam_64");
	}
	assert(lcublasZgeam_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgeam_64(handle, transa, transb, m, n, alpha, A, lda, beta, B, ldb, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgeam_64);
	}
	return res;
}

cublasStatus_t cublasStrsmBatched(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const float*  alpha, const float* const  A[], int  lda, float* const  B[], int  ldb, int  batchCount)
{
	static cublasStatus_t (*lcublasStrsmBatched) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* const [], int , float* const [], int , int );
	if (!lcublasStrsmBatched) {
		lcublasStrsmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const float* , const float* const [], int , float* const [], int , int )) dlsym(RTLD_NEXT, "cublasStrsmBatched");
		tracer._kernel_map[(void *) lcublasStrsmBatched] = std::string("cublasStrsmBatched");
	}
	assert(lcublasStrsmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsmBatched(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsmBatched);
	}
	return res;
}

cublasStatus_t cublasStrsmBatched_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const float*  alpha, const float* const  A[], int64_t  lda, float* const  B[], int64_t  ldb, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasStrsmBatched_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* const [], int64_t , float* const [], int64_t , int64_t );
	if (!lcublasStrsmBatched_64) {
		lcublasStrsmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const float* , const float* const [], int64_t , float* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasStrsmBatched_64");
		tracer._kernel_map[(void *) lcublasStrsmBatched_64] = std::string("cublasStrsmBatched_64");
	}
	assert(lcublasStrsmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrsmBatched_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrsmBatched_64);
	}
	return res;
}

cublasStatus_t cublasDtrsmBatched(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const double*  alpha, const double* const  A[], int  lda, double* const  B[], int  ldb, int  batchCount)
{
	static cublasStatus_t (*lcublasDtrsmBatched) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* const [], int , double* const [], int , int );
	if (!lcublasDtrsmBatched) {
		lcublasDtrsmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const double* , const double* const [], int , double* const [], int , int )) dlsym(RTLD_NEXT, "cublasDtrsmBatched");
		tracer._kernel_map[(void *) lcublasDtrsmBatched] = std::string("cublasDtrsmBatched");
	}
	assert(lcublasDtrsmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsmBatched(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsmBatched);
	}
	return res;
}

cublasStatus_t cublasDtrsmBatched_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const double*  alpha, const double* const  A[], int64_t  lda, double* const  B[], int64_t  ldb, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasDtrsmBatched_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* const [], int64_t , double* const [], int64_t , int64_t );
	if (!lcublasDtrsmBatched_64) {
		lcublasDtrsmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const double* , const double* const [], int64_t , double* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasDtrsmBatched_64");
		tracer._kernel_map[(void *) lcublasDtrsmBatched_64] = std::string("cublasDtrsmBatched_64");
	}
	assert(lcublasDtrsmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrsmBatched_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrsmBatched_64);
	}
	return res;
}

cublasStatus_t cublasCtrsmBatched(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuComplex*  alpha, const cuComplex* const  A[], int  lda, cuComplex* const  B[], int  ldb, int  batchCount)
{
	static cublasStatus_t (*lcublasCtrsmBatched) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* const [], int , cuComplex* const [], int , int );
	if (!lcublasCtrsmBatched) {
		lcublasCtrsmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuComplex* , const cuComplex* const [], int , cuComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasCtrsmBatched");
		tracer._kernel_map[(void *) lcublasCtrsmBatched] = std::string("cublasCtrsmBatched");
	}
	assert(lcublasCtrsmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsmBatched(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsmBatched);
	}
	return res;
}

cublasStatus_t cublasCtrsmBatched_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuComplex*  alpha, const cuComplex* const  A[], int64_t  lda, cuComplex* const  B[], int64_t  ldb, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasCtrsmBatched_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , cuComplex* const [], int64_t , int64_t );
	if (!lcublasCtrsmBatched_64) {
		lcublasCtrsmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuComplex* , const cuComplex* const [], int64_t , cuComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasCtrsmBatched_64");
		tracer._kernel_map[(void *) lcublasCtrsmBatched_64] = std::string("cublasCtrsmBatched_64");
	}
	assert(lcublasCtrsmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrsmBatched_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrsmBatched_64);
	}
	return res;
}

cublasStatus_t cublasZtrsmBatched(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int  m, int  n, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  A[], int  lda, cuDoubleComplex* const  B[], int  ldb, int  batchCount)
{
	static cublasStatus_t (*lcublasZtrsmBatched) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int );
	if (!lcublasZtrsmBatched) {
		lcublasZtrsmBatched = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int , int , const cuDoubleComplex* , const cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int )) dlsym(RTLD_NEXT, "cublasZtrsmBatched");
		tracer._kernel_map[(void *) lcublasZtrsmBatched] = std::string("cublasZtrsmBatched");
	}
	assert(lcublasZtrsmBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsmBatched(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsmBatched);
	}
	return res;
}

cublasStatus_t cublasZtrsmBatched_64(cublasHandle_t  handle, cublasSideMode_t  side, cublasFillMode_t  uplo, cublasOperation_t  trans, cublasDiagType_t  diag, int64_t  m, int64_t  n, const cuDoubleComplex*  alpha, const cuDoubleComplex* const  A[], int64_t  lda, cuDoubleComplex* const  B[], int64_t  ldb, int64_t  batchCount)
{
	static cublasStatus_t (*lcublasZtrsmBatched_64) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , cuDoubleComplex* const [], int64_t , int64_t );
	if (!lcublasZtrsmBatched_64) {
		lcublasZtrsmBatched_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , cublasFillMode_t , cublasOperation_t , cublasDiagType_t , int64_t , int64_t , const cuDoubleComplex* , const cuDoubleComplex* const [], int64_t , cuDoubleComplex* const [], int64_t , int64_t )) dlsym(RTLD_NEXT, "cublasZtrsmBatched_64");
		tracer._kernel_map[(void *) lcublasZtrsmBatched_64] = std::string("cublasZtrsmBatched_64");
	}
	assert(lcublasZtrsmBatched_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrsmBatched_64(handle, side, uplo, trans, diag, m, n, alpha, A, lda, B, ldb, batchCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrsmBatched_64);
	}
	return res;
}

cublasStatus_t cublasSdgmm(cublasHandle_t  handle, cublasSideMode_t  mode, int  m, int  n, const float*  A, int  lda, const float*  x, int  incx, float*  C, int  ldc)
{
	static cublasStatus_t (*lcublasSdgmm) (cublasHandle_t , cublasSideMode_t , int , int , const float* , int , const float* , int , float* , int );
	if (!lcublasSdgmm) {
		lcublasSdgmm = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int , int , const float* , int , const float* , int , float* , int )) dlsym(RTLD_NEXT, "cublasSdgmm");
		tracer._kernel_map[(void *) lcublasSdgmm] = std::string("cublasSdgmm");
	}
	assert(lcublasSdgmm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSdgmm(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSdgmm);
	}
	return res;
}

cublasStatus_t cublasSdgmm_64(cublasHandle_t  handle, cublasSideMode_t  mode, int64_t  m, int64_t  n, const float*  A, int64_t  lda, const float*  x, int64_t  incx, float*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasSdgmm_64) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const float* , int64_t , const float* , int64_t , float* , int64_t );
	if (!lcublasSdgmm_64) {
		lcublasSdgmm_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const float* , int64_t , const float* , int64_t , float* , int64_t )) dlsym(RTLD_NEXT, "cublasSdgmm_64");
		tracer._kernel_map[(void *) lcublasSdgmm_64] = std::string("cublasSdgmm_64");
	}
	assert(lcublasSdgmm_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSdgmm_64(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSdgmm_64);
	}
	return res;
}

cublasStatus_t cublasDdgmm(cublasHandle_t  handle, cublasSideMode_t  mode, int  m, int  n, const double*  A, int  lda, const double*  x, int  incx, double*  C, int  ldc)
{
	static cublasStatus_t (*lcublasDdgmm) (cublasHandle_t , cublasSideMode_t , int , int , const double* , int , const double* , int , double* , int );
	if (!lcublasDdgmm) {
		lcublasDdgmm = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int , int , const double* , int , const double* , int , double* , int )) dlsym(RTLD_NEXT, "cublasDdgmm");
		tracer._kernel_map[(void *) lcublasDdgmm] = std::string("cublasDdgmm");
	}
	assert(lcublasDdgmm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDdgmm(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDdgmm);
	}
	return res;
}

cublasStatus_t cublasDdgmm_64(cublasHandle_t  handle, cublasSideMode_t  mode, int64_t  m, int64_t  n, const double*  A, int64_t  lda, const double*  x, int64_t  incx, double*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasDdgmm_64) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const double* , int64_t , const double* , int64_t , double* , int64_t );
	if (!lcublasDdgmm_64) {
		lcublasDdgmm_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const double* , int64_t , const double* , int64_t , double* , int64_t )) dlsym(RTLD_NEXT, "cublasDdgmm_64");
		tracer._kernel_map[(void *) lcublasDdgmm_64] = std::string("cublasDdgmm_64");
	}
	assert(lcublasDdgmm_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDdgmm_64(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDdgmm_64);
	}
	return res;
}

cublasStatus_t cublasCdgmm(cublasHandle_t  handle, cublasSideMode_t  mode, int  m, int  n, const cuComplex*  A, int  lda, const cuComplex*  x, int  incx, cuComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasCdgmm) (cublasHandle_t , cublasSideMode_t , int , int , const cuComplex* , int , const cuComplex* , int , cuComplex* , int );
	if (!lcublasCdgmm) {
		lcublasCdgmm = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int , int , const cuComplex* , int , const cuComplex* , int , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCdgmm");
		tracer._kernel_map[(void *) lcublasCdgmm] = std::string("cublasCdgmm");
	}
	assert(lcublasCdgmm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdgmm(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdgmm);
	}
	return res;
}

cublasStatus_t cublasCdgmm_64(cublasHandle_t  handle, cublasSideMode_t  mode, int64_t  m, int64_t  n, const cuComplex*  A, int64_t  lda, const cuComplex*  x, int64_t  incx, cuComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasCdgmm_64) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t );
	if (!lcublasCdgmm_64) {
		lcublasCdgmm_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const cuComplex* , int64_t , const cuComplex* , int64_t , cuComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasCdgmm_64");
		tracer._kernel_map[(void *) lcublasCdgmm_64] = std::string("cublasCdgmm_64");
	}
	assert(lcublasCdgmm_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCdgmm_64(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCdgmm_64);
	}
	return res;
}

cublasStatus_t cublasZdgmm(cublasHandle_t  handle, cublasSideMode_t  mode, int  m, int  n, const cuDoubleComplex*  A, int  lda, const cuDoubleComplex*  x, int  incx, cuDoubleComplex*  C, int  ldc)
{
	static cublasStatus_t (*lcublasZdgmm) (cublasHandle_t , cublasSideMode_t , int , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int );
	if (!lcublasZdgmm) {
		lcublasZdgmm = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int , int , const cuDoubleComplex* , int , const cuDoubleComplex* , int , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZdgmm");
		tracer._kernel_map[(void *) lcublasZdgmm] = std::string("cublasZdgmm");
	}
	assert(lcublasZdgmm);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdgmm(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdgmm);
	}
	return res;
}

cublasStatus_t cublasZdgmm_64(cublasHandle_t  handle, cublasSideMode_t  mode, int64_t  m, int64_t  n, const cuDoubleComplex*  A, int64_t  lda, const cuDoubleComplex*  x, int64_t  incx, cuDoubleComplex*  C, int64_t  ldc)
{
	static cublasStatus_t (*lcublasZdgmm_64) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t );
	if (!lcublasZdgmm_64) {
		lcublasZdgmm_64 = (cublasStatus_t (*) (cublasHandle_t , cublasSideMode_t , int64_t , int64_t , const cuDoubleComplex* , int64_t , const cuDoubleComplex* , int64_t , cuDoubleComplex* , int64_t )) dlsym(RTLD_NEXT, "cublasZdgmm_64");
		tracer._kernel_map[(void *) lcublasZdgmm_64] = std::string("cublasZdgmm_64");
	}
	assert(lcublasZdgmm_64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZdgmm_64(handle, mode, m, n, A, lda, x, incx, C, ldc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZdgmm_64);
	}
	return res;
}

cublasStatus_t cublasSmatinvBatched(cublasHandle_t  handle, int  n, const float* const  A[], int  lda, float* const  Ainv[], int  lda_inv, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasSmatinvBatched) (cublasHandle_t , int , const float* const [], int , float* const [], int , int* , int );
	if (!lcublasSmatinvBatched) {
		lcublasSmatinvBatched = (cublasStatus_t (*) (cublasHandle_t , int , const float* const [], int , float* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasSmatinvBatched");
		tracer._kernel_map[(void *) lcublasSmatinvBatched] = std::string("cublasSmatinvBatched");
	}
	assert(lcublasSmatinvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSmatinvBatched(handle, n, A, lda, Ainv, lda_inv, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSmatinvBatched);
	}
	return res;
}

cublasStatus_t cublasDmatinvBatched(cublasHandle_t  handle, int  n, const double* const  A[], int  lda, double* const  Ainv[], int  lda_inv, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasDmatinvBatched) (cublasHandle_t , int , const double* const [], int , double* const [], int , int* , int );
	if (!lcublasDmatinvBatched) {
		lcublasDmatinvBatched = (cublasStatus_t (*) (cublasHandle_t , int , const double* const [], int , double* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasDmatinvBatched");
		tracer._kernel_map[(void *) lcublasDmatinvBatched] = std::string("cublasDmatinvBatched");
	}
	assert(lcublasDmatinvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDmatinvBatched(handle, n, A, lda, Ainv, lda_inv, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDmatinvBatched);
	}
	return res;
}

cublasStatus_t cublasCmatinvBatched(cublasHandle_t  handle, int  n, const cuComplex* const  A[], int  lda, cuComplex* const  Ainv[], int  lda_inv, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasCmatinvBatched) (cublasHandle_t , int , const cuComplex* const [], int , cuComplex* const [], int , int* , int );
	if (!lcublasCmatinvBatched) {
		lcublasCmatinvBatched = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* const [], int , cuComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasCmatinvBatched");
		tracer._kernel_map[(void *) lcublasCmatinvBatched] = std::string("cublasCmatinvBatched");
	}
	assert(lcublasCmatinvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCmatinvBatched(handle, n, A, lda, Ainv, lda_inv, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCmatinvBatched);
	}
	return res;
}

cublasStatus_t cublasZmatinvBatched(cublasHandle_t  handle, int  n, const cuDoubleComplex* const  A[], int  lda, cuDoubleComplex* const  Ainv[], int  lda_inv, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasZmatinvBatched) (cublasHandle_t , int , const cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int* , int );
	if (!lcublasZmatinvBatched) {
		lcublasZmatinvBatched = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasZmatinvBatched");
		tracer._kernel_map[(void *) lcublasZmatinvBatched] = std::string("cublasZmatinvBatched");
	}
	assert(lcublasZmatinvBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZmatinvBatched(handle, n, A, lda, Ainv, lda_inv, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZmatinvBatched);
	}
	return res;
}

cublasStatus_t cublasSgeqrfBatched(cublasHandle_t  handle, int  m, int  n, float* const  Aarray[], int  lda, float* const  TauArray[], int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasSgeqrfBatched) (cublasHandle_t , int , int , float* const [], int , float* const [], int* , int );
	if (!lcublasSgeqrfBatched) {
		lcublasSgeqrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , int , float* const [], int , float* const [], int* , int )) dlsym(RTLD_NEXT, "cublasSgeqrfBatched");
		tracer._kernel_map[(void *) lcublasSgeqrfBatched] = std::string("cublasSgeqrfBatched");
	}
	assert(lcublasSgeqrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgeqrfBatched(handle, m, n, Aarray, lda, TauArray, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgeqrfBatched);
	}
	return res;
}

cublasStatus_t cublasDgeqrfBatched(cublasHandle_t  handle, int  m, int  n, double* const  Aarray[], int  lda, double* const  TauArray[], int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasDgeqrfBatched) (cublasHandle_t , int , int , double* const [], int , double* const [], int* , int );
	if (!lcublasDgeqrfBatched) {
		lcublasDgeqrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , int , double* const [], int , double* const [], int* , int )) dlsym(RTLD_NEXT, "cublasDgeqrfBatched");
		tracer._kernel_map[(void *) lcublasDgeqrfBatched] = std::string("cublasDgeqrfBatched");
	}
	assert(lcublasDgeqrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgeqrfBatched(handle, m, n, Aarray, lda, TauArray, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgeqrfBatched);
	}
	return res;
}

cublasStatus_t cublasCgeqrfBatched(cublasHandle_t  handle, int  m, int  n, cuComplex* const  Aarray[], int  lda, cuComplex* const  TauArray[], int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasCgeqrfBatched) (cublasHandle_t , int , int , cuComplex* const [], int , cuComplex* const [], int* , int );
	if (!lcublasCgeqrfBatched) {
		lcublasCgeqrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , int , cuComplex* const [], int , cuComplex* const [], int* , int )) dlsym(RTLD_NEXT, "cublasCgeqrfBatched");
		tracer._kernel_map[(void *) lcublasCgeqrfBatched] = std::string("cublasCgeqrfBatched");
	}
	assert(lcublasCgeqrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgeqrfBatched(handle, m, n, Aarray, lda, TauArray, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgeqrfBatched);
	}
	return res;
}

cublasStatus_t cublasZgeqrfBatched(cublasHandle_t  handle, int  m, int  n, cuDoubleComplex* const  Aarray[], int  lda, cuDoubleComplex* const  TauArray[], int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasZgeqrfBatched) (cublasHandle_t , int , int , cuDoubleComplex* const [], int , cuDoubleComplex* const [], int* , int );
	if (!lcublasZgeqrfBatched) {
		lcublasZgeqrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , int , cuDoubleComplex* const [], int , cuDoubleComplex* const [], int* , int )) dlsym(RTLD_NEXT, "cublasZgeqrfBatched");
		tracer._kernel_map[(void *) lcublasZgeqrfBatched] = std::string("cublasZgeqrfBatched");
	}
	assert(lcublasZgeqrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgeqrfBatched(handle, m, n, Aarray, lda, TauArray, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgeqrfBatched);
	}
	return res;
}

cublasStatus_t cublasSgelsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  nrhs, float* const  Aarray[], int  lda, float* const  Carray[], int  ldc, int*  info, int*  devInfoArray, int  batchSize)
{
	static cublasStatus_t (*lcublasSgelsBatched) (cublasHandle_t , cublasOperation_t , int , int , int , float* const [], int , float* const [], int , int* , int* , int );
	if (!lcublasSgelsBatched) {
		lcublasSgelsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , float* const [], int , float* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasSgelsBatched");
		tracer._kernel_map[(void *) lcublasSgelsBatched] = std::string("cublasSgelsBatched");
	}
	assert(lcublasSgelsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgelsBatched(handle, trans, m, n, nrhs, Aarray, lda, Carray, ldc, info, devInfoArray, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgelsBatched);
	}
	return res;
}

cublasStatus_t cublasDgelsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  nrhs, double* const  Aarray[], int  lda, double* const  Carray[], int  ldc, int*  info, int*  devInfoArray, int  batchSize)
{
	static cublasStatus_t (*lcublasDgelsBatched) (cublasHandle_t , cublasOperation_t , int , int , int , double* const [], int , double* const [], int , int* , int* , int );
	if (!lcublasDgelsBatched) {
		lcublasDgelsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , double* const [], int , double* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasDgelsBatched");
		tracer._kernel_map[(void *) lcublasDgelsBatched] = std::string("cublasDgelsBatched");
	}
	assert(lcublasDgelsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgelsBatched(handle, trans, m, n, nrhs, Aarray, lda, Carray, ldc, info, devInfoArray, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgelsBatched);
	}
	return res;
}

cublasStatus_t cublasCgelsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  nrhs, cuComplex* const  Aarray[], int  lda, cuComplex* const  Carray[], int  ldc, int*  info, int*  devInfoArray, int  batchSize)
{
	static cublasStatus_t (*lcublasCgelsBatched) (cublasHandle_t , cublasOperation_t , int , int , int , cuComplex* const [], int , cuComplex* const [], int , int* , int* , int );
	if (!lcublasCgelsBatched) {
		lcublasCgelsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , cuComplex* const [], int , cuComplex* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasCgelsBatched");
		tracer._kernel_map[(void *) lcublasCgelsBatched] = std::string("cublasCgelsBatched");
	}
	assert(lcublasCgelsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgelsBatched(handle, trans, m, n, nrhs, Aarray, lda, Carray, ldc, info, devInfoArray, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgelsBatched);
	}
	return res;
}

cublasStatus_t cublasZgelsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  m, int  n, int  nrhs, cuDoubleComplex* const  Aarray[], int  lda, cuDoubleComplex* const  Carray[], int  ldc, int*  info, int*  devInfoArray, int  batchSize)
{
	static cublasStatus_t (*lcublasZgelsBatched) (cublasHandle_t , cublasOperation_t , int , int , int , cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int* , int* , int );
	if (!lcublasZgelsBatched) {
		lcublasZgelsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , int , cuDoubleComplex* const [], int , cuDoubleComplex* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasZgelsBatched");
		tracer._kernel_map[(void *) lcublasZgelsBatched] = std::string("cublasZgelsBatched");
	}
	assert(lcublasZgelsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgelsBatched(handle, trans, m, n, nrhs, Aarray, lda, Carray, ldc, info, devInfoArray, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgelsBatched);
	}
	return res;
}

cublasStatus_t cublasStpttr(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  AP, float*  A, int  lda)
{
	static cublasStatus_t (*lcublasStpttr) (cublasHandle_t , cublasFillMode_t , int , const float* , float* , int );
	if (!lcublasStpttr) {
		lcublasStpttr = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , float* , int )) dlsym(RTLD_NEXT, "cublasStpttr");
		tracer._kernel_map[(void *) lcublasStpttr] = std::string("cublasStpttr");
	}
	assert(lcublasStpttr);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStpttr(handle, uplo, n, AP, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStpttr);
	}
	return res;
}

cublasStatus_t cublasDtpttr(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  AP, double*  A, int  lda)
{
	static cublasStatus_t (*lcublasDtpttr) (cublasHandle_t , cublasFillMode_t , int , const double* , double* , int );
	if (!lcublasDtpttr) {
		lcublasDtpttr = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , double* , int )) dlsym(RTLD_NEXT, "cublasDtpttr");
		tracer._kernel_map[(void *) lcublasDtpttr] = std::string("cublasDtpttr");
	}
	assert(lcublasDtpttr);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtpttr(handle, uplo, n, AP, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtpttr);
	}
	return res;
}

cublasStatus_t cublasCtpttr(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  AP, cuComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasCtpttr) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , cuComplex* , int );
	if (!lcublasCtpttr) {
		lcublasCtpttr = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , cuComplex* , int )) dlsym(RTLD_NEXT, "cublasCtpttr");
		tracer._kernel_map[(void *) lcublasCtpttr] = std::string("cublasCtpttr");
	}
	assert(lcublasCtpttr);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtpttr(handle, uplo, n, AP, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtpttr);
	}
	return res;
}

cublasStatus_t cublasZtpttr(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  AP, cuDoubleComplex*  A, int  lda)
{
	static cublasStatus_t (*lcublasZtpttr) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , cuDoubleComplex* , int );
	if (!lcublasZtpttr) {
		lcublasZtpttr = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , cuDoubleComplex* , int )) dlsym(RTLD_NEXT, "cublasZtpttr");
		tracer._kernel_map[(void *) lcublasZtpttr] = std::string("cublasZtpttr");
	}
	assert(lcublasZtpttr);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtpttr(handle, uplo, n, AP, A, lda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtpttr);
	}
	return res;
}

cublasStatus_t cublasStrttp(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const float*  A, int  lda, float*  AP)
{
	static cublasStatus_t (*lcublasStrttp) (cublasHandle_t , cublasFillMode_t , int , const float* , int , float* );
	if (!lcublasStrttp) {
		lcublasStrttp = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const float* , int , float* )) dlsym(RTLD_NEXT, "cublasStrttp");
		tracer._kernel_map[(void *) lcublasStrttp] = std::string("cublasStrttp");
	}
	assert(lcublasStrttp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasStrttp(handle, uplo, n, A, lda, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasStrttp);
	}
	return res;
}

cublasStatus_t cublasDtrttp(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const double*  A, int  lda, double*  AP)
{
	static cublasStatus_t (*lcublasDtrttp) (cublasHandle_t , cublasFillMode_t , int , const double* , int , double* );
	if (!lcublasDtrttp) {
		lcublasDtrttp = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const double* , int , double* )) dlsym(RTLD_NEXT, "cublasDtrttp");
		tracer._kernel_map[(void *) lcublasDtrttp] = std::string("cublasDtrttp");
	}
	assert(lcublasDtrttp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDtrttp(handle, uplo, n, A, lda, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDtrttp);
	}
	return res;
}

cublasStatus_t cublasCtrttp(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuComplex*  A, int  lda, cuComplex*  AP)
{
	static cublasStatus_t (*lcublasCtrttp) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , int , cuComplex* );
	if (!lcublasCtrttp) {
		lcublasCtrttp = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuComplex* , int , cuComplex* )) dlsym(RTLD_NEXT, "cublasCtrttp");
		tracer._kernel_map[(void *) lcublasCtrttp] = std::string("cublasCtrttp");
	}
	assert(lcublasCtrttp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCtrttp(handle, uplo, n, A, lda, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCtrttp);
	}
	return res;
}

cublasStatus_t cublasZtrttp(cublasHandle_t  handle, cublasFillMode_t  uplo, int  n, const cuDoubleComplex*  A, int  lda, cuDoubleComplex*  AP)
{
	static cublasStatus_t (*lcublasZtrttp) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , int , cuDoubleComplex* );
	if (!lcublasZtrttp) {
		lcublasZtrttp = (cublasStatus_t (*) (cublasHandle_t , cublasFillMode_t , int , const cuDoubleComplex* , int , cuDoubleComplex* )) dlsym(RTLD_NEXT, "cublasZtrttp");
		tracer._kernel_map[(void *) lcublasZtrttp] = std::string("cublasZtrttp");
	}
	assert(lcublasZtrttp);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZtrttp(handle, uplo, n, A, lda, AP);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZtrttp);
	}
	return res;
}

cublasStatus_t cublasSgetrfBatched(cublasHandle_t  handle, int  n, float* const  A[], int  lda, int*  P, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasSgetrfBatched) (cublasHandle_t , int , float* const [], int , int* , int* , int );
	if (!lcublasSgetrfBatched) {
		lcublasSgetrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , float* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasSgetrfBatched");
		tracer._kernel_map[(void *) lcublasSgetrfBatched] = std::string("cublasSgetrfBatched");
	}
	assert(lcublasSgetrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgetrfBatched(handle, n, A, lda, P, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgetrfBatched);
	}
	return res;
}

cublasStatus_t cublasDgetrfBatched(cublasHandle_t  handle, int  n, double* const  A[], int  lda, int*  P, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasDgetrfBatched) (cublasHandle_t , int , double* const [], int , int* , int* , int );
	if (!lcublasDgetrfBatched) {
		lcublasDgetrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , double* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasDgetrfBatched");
		tracer._kernel_map[(void *) lcublasDgetrfBatched] = std::string("cublasDgetrfBatched");
	}
	assert(lcublasDgetrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgetrfBatched(handle, n, A, lda, P, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgetrfBatched);
	}
	return res;
}

cublasStatus_t cublasCgetrfBatched(cublasHandle_t  handle, int  n, cuComplex* const  A[], int  lda, int*  P, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasCgetrfBatched) (cublasHandle_t , int , cuComplex* const [], int , int* , int* , int );
	if (!lcublasCgetrfBatched) {
		lcublasCgetrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , cuComplex* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasCgetrfBatched");
		tracer._kernel_map[(void *) lcublasCgetrfBatched] = std::string("cublasCgetrfBatched");
	}
	assert(lcublasCgetrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgetrfBatched(handle, n, A, lda, P, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgetrfBatched);
	}
	return res;
}

cublasStatus_t cublasZgetrfBatched(cublasHandle_t  handle, int  n, cuDoubleComplex* const  A[], int  lda, int*  P, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasZgetrfBatched) (cublasHandle_t , int , cuDoubleComplex* const [], int , int* , int* , int );
	if (!lcublasZgetrfBatched) {
		lcublasZgetrfBatched = (cublasStatus_t (*) (cublasHandle_t , int , cuDoubleComplex* const [], int , int* , int* , int )) dlsym(RTLD_NEXT, "cublasZgetrfBatched");
		tracer._kernel_map[(void *) lcublasZgetrfBatched] = std::string("cublasZgetrfBatched");
	}
	assert(lcublasZgetrfBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgetrfBatched(handle, n, A, lda, P, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgetrfBatched);
	}
	return res;
}

cublasStatus_t cublasSgetriBatched(cublasHandle_t  handle, int  n, const float* const  A[], int  lda, const int*  P, float* const  C[], int  ldc, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasSgetriBatched) (cublasHandle_t , int , const float* const [], int , const int* , float* const [], int , int* , int );
	if (!lcublasSgetriBatched) {
		lcublasSgetriBatched = (cublasStatus_t (*) (cublasHandle_t , int , const float* const [], int , const int* , float* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasSgetriBatched");
		tracer._kernel_map[(void *) lcublasSgetriBatched] = std::string("cublasSgetriBatched");
	}
	assert(lcublasSgetriBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgetriBatched(handle, n, A, lda, P, C, ldc, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgetriBatched);
	}
	return res;
}

cublasStatus_t cublasDgetriBatched(cublasHandle_t  handle, int  n, const double* const  A[], int  lda, const int*  P, double* const  C[], int  ldc, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasDgetriBatched) (cublasHandle_t , int , const double* const [], int , const int* , double* const [], int , int* , int );
	if (!lcublasDgetriBatched) {
		lcublasDgetriBatched = (cublasStatus_t (*) (cublasHandle_t , int , const double* const [], int , const int* , double* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasDgetriBatched");
		tracer._kernel_map[(void *) lcublasDgetriBatched] = std::string("cublasDgetriBatched");
	}
	assert(lcublasDgetriBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgetriBatched(handle, n, A, lda, P, C, ldc, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgetriBatched);
	}
	return res;
}

cublasStatus_t cublasCgetriBatched(cublasHandle_t  handle, int  n, const cuComplex* const  A[], int  lda, const int*  P, cuComplex* const  C[], int  ldc, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasCgetriBatched) (cublasHandle_t , int , const cuComplex* const [], int , const int* , cuComplex* const [], int , int* , int );
	if (!lcublasCgetriBatched) {
		lcublasCgetriBatched = (cublasStatus_t (*) (cublasHandle_t , int , const cuComplex* const [], int , const int* , cuComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasCgetriBatched");
		tracer._kernel_map[(void *) lcublasCgetriBatched] = std::string("cublasCgetriBatched");
	}
	assert(lcublasCgetriBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgetriBatched(handle, n, A, lda, P, C, ldc, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgetriBatched);
	}
	return res;
}

cublasStatus_t cublasZgetriBatched(cublasHandle_t  handle, int  n, const cuDoubleComplex* const  A[], int  lda, const int*  P, cuDoubleComplex* const  C[], int  ldc, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasZgetriBatched) (cublasHandle_t , int , const cuDoubleComplex* const [], int , const int* , cuDoubleComplex* const [], int , int* , int );
	if (!lcublasZgetriBatched) {
		lcublasZgetriBatched = (cublasStatus_t (*) (cublasHandle_t , int , const cuDoubleComplex* const [], int , const int* , cuDoubleComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasZgetriBatched");
		tracer._kernel_map[(void *) lcublasZgetriBatched] = std::string("cublasZgetriBatched");
	}
	assert(lcublasZgetriBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgetriBatched(handle, n, A, lda, P, C, ldc, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgetriBatched);
	}
	return res;
}

cublasStatus_t cublasSgetrsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  n, int  nrhs, const float* const  Aarray[], int  lda, const int*  devIpiv, float* const  Barray[], int  ldb, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasSgetrsBatched) (cublasHandle_t , cublasOperation_t , int , int , const float* const [], int , const int* , float* const [], int , int* , int );
	if (!lcublasSgetrsBatched) {
		lcublasSgetrsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const float* const [], int , const int* , float* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasSgetrsBatched");
		tracer._kernel_map[(void *) lcublasSgetrsBatched] = std::string("cublasSgetrsBatched");
	}
	assert(lcublasSgetrsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasSgetrsBatched(handle, trans, n, nrhs, Aarray, lda, devIpiv, Barray, ldb, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasSgetrsBatched);
	}
	return res;
}

cublasStatus_t cublasDgetrsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  n, int  nrhs, const double* const  Aarray[], int  lda, const int*  devIpiv, double* const  Barray[], int  ldb, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasDgetrsBatched) (cublasHandle_t , cublasOperation_t , int , int , const double* const [], int , const int* , double* const [], int , int* , int );
	if (!lcublasDgetrsBatched) {
		lcublasDgetrsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const double* const [], int , const int* , double* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasDgetrsBatched");
		tracer._kernel_map[(void *) lcublasDgetrsBatched] = std::string("cublasDgetrsBatched");
	}
	assert(lcublasDgetrsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasDgetrsBatched(handle, trans, n, nrhs, Aarray, lda, devIpiv, Barray, ldb, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasDgetrsBatched);
	}
	return res;
}

cublasStatus_t cublasCgetrsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  n, int  nrhs, const cuComplex* const  Aarray[], int  lda, const int*  devIpiv, cuComplex* const  Barray[], int  ldb, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasCgetrsBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* const [], int , const int* , cuComplex* const [], int , int* , int );
	if (!lcublasCgetrsBatched) {
		lcublasCgetrsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuComplex* const [], int , const int* , cuComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasCgetrsBatched");
		tracer._kernel_map[(void *) lcublasCgetrsBatched] = std::string("cublasCgetrsBatched");
	}
	assert(lcublasCgetrsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasCgetrsBatched(handle, trans, n, nrhs, Aarray, lda, devIpiv, Barray, ldb, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasCgetrsBatched);
	}
	return res;
}

cublasStatus_t cublasZgetrsBatched(cublasHandle_t  handle, cublasOperation_t  trans, int  n, int  nrhs, const cuDoubleComplex* const  Aarray[], int  lda, const int*  devIpiv, cuDoubleComplex* const  Barray[], int  ldb, int*  info, int  batchSize)
{
	static cublasStatus_t (*lcublasZgetrsBatched) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* const [], int , const int* , cuDoubleComplex* const [], int , int* , int );
	if (!lcublasZgetrsBatched) {
		lcublasZgetrsBatched = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , int , int , const cuDoubleComplex* const [], int , const int* , cuDoubleComplex* const [], int , int* , int )) dlsym(RTLD_NEXT, "cublasZgetrsBatched");
		tracer._kernel_map[(void *) lcublasZgetrsBatched] = std::string("cublasZgetrsBatched");
	}
	assert(lcublasZgetrsBatched);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasZgetrsBatched(handle, trans, n, nrhs, Aarray, lda, devIpiv, Barray, ldb, info, batchSize);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasZgetrsBatched);
	}
	return res;
}

cublasStatus_t cublasUint8gemmBias(cublasHandle_t  handle, cublasOperation_t  transa, cublasOperation_t  transb, cublasOperation_t  transc, int  m, int  n, int  k, const unsigned char*  A, int  A_bias, int  lda, const unsigned char*  B, int  B_bias, int  ldb, unsigned char*  C, int  C_bias, int  ldc, int  C_mult, int  C_shift)
{
	static cublasStatus_t (*lcublasUint8gemmBias) (cublasHandle_t , cublasOperation_t , cublasOperation_t , cublasOperation_t , int , int , int , const unsigned char* , int , int , const unsigned char* , int , int , unsigned char* , int , int , int , int );
	if (!lcublasUint8gemmBias) {
		lcublasUint8gemmBias = (cublasStatus_t (*) (cublasHandle_t , cublasOperation_t , cublasOperation_t , cublasOperation_t , int , int , int , const unsigned char* , int , int , const unsigned char* , int , int , unsigned char* , int , int , int , int )) dlsym(RTLD_NEXT, "cublasUint8gemmBias");
		tracer._kernel_map[(void *) lcublasUint8gemmBias] = std::string("cublasUint8gemmBias");
	}
	assert(lcublasUint8gemmBias);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasUint8gemmBias(handle, transa, transb, transc, m, n, k, A, A_bias, lda, B, B_bias, ldb, C, C_bias, ldc, C_mult, C_shift);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasUint8gemmBias);
	}
	return res;
}


cudaError_t cudaProfilerStart()
{
	static cudaError_t (*lcudaProfilerStart) ();
	if (!lcudaProfilerStart) {
		lcudaProfilerStart = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaProfilerStart");
	}
	assert(lcudaProfilerStart);

    tracer.profile_start = true;
    return lcudaProfilerStart();
}
        


cudaError_t cudaProfilerStop()
{
	static cudaError_t (*lcudaProfilerStop) ();
	if (!lcudaProfilerStop) {
		lcudaProfilerStop = (cudaError_t (*) ()) dlsym(RTLD_NEXT, "cudaProfilerStop");
	}
	assert(lcudaProfilerStop);

    tracer.profile_start = false;
    return lcudaProfilerStop();
}
        

CUresult cuProfilerInitialize(const char * configFile, const char * outputFile, CUoutput_mode  outputMode)
{
	static CUresult (*lcuProfilerInitialize) (const char *, const char *, CUoutput_mode );
	if (!lcuProfilerInitialize) {
		lcuProfilerInitialize = (CUresult (*) (const char *, const char *, CUoutput_mode )) dlsym(RTLD_NEXT, "cuProfilerInitialize");
		tracer._kernel_map[(void *) lcuProfilerInitialize] = std::string("cuProfilerInitialize");
	}
	assert(lcuProfilerInitialize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuProfilerInitialize(configFile, outputFile, outputMode);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuProfilerInitialize);
	}
	return res;
}

CUresult cuProfilerStart()
{
	static CUresult (*lcuProfilerStart) ();
	if (!lcuProfilerStart) {
		lcuProfilerStart = (CUresult (*) ()) dlsym(RTLD_NEXT, "cuProfilerStart");
		tracer._kernel_map[(void *) lcuProfilerStart] = std::string("cuProfilerStart");
	}
	assert(lcuProfilerStart);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuProfilerStart();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuProfilerStart);
	}
	return res;
}

CUresult cuProfilerStop()
{
	static CUresult (*lcuProfilerStop) ();
	if (!lcuProfilerStop) {
		lcuProfilerStop = (CUresult (*) ()) dlsym(RTLD_NEXT, "cuProfilerStop");
		tracer._kernel_map[(void *) lcuProfilerStop] = std::string("cuProfilerStop");
	}
	assert(lcuProfilerStop);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	CUresult res = 
		lcuProfilerStop();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcuProfilerStop);
	}
	return res;
}

const char * nvrtcGetErrorString(nvrtcResult  result)
{
	static const char * (*lnvrtcGetErrorString) (nvrtcResult );
	if (!lnvrtcGetErrorString) {
		lnvrtcGetErrorString = (const char * (*) (nvrtcResult )) dlsym(RTLD_NEXT, "nvrtcGetErrorString");
		tracer._kernel_map[(void *) lnvrtcGetErrorString] = std::string("nvrtcGetErrorString");
	}
	assert(lnvrtcGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char * res = 
		lnvrtcGetErrorString(result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetErrorString);
	}
	return res;
}

nvrtcResult nvrtcVersion(int * major, int * minor)
{
	static nvrtcResult (*lnvrtcVersion) (int *, int *);
	if (!lnvrtcVersion) {
		lnvrtcVersion = (nvrtcResult (*) (int *, int *)) dlsym(RTLD_NEXT, "nvrtcVersion");
		tracer._kernel_map[(void *) lnvrtcVersion] = std::string("nvrtcVersion");
	}
	assert(lnvrtcVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcVersion(major, minor);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcVersion);
	}
	return res;
}

nvrtcResult nvrtcGetNumSupportedArchs(int*  numArchs)
{
	static nvrtcResult (*lnvrtcGetNumSupportedArchs) (int* );
	if (!lnvrtcGetNumSupportedArchs) {
		lnvrtcGetNumSupportedArchs = (nvrtcResult (*) (int* )) dlsym(RTLD_NEXT, "nvrtcGetNumSupportedArchs");
		tracer._kernel_map[(void *) lnvrtcGetNumSupportedArchs] = std::string("nvrtcGetNumSupportedArchs");
	}
	assert(lnvrtcGetNumSupportedArchs);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetNumSupportedArchs(numArchs);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetNumSupportedArchs);
	}
	return res;
}

nvrtcResult nvrtcGetSupportedArchs(int*  supportedArchs)
{
	static nvrtcResult (*lnvrtcGetSupportedArchs) (int* );
	if (!lnvrtcGetSupportedArchs) {
		lnvrtcGetSupportedArchs = (nvrtcResult (*) (int* )) dlsym(RTLD_NEXT, "nvrtcGetSupportedArchs");
		tracer._kernel_map[(void *) lnvrtcGetSupportedArchs] = std::string("nvrtcGetSupportedArchs");
	}
	assert(lnvrtcGetSupportedArchs);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetSupportedArchs(supportedArchs);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetSupportedArchs);
	}
	return res;
}

nvrtcResult nvrtcCreateProgram(nvrtcProgram * prog, const char * src, const char * name, int  numHeaders, const char * const * headers, const char * const * includeNames)
{
	static nvrtcResult (*lnvrtcCreateProgram) (nvrtcProgram *, const char *, const char *, int , const char * const *, const char * const *);
	if (!lnvrtcCreateProgram) {
		lnvrtcCreateProgram = (nvrtcResult (*) (nvrtcProgram *, const char *, const char *, int , const char * const *, const char * const *)) dlsym(RTLD_NEXT, "nvrtcCreateProgram");
		tracer._kernel_map[(void *) lnvrtcCreateProgram] = std::string("nvrtcCreateProgram");
	}
	assert(lnvrtcCreateProgram);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcCreateProgram(prog, src, name, numHeaders, headers, includeNames);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcCreateProgram);
	}
	return res;
}

nvrtcResult nvrtcDestroyProgram(nvrtcProgram * prog)
{
	static nvrtcResult (*lnvrtcDestroyProgram) (nvrtcProgram *);
	if (!lnvrtcDestroyProgram) {
		lnvrtcDestroyProgram = (nvrtcResult (*) (nvrtcProgram *)) dlsym(RTLD_NEXT, "nvrtcDestroyProgram");
		tracer._kernel_map[(void *) lnvrtcDestroyProgram] = std::string("nvrtcDestroyProgram");
	}
	assert(lnvrtcDestroyProgram);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcDestroyProgram(prog);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcDestroyProgram);
	}
	return res;
}

nvrtcResult nvrtcCompileProgram(nvrtcProgram  prog, int  numOptions, const char * const * options)
{
	static nvrtcResult (*lnvrtcCompileProgram) (nvrtcProgram , int , const char * const *);
	if (!lnvrtcCompileProgram) {
		lnvrtcCompileProgram = (nvrtcResult (*) (nvrtcProgram , int , const char * const *)) dlsym(RTLD_NEXT, "nvrtcCompileProgram");
		tracer._kernel_map[(void *) lnvrtcCompileProgram] = std::string("nvrtcCompileProgram");
	}
	assert(lnvrtcCompileProgram);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcCompileProgram(prog, numOptions, options);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcCompileProgram);
	}
	return res;
}

nvrtcResult nvrtcGetPTXSize(nvrtcProgram  prog, size_t * ptxSizeRet)
{
	static nvrtcResult (*lnvrtcGetPTXSize) (nvrtcProgram , size_t *);
	if (!lnvrtcGetPTXSize) {
		lnvrtcGetPTXSize = (nvrtcResult (*) (nvrtcProgram , size_t *)) dlsym(RTLD_NEXT, "nvrtcGetPTXSize");
		tracer._kernel_map[(void *) lnvrtcGetPTXSize] = std::string("nvrtcGetPTXSize");
	}
	assert(lnvrtcGetPTXSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetPTXSize(prog, ptxSizeRet);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetPTXSize);
	}
	return res;
}

nvrtcResult nvrtcGetPTX(nvrtcProgram  prog, char * ptx)
{
	static nvrtcResult (*lnvrtcGetPTX) (nvrtcProgram , char *);
	if (!lnvrtcGetPTX) {
		lnvrtcGetPTX = (nvrtcResult (*) (nvrtcProgram , char *)) dlsym(RTLD_NEXT, "nvrtcGetPTX");
		tracer._kernel_map[(void *) lnvrtcGetPTX] = std::string("nvrtcGetPTX");
	}
	assert(lnvrtcGetPTX);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetPTX(prog, ptx);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetPTX);
	}
	return res;
}

nvrtcResult nvrtcGetCUBINSize(nvrtcProgram  prog, size_t * cubinSizeRet)
{
	static nvrtcResult (*lnvrtcGetCUBINSize) (nvrtcProgram , size_t *);
	if (!lnvrtcGetCUBINSize) {
		lnvrtcGetCUBINSize = (nvrtcResult (*) (nvrtcProgram , size_t *)) dlsym(RTLD_NEXT, "nvrtcGetCUBINSize");
		tracer._kernel_map[(void *) lnvrtcGetCUBINSize] = std::string("nvrtcGetCUBINSize");
	}
	assert(lnvrtcGetCUBINSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetCUBINSize(prog, cubinSizeRet);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetCUBINSize);
	}
	return res;
}

nvrtcResult nvrtcGetCUBIN(nvrtcProgram  prog, char * cubin)
{
	static nvrtcResult (*lnvrtcGetCUBIN) (nvrtcProgram , char *);
	if (!lnvrtcGetCUBIN) {
		lnvrtcGetCUBIN = (nvrtcResult (*) (nvrtcProgram , char *)) dlsym(RTLD_NEXT, "nvrtcGetCUBIN");
		tracer._kernel_map[(void *) lnvrtcGetCUBIN] = std::string("nvrtcGetCUBIN");
	}
	assert(lnvrtcGetCUBIN);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetCUBIN(prog, cubin);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetCUBIN);
	}
	return res;
}

nvrtcResult nvrtcGetLTOIRSize(nvrtcProgram  prog, size_t * LTOIRSizeRet)
{
	static nvrtcResult (*lnvrtcGetLTOIRSize) (nvrtcProgram , size_t *);
	if (!lnvrtcGetLTOIRSize) {
		lnvrtcGetLTOIRSize = (nvrtcResult (*) (nvrtcProgram , size_t *)) dlsym(RTLD_NEXT, "nvrtcGetLTOIRSize");
		tracer._kernel_map[(void *) lnvrtcGetLTOIRSize] = std::string("nvrtcGetLTOIRSize");
	}
	assert(lnvrtcGetLTOIRSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetLTOIRSize(prog, LTOIRSizeRet);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetLTOIRSize);
	}
	return res;
}

nvrtcResult nvrtcGetLTOIR(nvrtcProgram  prog, char * LTOIR)
{
	static nvrtcResult (*lnvrtcGetLTOIR) (nvrtcProgram , char *);
	if (!lnvrtcGetLTOIR) {
		lnvrtcGetLTOIR = (nvrtcResult (*) (nvrtcProgram , char *)) dlsym(RTLD_NEXT, "nvrtcGetLTOIR");
		tracer._kernel_map[(void *) lnvrtcGetLTOIR] = std::string("nvrtcGetLTOIR");
	}
	assert(lnvrtcGetLTOIR);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetLTOIR(prog, LTOIR);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetLTOIR);
	}
	return res;
}

nvrtcResult nvrtcGetOptiXIRSize(nvrtcProgram  prog, size_t * optixirSizeRet)
{
	static nvrtcResult (*lnvrtcGetOptiXIRSize) (nvrtcProgram , size_t *);
	if (!lnvrtcGetOptiXIRSize) {
		lnvrtcGetOptiXIRSize = (nvrtcResult (*) (nvrtcProgram , size_t *)) dlsym(RTLD_NEXT, "nvrtcGetOptiXIRSize");
		tracer._kernel_map[(void *) lnvrtcGetOptiXIRSize] = std::string("nvrtcGetOptiXIRSize");
	}
	assert(lnvrtcGetOptiXIRSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetOptiXIRSize(prog, optixirSizeRet);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetOptiXIRSize);
	}
	return res;
}

nvrtcResult nvrtcGetOptiXIR(nvrtcProgram  prog, char * optixir)
{
	static nvrtcResult (*lnvrtcGetOptiXIR) (nvrtcProgram , char *);
	if (!lnvrtcGetOptiXIR) {
		lnvrtcGetOptiXIR = (nvrtcResult (*) (nvrtcProgram , char *)) dlsym(RTLD_NEXT, "nvrtcGetOptiXIR");
		tracer._kernel_map[(void *) lnvrtcGetOptiXIR] = std::string("nvrtcGetOptiXIR");
	}
	assert(lnvrtcGetOptiXIR);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetOptiXIR(prog, optixir);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetOptiXIR);
	}
	return res;
}

nvrtcResult nvrtcGetProgramLogSize(nvrtcProgram  prog, size_t * logSizeRet)
{
	static nvrtcResult (*lnvrtcGetProgramLogSize) (nvrtcProgram , size_t *);
	if (!lnvrtcGetProgramLogSize) {
		lnvrtcGetProgramLogSize = (nvrtcResult (*) (nvrtcProgram , size_t *)) dlsym(RTLD_NEXT, "nvrtcGetProgramLogSize");
		tracer._kernel_map[(void *) lnvrtcGetProgramLogSize] = std::string("nvrtcGetProgramLogSize");
	}
	assert(lnvrtcGetProgramLogSize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetProgramLogSize(prog, logSizeRet);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetProgramLogSize);
	}
	return res;
}

nvrtcResult nvrtcGetProgramLog(nvrtcProgram  prog, char * log)
{
	static nvrtcResult (*lnvrtcGetProgramLog) (nvrtcProgram , char *);
	if (!lnvrtcGetProgramLog) {
		lnvrtcGetProgramLog = (nvrtcResult (*) (nvrtcProgram , char *)) dlsym(RTLD_NEXT, "nvrtcGetProgramLog");
		tracer._kernel_map[(void *) lnvrtcGetProgramLog] = std::string("nvrtcGetProgramLog");
	}
	assert(lnvrtcGetProgramLog);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetProgramLog(prog, log);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetProgramLog);
	}
	return res;
}

nvrtcResult nvrtcAddNameExpression(nvrtcProgram  prog, const char * const  name_expression)
{
	static nvrtcResult (*lnvrtcAddNameExpression) (nvrtcProgram , const char * const );
	if (!lnvrtcAddNameExpression) {
		lnvrtcAddNameExpression = (nvrtcResult (*) (nvrtcProgram , const char * const )) dlsym(RTLD_NEXT, "nvrtcAddNameExpression");
		tracer._kernel_map[(void *) lnvrtcAddNameExpression] = std::string("nvrtcAddNameExpression");
	}
	assert(lnvrtcAddNameExpression);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcAddNameExpression(prog, name_expression);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcAddNameExpression);
	}
	return res;
}

nvrtcResult nvrtcGetLoweredName(nvrtcProgram  prog, const char *const  name_expression, const char**  lowered_name)
{
	static nvrtcResult (*lnvrtcGetLoweredName) (nvrtcProgram , const char *const , const char** );
	if (!lnvrtcGetLoweredName) {
		lnvrtcGetLoweredName = (nvrtcResult (*) (nvrtcProgram , const char *const , const char** )) dlsym(RTLD_NEXT, "nvrtcGetLoweredName");
		tracer._kernel_map[(void *) lnvrtcGetLoweredName] = std::string("nvrtcGetLoweredName");
	}
	assert(lnvrtcGetLoweredName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	nvrtcResult res = 
		lnvrtcGetLoweredName(prog, name_expression, lowered_name);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lnvrtcGetLoweredName);
	}
	return res;
}

cublasStatus_t cublasLtCreate(cublasLtHandle_t*  lightHandle)
{
	static cublasStatus_t (*lcublasLtCreate) (cublasLtHandle_t* );
	if (!lcublasLtCreate) {
		lcublasLtCreate = (cublasStatus_t (*) (cublasLtHandle_t* )) dlsym(RTLD_NEXT, "cublasLtCreate");
		tracer._kernel_map[(void *) lcublasLtCreate] = std::string("cublasLtCreate");
	}
	assert(lcublasLtCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtCreate(lightHandle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtCreate);
	}
	return res;
}

cublasStatus_t cublasLtDestroy(cublasLtHandle_t  lightHandle)
{
	static cublasStatus_t (*lcublasLtDestroy) (cublasLtHandle_t );
	if (!lcublasLtDestroy) {
		lcublasLtDestroy = (cublasStatus_t (*) (cublasLtHandle_t )) dlsym(RTLD_NEXT, "cublasLtDestroy");
		tracer._kernel_map[(void *) lcublasLtDestroy] = std::string("cublasLtDestroy");
	}
	assert(lcublasLtDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtDestroy(lightHandle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtDestroy);
	}
	return res;
}

const char* cublasLtGetStatusName(cublasStatus_t  status)
{
	static const char* (*lcublasLtGetStatusName) (cublasStatus_t );
	if (!lcublasLtGetStatusName) {
		lcublasLtGetStatusName = (const char* (*) (cublasStatus_t )) dlsym(RTLD_NEXT, "cublasLtGetStatusName");
		tracer._kernel_map[(void *) lcublasLtGetStatusName] = std::string("cublasLtGetStatusName");
	}
	assert(lcublasLtGetStatusName);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcublasLtGetStatusName(status);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtGetStatusName);
	}
	return res;
}

const char* cublasLtGetStatusString(cublasStatus_t  status)
{
	static const char* (*lcublasLtGetStatusString) (cublasStatus_t );
	if (!lcublasLtGetStatusString) {
		lcublasLtGetStatusString = (const char* (*) (cublasStatus_t )) dlsym(RTLD_NEXT, "cublasLtGetStatusString");
		tracer._kernel_map[(void *) lcublasLtGetStatusString] = std::string("cublasLtGetStatusString");
	}
	assert(lcublasLtGetStatusString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lcublasLtGetStatusString(status);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtGetStatusString);
	}
	return res;
}

size_t cublasLtGetVersion()
{
	static size_t (*lcublasLtGetVersion) ();
	if (!lcublasLtGetVersion) {
		lcublasLtGetVersion = (size_t (*) ()) dlsym(RTLD_NEXT, "cublasLtGetVersion");
		tracer._kernel_map[(void *) lcublasLtGetVersion] = std::string("cublasLtGetVersion");
	}
	assert(lcublasLtGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcublasLtGetVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtGetVersion);
	}
	return res;
}

size_t cublasLtGetCudartVersion()
{
	static size_t (*lcublasLtGetCudartVersion) ();
	if (!lcublasLtGetCudartVersion) {
		lcublasLtGetCudartVersion = (size_t (*) ()) dlsym(RTLD_NEXT, "cublasLtGetCudartVersion");
		tracer._kernel_map[(void *) lcublasLtGetCudartVersion] = std::string("cublasLtGetCudartVersion");
	}
	assert(lcublasLtGetCudartVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	size_t res = 
		lcublasLtGetCudartVersion();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtGetCudartVersion);
	}
	return res;
}

cublasStatus_t cublasLtGetProperty(libraryPropertyType  type, int*  value)
{
	static cublasStatus_t (*lcublasLtGetProperty) (libraryPropertyType , int* );
	if (!lcublasLtGetProperty) {
		lcublasLtGetProperty = (cublasStatus_t (*) (libraryPropertyType , int* )) dlsym(RTLD_NEXT, "cublasLtGetProperty");
		tracer._kernel_map[(void *) lcublasLtGetProperty] = std::string("cublasLtGetProperty");
	}
	assert(lcublasLtGetProperty);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtGetProperty(type, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtGetProperty);
	}
	return res;
}

cublasStatus_t cublasLtHeuristicsCacheGetCapacity(size_t*  capacity)
{
	static cublasStatus_t (*lcublasLtHeuristicsCacheGetCapacity) (size_t* );
	if (!lcublasLtHeuristicsCacheGetCapacity) {
		lcublasLtHeuristicsCacheGetCapacity = (cublasStatus_t (*) (size_t* )) dlsym(RTLD_NEXT, "cublasLtHeuristicsCacheGetCapacity");
		tracer._kernel_map[(void *) lcublasLtHeuristicsCacheGetCapacity] = std::string("cublasLtHeuristicsCacheGetCapacity");
	}
	assert(lcublasLtHeuristicsCacheGetCapacity);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtHeuristicsCacheGetCapacity(capacity);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtHeuristicsCacheGetCapacity);
	}
	return res;
}

cublasStatus_t cublasLtHeuristicsCacheSetCapacity(size_t  capacity)
{
	static cublasStatus_t (*lcublasLtHeuristicsCacheSetCapacity) (size_t );
	if (!lcublasLtHeuristicsCacheSetCapacity) {
		lcublasLtHeuristicsCacheSetCapacity = (cublasStatus_t (*) (size_t )) dlsym(RTLD_NEXT, "cublasLtHeuristicsCacheSetCapacity");
		tracer._kernel_map[(void *) lcublasLtHeuristicsCacheSetCapacity] = std::string("cublasLtHeuristicsCacheSetCapacity");
	}
	assert(lcublasLtHeuristicsCacheSetCapacity);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtHeuristicsCacheSetCapacity(capacity);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtHeuristicsCacheSetCapacity);
	}
	return res;
}

unsigned cublasLtDisableCpuInstructionsSetMask(unsigned  mask)
{
	static unsigned (*lcublasLtDisableCpuInstructionsSetMask) (unsigned );
	if (!lcublasLtDisableCpuInstructionsSetMask) {
		lcublasLtDisableCpuInstructionsSetMask = (unsigned (*) (unsigned )) dlsym(RTLD_NEXT, "cublasLtDisableCpuInstructionsSetMask");
		tracer._kernel_map[(void *) lcublasLtDisableCpuInstructionsSetMask] = std::string("cublasLtDisableCpuInstructionsSetMask");
	}
	assert(lcublasLtDisableCpuInstructionsSetMask);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	unsigned res = 
		lcublasLtDisableCpuInstructionsSetMask(mask);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtDisableCpuInstructionsSetMask);
	}
	return res;
}

cublasStatus_t cublasLtMatmul(cublasLtHandle_t  lightHandle, cublasLtMatmulDesc_t  computeDesc, const void*  alpha, const void*  A, cublasLtMatrixLayout_t  Adesc, const void*  B, cublasLtMatrixLayout_t  Bdesc, const void*  beta, const void*  C, cublasLtMatrixLayout_t  Cdesc, void*  D, cublasLtMatrixLayout_t  Ddesc, const cublasLtMatmulAlgo_t*  algo, void*  workspace, size_t  workspaceSizeInBytes, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasLtMatmul) (cublasLtHandle_t , cublasLtMatmulDesc_t , const void* , const void* , cublasLtMatrixLayout_t , const void* , cublasLtMatrixLayout_t , const void* , const void* , cublasLtMatrixLayout_t , void* , cublasLtMatrixLayout_t , const cublasLtMatmulAlgo_t* , void* , size_t , cudaStream_t );
	if (!lcublasLtMatmul) {
		lcublasLtMatmul = (cublasStatus_t (*) (cublasLtHandle_t , cublasLtMatmulDesc_t , const void* , const void* , cublasLtMatrixLayout_t , const void* , cublasLtMatrixLayout_t , const void* , const void* , cublasLtMatrixLayout_t , void* , cublasLtMatrixLayout_t , const cublasLtMatmulAlgo_t* , void* , size_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasLtMatmul");
		tracer._kernel_map[(void *) lcublasLtMatmul] = std::string("cublasLtMatmul");
	}
	assert(lcublasLtMatmul);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmul(lightHandle, computeDesc, alpha, A, Adesc, B, Bdesc, beta, C, Cdesc, D, Ddesc, algo, workspace, workspaceSizeInBytes, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmul);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransform(cublasLtHandle_t  lightHandle, cublasLtMatrixTransformDesc_t  transformDesc, const void*  alpha, const void*  A, cublasLtMatrixLayout_t  Adesc, const void*  beta, const void*  B, cublasLtMatrixLayout_t  Bdesc, void*  C, cublasLtMatrixLayout_t  Cdesc, cudaStream_t  stream)
{
	static cublasStatus_t (*lcublasLtMatrixTransform) (cublasLtHandle_t , cublasLtMatrixTransformDesc_t , const void* , const void* , cublasLtMatrixLayout_t , const void* , const void* , cublasLtMatrixLayout_t , void* , cublasLtMatrixLayout_t , cudaStream_t );
	if (!lcublasLtMatrixTransform) {
		lcublasLtMatrixTransform = (cublasStatus_t (*) (cublasLtHandle_t , cublasLtMatrixTransformDesc_t , const void* , const void* , cublasLtMatrixLayout_t , const void* , const void* , cublasLtMatrixLayout_t , void* , cublasLtMatrixLayout_t , cudaStream_t )) dlsym(RTLD_NEXT, "cublasLtMatrixTransform");
		tracer._kernel_map[(void *) lcublasLtMatrixTransform] = std::string("cublasLtMatrixTransform");
	}
	assert(lcublasLtMatrixTransform);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransform(lightHandle, transformDesc, alpha, A, Adesc, beta, B, Bdesc, C, Cdesc, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransform);
	}
	return res;
}

cublasStatus_t cublasLtMatrixLayoutInit_internal(cublasLtMatrixLayout_t  matLayout, size_t  size, cudaDataType  type, uint64_t  rows, uint64_t  cols, int64_t  ld)
{
	static cublasStatus_t (*lcublasLtMatrixLayoutInit_internal) (cublasLtMatrixLayout_t , size_t , cudaDataType , uint64_t , uint64_t , int64_t );
	if (!lcublasLtMatrixLayoutInit_internal) {
		lcublasLtMatrixLayoutInit_internal = (cublasStatus_t (*) (cublasLtMatrixLayout_t , size_t , cudaDataType , uint64_t , uint64_t , int64_t )) dlsym(RTLD_NEXT, "cublasLtMatrixLayoutInit_internal");
		tracer._kernel_map[(void *) lcublasLtMatrixLayoutInit_internal] = std::string("cublasLtMatrixLayoutInit_internal");
	}
	assert(lcublasLtMatrixLayoutInit_internal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixLayoutInit_internal(matLayout, size, type, rows, cols, ld);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixLayoutInit_internal);
	}
	return res;
}

cublasStatus_t cublasLtMatrixLayoutCreate(cublasLtMatrixLayout_t*  matLayout, cudaDataType  type, uint64_t  rows, uint64_t  cols, int64_t  ld)
{
	static cublasStatus_t (*lcublasLtMatrixLayoutCreate) (cublasLtMatrixLayout_t* , cudaDataType , uint64_t , uint64_t , int64_t );
	if (!lcublasLtMatrixLayoutCreate) {
		lcublasLtMatrixLayoutCreate = (cublasStatus_t (*) (cublasLtMatrixLayout_t* , cudaDataType , uint64_t , uint64_t , int64_t )) dlsym(RTLD_NEXT, "cublasLtMatrixLayoutCreate");
		tracer._kernel_map[(void *) lcublasLtMatrixLayoutCreate] = std::string("cublasLtMatrixLayoutCreate");
	}
	assert(lcublasLtMatrixLayoutCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixLayoutCreate(matLayout, type, rows, cols, ld);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixLayoutCreate);
	}
	return res;
}

cublasStatus_t cublasLtMatrixLayoutDestroy(cublasLtMatrixLayout_t  matLayout)
{
	static cublasStatus_t (*lcublasLtMatrixLayoutDestroy) (cublasLtMatrixLayout_t );
	if (!lcublasLtMatrixLayoutDestroy) {
		lcublasLtMatrixLayoutDestroy = (cublasStatus_t (*) (cublasLtMatrixLayout_t )) dlsym(RTLD_NEXT, "cublasLtMatrixLayoutDestroy");
		tracer._kernel_map[(void *) lcublasLtMatrixLayoutDestroy] = std::string("cublasLtMatrixLayoutDestroy");
	}
	assert(lcublasLtMatrixLayoutDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixLayoutDestroy(matLayout);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixLayoutDestroy);
	}
	return res;
}

cublasStatus_t cublasLtMatrixLayoutSetAttribute(cublasLtMatrixLayout_t  matLayout, cublasLtMatrixLayoutAttribute_t  attr, const void*  buf, size_t  sizeInBytes)
{
	static cublasStatus_t (*lcublasLtMatrixLayoutSetAttribute) (cublasLtMatrixLayout_t , cublasLtMatrixLayoutAttribute_t , const void* , size_t );
	if (!lcublasLtMatrixLayoutSetAttribute) {
		lcublasLtMatrixLayoutSetAttribute = (cublasStatus_t (*) (cublasLtMatrixLayout_t , cublasLtMatrixLayoutAttribute_t , const void* , size_t )) dlsym(RTLD_NEXT, "cublasLtMatrixLayoutSetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatrixLayoutSetAttribute] = std::string("cublasLtMatrixLayoutSetAttribute");
	}
	assert(lcublasLtMatrixLayoutSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixLayoutSetAttribute(matLayout, attr, buf, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixLayoutSetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatrixLayoutGetAttribute(cublasLtMatrixLayout_t  matLayout, cublasLtMatrixLayoutAttribute_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatrixLayoutGetAttribute) (cublasLtMatrixLayout_t , cublasLtMatrixLayoutAttribute_t , void* , size_t , size_t* );
	if (!lcublasLtMatrixLayoutGetAttribute) {
		lcublasLtMatrixLayoutGetAttribute = (cublasStatus_t (*) (cublasLtMatrixLayout_t , cublasLtMatrixLayoutAttribute_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatrixLayoutGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatrixLayoutGetAttribute] = std::string("cublasLtMatrixLayoutGetAttribute");
	}
	assert(lcublasLtMatrixLayoutGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixLayoutGetAttribute(matLayout, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixLayoutGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulDescInit_internal(cublasLtMatmulDesc_t  matmulDesc, size_t  size, cublasComputeType_t  computeType, cudaDataType_t  scaleType)
{
	static cublasStatus_t (*lcublasLtMatmulDescInit_internal) (cublasLtMatmulDesc_t , size_t , cublasComputeType_t , cudaDataType_t );
	if (!lcublasLtMatmulDescInit_internal) {
		lcublasLtMatmulDescInit_internal = (cublasStatus_t (*) (cublasLtMatmulDesc_t , size_t , cublasComputeType_t , cudaDataType_t )) dlsym(RTLD_NEXT, "cublasLtMatmulDescInit_internal");
		tracer._kernel_map[(void *) lcublasLtMatmulDescInit_internal] = std::string("cublasLtMatmulDescInit_internal");
	}
	assert(lcublasLtMatmulDescInit_internal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulDescInit_internal(matmulDesc, size, computeType, scaleType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulDescInit_internal);
	}
	return res;
}

cublasStatus_t cublasLtMatmulDescCreate(cublasLtMatmulDesc_t*  matmulDesc, cublasComputeType_t  computeType, cudaDataType_t  scaleType)
{
	static cublasStatus_t (*lcublasLtMatmulDescCreate) (cublasLtMatmulDesc_t* , cublasComputeType_t , cudaDataType_t );
	if (!lcublasLtMatmulDescCreate) {
		lcublasLtMatmulDescCreate = (cublasStatus_t (*) (cublasLtMatmulDesc_t* , cublasComputeType_t , cudaDataType_t )) dlsym(RTLD_NEXT, "cublasLtMatmulDescCreate");
		tracer._kernel_map[(void *) lcublasLtMatmulDescCreate] = std::string("cublasLtMatmulDescCreate");
	}
	assert(lcublasLtMatmulDescCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulDescCreate(matmulDesc, computeType, scaleType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulDescCreate);
	}
	return res;
}

cublasStatus_t cublasLtMatmulDescDestroy(cublasLtMatmulDesc_t  matmulDesc)
{
	static cublasStatus_t (*lcublasLtMatmulDescDestroy) (cublasLtMatmulDesc_t );
	if (!lcublasLtMatmulDescDestroy) {
		lcublasLtMatmulDescDestroy = (cublasStatus_t (*) (cublasLtMatmulDesc_t )) dlsym(RTLD_NEXT, "cublasLtMatmulDescDestroy");
		tracer._kernel_map[(void *) lcublasLtMatmulDescDestroy] = std::string("cublasLtMatmulDescDestroy");
	}
	assert(lcublasLtMatmulDescDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulDescDestroy(matmulDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulDescDestroy);
	}
	return res;
}

cublasStatus_t cublasLtMatmulDescSetAttribute(cublasLtMatmulDesc_t  matmulDesc, cublasLtMatmulDescAttributes_t  attr, const void*  buf, size_t  sizeInBytes)
{
	static cublasStatus_t (*lcublasLtMatmulDescSetAttribute) (cublasLtMatmulDesc_t , cublasLtMatmulDescAttributes_t , const void* , size_t );
	if (!lcublasLtMatmulDescSetAttribute) {
		lcublasLtMatmulDescSetAttribute = (cublasStatus_t (*) (cublasLtMatmulDesc_t , cublasLtMatmulDescAttributes_t , const void* , size_t )) dlsym(RTLD_NEXT, "cublasLtMatmulDescSetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulDescSetAttribute] = std::string("cublasLtMatmulDescSetAttribute");
	}
	assert(lcublasLtMatmulDescSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulDescSetAttribute(matmulDesc, attr, buf, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulDescSetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulDescGetAttribute(cublasLtMatmulDesc_t  matmulDesc, cublasLtMatmulDescAttributes_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatmulDescGetAttribute) (cublasLtMatmulDesc_t , cublasLtMatmulDescAttributes_t , void* , size_t , size_t* );
	if (!lcublasLtMatmulDescGetAttribute) {
		lcublasLtMatmulDescGetAttribute = (cublasStatus_t (*) (cublasLtMatmulDesc_t , cublasLtMatmulDescAttributes_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulDescGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulDescGetAttribute] = std::string("cublasLtMatmulDescGetAttribute");
	}
	assert(lcublasLtMatmulDescGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulDescGetAttribute(matmulDesc, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulDescGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransformDescInit_internal(cublasLtMatrixTransformDesc_t  transformDesc, size_t  size, cudaDataType  scaleType)
{
	static cublasStatus_t (*lcublasLtMatrixTransformDescInit_internal) (cublasLtMatrixTransformDesc_t , size_t , cudaDataType );
	if (!lcublasLtMatrixTransformDescInit_internal) {
		lcublasLtMatrixTransformDescInit_internal = (cublasStatus_t (*) (cublasLtMatrixTransformDesc_t , size_t , cudaDataType )) dlsym(RTLD_NEXT, "cublasLtMatrixTransformDescInit_internal");
		tracer._kernel_map[(void *) lcublasLtMatrixTransformDescInit_internal] = std::string("cublasLtMatrixTransformDescInit_internal");
	}
	assert(lcublasLtMatrixTransformDescInit_internal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransformDescInit_internal(transformDesc, size, scaleType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransformDescInit_internal);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransformDescCreate(cublasLtMatrixTransformDesc_t*  transformDesc, cudaDataType  scaleType)
{
	static cublasStatus_t (*lcublasLtMatrixTransformDescCreate) (cublasLtMatrixTransformDesc_t* , cudaDataType );
	if (!lcublasLtMatrixTransformDescCreate) {
		lcublasLtMatrixTransformDescCreate = (cublasStatus_t (*) (cublasLtMatrixTransformDesc_t* , cudaDataType )) dlsym(RTLD_NEXT, "cublasLtMatrixTransformDescCreate");
		tracer._kernel_map[(void *) lcublasLtMatrixTransformDescCreate] = std::string("cublasLtMatrixTransformDescCreate");
	}
	assert(lcublasLtMatrixTransformDescCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransformDescCreate(transformDesc, scaleType);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransformDescCreate);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransformDescDestroy(cublasLtMatrixTransformDesc_t  transformDesc)
{
	static cublasStatus_t (*lcublasLtMatrixTransformDescDestroy) (cublasLtMatrixTransformDesc_t );
	if (!lcublasLtMatrixTransformDescDestroy) {
		lcublasLtMatrixTransformDescDestroy = (cublasStatus_t (*) (cublasLtMatrixTransformDesc_t )) dlsym(RTLD_NEXT, "cublasLtMatrixTransformDescDestroy");
		tracer._kernel_map[(void *) lcublasLtMatrixTransformDescDestroy] = std::string("cublasLtMatrixTransformDescDestroy");
	}
	assert(lcublasLtMatrixTransformDescDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransformDescDestroy(transformDesc);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransformDescDestroy);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransformDescSetAttribute(cublasLtMatrixTransformDesc_t  transformDesc, cublasLtMatrixTransformDescAttributes_t  attr, const void*  buf, size_t  sizeInBytes)
{
	static cublasStatus_t (*lcublasLtMatrixTransformDescSetAttribute) (cublasLtMatrixTransformDesc_t , cublasLtMatrixTransformDescAttributes_t , const void* , size_t );
	if (!lcublasLtMatrixTransformDescSetAttribute) {
		lcublasLtMatrixTransformDescSetAttribute = (cublasStatus_t (*) (cublasLtMatrixTransformDesc_t , cublasLtMatrixTransformDescAttributes_t , const void* , size_t )) dlsym(RTLD_NEXT, "cublasLtMatrixTransformDescSetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatrixTransformDescSetAttribute] = std::string("cublasLtMatrixTransformDescSetAttribute");
	}
	assert(lcublasLtMatrixTransformDescSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransformDescSetAttribute(transformDesc, attr, buf, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransformDescSetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatrixTransformDescGetAttribute(cublasLtMatrixTransformDesc_t  transformDesc, cublasLtMatrixTransformDescAttributes_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatrixTransformDescGetAttribute) (cublasLtMatrixTransformDesc_t , cublasLtMatrixTransformDescAttributes_t , void* , size_t , size_t* );
	if (!lcublasLtMatrixTransformDescGetAttribute) {
		lcublasLtMatrixTransformDescGetAttribute = (cublasStatus_t (*) (cublasLtMatrixTransformDesc_t , cublasLtMatrixTransformDescAttributes_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatrixTransformDescGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatrixTransformDescGetAttribute] = std::string("cublasLtMatrixTransformDescGetAttribute");
	}
	assert(lcublasLtMatrixTransformDescGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatrixTransformDescGetAttribute(transformDesc, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatrixTransformDescGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulPreferenceInit_internal(cublasLtMatmulPreference_t  pref, size_t  size)
{
	static cublasStatus_t (*lcublasLtMatmulPreferenceInit_internal) (cublasLtMatmulPreference_t , size_t );
	if (!lcublasLtMatmulPreferenceInit_internal) {
		lcublasLtMatmulPreferenceInit_internal = (cublasStatus_t (*) (cublasLtMatmulPreference_t , size_t )) dlsym(RTLD_NEXT, "cublasLtMatmulPreferenceInit_internal");
		tracer._kernel_map[(void *) lcublasLtMatmulPreferenceInit_internal] = std::string("cublasLtMatmulPreferenceInit_internal");
	}
	assert(lcublasLtMatmulPreferenceInit_internal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulPreferenceInit_internal(pref, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulPreferenceInit_internal);
	}
	return res;
}

cublasStatus_t cublasLtMatmulPreferenceCreate(cublasLtMatmulPreference_t*  pref)
{
	static cublasStatus_t (*lcublasLtMatmulPreferenceCreate) (cublasLtMatmulPreference_t* );
	if (!lcublasLtMatmulPreferenceCreate) {
		lcublasLtMatmulPreferenceCreate = (cublasStatus_t (*) (cublasLtMatmulPreference_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulPreferenceCreate");
		tracer._kernel_map[(void *) lcublasLtMatmulPreferenceCreate] = std::string("cublasLtMatmulPreferenceCreate");
	}
	assert(lcublasLtMatmulPreferenceCreate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulPreferenceCreate(pref);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulPreferenceCreate);
	}
	return res;
}

cublasStatus_t cublasLtMatmulPreferenceDestroy(cublasLtMatmulPreference_t  pref)
{
	static cublasStatus_t (*lcublasLtMatmulPreferenceDestroy) (cublasLtMatmulPreference_t );
	if (!lcublasLtMatmulPreferenceDestroy) {
		lcublasLtMatmulPreferenceDestroy = (cublasStatus_t (*) (cublasLtMatmulPreference_t )) dlsym(RTLD_NEXT, "cublasLtMatmulPreferenceDestroy");
		tracer._kernel_map[(void *) lcublasLtMatmulPreferenceDestroy] = std::string("cublasLtMatmulPreferenceDestroy");
	}
	assert(lcublasLtMatmulPreferenceDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulPreferenceDestroy(pref);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulPreferenceDestroy);
	}
	return res;
}

cublasStatus_t cublasLtMatmulPreferenceSetAttribute(cublasLtMatmulPreference_t  pref, cublasLtMatmulPreferenceAttributes_t  attr, const void*  buf, size_t  sizeInBytes)
{
	static cublasStatus_t (*lcublasLtMatmulPreferenceSetAttribute) (cublasLtMatmulPreference_t , cublasLtMatmulPreferenceAttributes_t , const void* , size_t );
	if (!lcublasLtMatmulPreferenceSetAttribute) {
		lcublasLtMatmulPreferenceSetAttribute = (cublasStatus_t (*) (cublasLtMatmulPreference_t , cublasLtMatmulPreferenceAttributes_t , const void* , size_t )) dlsym(RTLD_NEXT, "cublasLtMatmulPreferenceSetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulPreferenceSetAttribute] = std::string("cublasLtMatmulPreferenceSetAttribute");
	}
	assert(lcublasLtMatmulPreferenceSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulPreferenceSetAttribute(pref, attr, buf, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulPreferenceSetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulPreferenceGetAttribute(cublasLtMatmulPreference_t  pref, cublasLtMatmulPreferenceAttributes_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatmulPreferenceGetAttribute) (cublasLtMatmulPreference_t , cublasLtMatmulPreferenceAttributes_t , void* , size_t , size_t* );
	if (!lcublasLtMatmulPreferenceGetAttribute) {
		lcublasLtMatmulPreferenceGetAttribute = (cublasStatus_t (*) (cublasLtMatmulPreference_t , cublasLtMatmulPreferenceAttributes_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulPreferenceGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulPreferenceGetAttribute] = std::string("cublasLtMatmulPreferenceGetAttribute");
	}
	assert(lcublasLtMatmulPreferenceGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulPreferenceGetAttribute(pref, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulPreferenceGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoGetHeuristic(cublasLtHandle_t  lightHandle, cublasLtMatmulDesc_t  operationDesc, cublasLtMatrixLayout_t  Adesc, cublasLtMatrixLayout_t  Bdesc, cublasLtMatrixLayout_t  Cdesc, cublasLtMatrixLayout_t  Ddesc, cublasLtMatmulPreference_t  preference, int  requestedAlgoCount, cublasLtMatmulHeuristicResult_t  heuristicResultsArray[], int*  returnAlgoCount)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoGetHeuristic) (cublasLtHandle_t , cublasLtMatmulDesc_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatmulPreference_t , int , cublasLtMatmulHeuristicResult_t [], int* );
	if (!lcublasLtMatmulAlgoGetHeuristic) {
		lcublasLtMatmulAlgoGetHeuristic = (cublasStatus_t (*) (cublasLtHandle_t , cublasLtMatmulDesc_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatmulPreference_t , int , cublasLtMatmulHeuristicResult_t [], int* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoGetHeuristic");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoGetHeuristic] = std::string("cublasLtMatmulAlgoGetHeuristic");
	}
	assert(lcublasLtMatmulAlgoGetHeuristic);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoGetHeuristic(lightHandle, operationDesc, Adesc, Bdesc, Cdesc, Ddesc, preference, requestedAlgoCount, heuristicResultsArray, returnAlgoCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoGetHeuristic);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoGetIds(cublasLtHandle_t  lightHandle, cublasComputeType_t  computeType, cudaDataType_t  scaleType, cudaDataType_t  Atype, cudaDataType_t  Btype, cudaDataType_t  Ctype, cudaDataType_t  Dtype, int  requestedAlgoCount, int  algoIdsArray[], int*  returnAlgoCount)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoGetIds) (cublasLtHandle_t , cublasComputeType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , int , int [], int* );
	if (!lcublasLtMatmulAlgoGetIds) {
		lcublasLtMatmulAlgoGetIds = (cublasStatus_t (*) (cublasLtHandle_t , cublasComputeType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , int , int [], int* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoGetIds");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoGetIds] = std::string("cublasLtMatmulAlgoGetIds");
	}
	assert(lcublasLtMatmulAlgoGetIds);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoGetIds(lightHandle, computeType, scaleType, Atype, Btype, Ctype, Dtype, requestedAlgoCount, algoIdsArray, returnAlgoCount);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoGetIds);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoInit(cublasLtHandle_t  lightHandle, cublasComputeType_t  computeType, cudaDataType_t  scaleType, cudaDataType_t  Atype, cudaDataType_t  Btype, cudaDataType_t  Ctype, cudaDataType_t  Dtype, int  algoId, cublasLtMatmulAlgo_t*  algo)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoInit) (cublasLtHandle_t , cublasComputeType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , int , cublasLtMatmulAlgo_t* );
	if (!lcublasLtMatmulAlgoInit) {
		lcublasLtMatmulAlgoInit = (cublasStatus_t (*) (cublasLtHandle_t , cublasComputeType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , cudaDataType_t , int , cublasLtMatmulAlgo_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoInit");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoInit] = std::string("cublasLtMatmulAlgoInit");
	}
	assert(lcublasLtMatmulAlgoInit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoInit(lightHandle, computeType, scaleType, Atype, Btype, Ctype, Dtype, algoId, algo);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoInit);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoCheck(cublasLtHandle_t  lightHandle, cublasLtMatmulDesc_t  operationDesc, cublasLtMatrixLayout_t  Adesc, cublasLtMatrixLayout_t  Bdesc, cublasLtMatrixLayout_t  Cdesc, cublasLtMatrixLayout_t  Ddesc, const cublasLtMatmulAlgo_t*  algo, cublasLtMatmulHeuristicResult_t*  result)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoCheck) (cublasLtHandle_t , cublasLtMatmulDesc_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , const cublasLtMatmulAlgo_t* , cublasLtMatmulHeuristicResult_t* );
	if (!lcublasLtMatmulAlgoCheck) {
		lcublasLtMatmulAlgoCheck = (cublasStatus_t (*) (cublasLtHandle_t , cublasLtMatmulDesc_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , cublasLtMatrixLayout_t , const cublasLtMatmulAlgo_t* , cublasLtMatmulHeuristicResult_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoCheck");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoCheck] = std::string("cublasLtMatmulAlgoCheck");
	}
	assert(lcublasLtMatmulAlgoCheck);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoCheck(lightHandle, operationDesc, Adesc, Bdesc, Cdesc, Ddesc, algo, result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoCheck);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoCapGetAttribute(const cublasLtMatmulAlgo_t*  algo, cublasLtMatmulAlgoCapAttributes_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoCapGetAttribute) (const cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoCapAttributes_t , void* , size_t , size_t* );
	if (!lcublasLtMatmulAlgoCapGetAttribute) {
		lcublasLtMatmulAlgoCapGetAttribute = (cublasStatus_t (*) (const cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoCapAttributes_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoCapGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoCapGetAttribute] = std::string("cublasLtMatmulAlgoCapGetAttribute");
	}
	assert(lcublasLtMatmulAlgoCapGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoCapGetAttribute(algo, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoCapGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoConfigSetAttribute(cublasLtMatmulAlgo_t*  algo, cublasLtMatmulAlgoConfigAttributes_t  attr, const void*  buf, size_t  sizeInBytes)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoConfigSetAttribute) (cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoConfigAttributes_t , const void* , size_t );
	if (!lcublasLtMatmulAlgoConfigSetAttribute) {
		lcublasLtMatmulAlgoConfigSetAttribute = (cublasStatus_t (*) (cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoConfigAttributes_t , const void* , size_t )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoConfigSetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoConfigSetAttribute] = std::string("cublasLtMatmulAlgoConfigSetAttribute");
	}
	assert(lcublasLtMatmulAlgoConfigSetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoConfigSetAttribute(algo, attr, buf, sizeInBytes);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoConfigSetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtMatmulAlgoConfigGetAttribute(const cublasLtMatmulAlgo_t*  algo, cublasLtMatmulAlgoConfigAttributes_t  attr, void*  buf, size_t  sizeInBytes, size_t*  sizeWritten)
{
	static cublasStatus_t (*lcublasLtMatmulAlgoConfigGetAttribute) (const cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoConfigAttributes_t , void* , size_t , size_t* );
	if (!lcublasLtMatmulAlgoConfigGetAttribute) {
		lcublasLtMatmulAlgoConfigGetAttribute = (cublasStatus_t (*) (const cublasLtMatmulAlgo_t* , cublasLtMatmulAlgoConfigAttributes_t , void* , size_t , size_t* )) dlsym(RTLD_NEXT, "cublasLtMatmulAlgoConfigGetAttribute");
		tracer._kernel_map[(void *) lcublasLtMatmulAlgoConfigGetAttribute] = std::string("cublasLtMatmulAlgoConfigGetAttribute");
	}
	assert(lcublasLtMatmulAlgoConfigGetAttribute);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtMatmulAlgoConfigGetAttribute(algo, attr, buf, sizeInBytes, sizeWritten);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtMatmulAlgoConfigGetAttribute);
	}
	return res;
}

cublasStatus_t cublasLtLoggerSetCallback(cublasLtLoggerCallback_t  callback)
{
	static cublasStatus_t (*lcublasLtLoggerSetCallback) (cublasLtLoggerCallback_t );
	if (!lcublasLtLoggerSetCallback) {
		lcublasLtLoggerSetCallback = (cublasStatus_t (*) (cublasLtLoggerCallback_t )) dlsym(RTLD_NEXT, "cublasLtLoggerSetCallback");
		tracer._kernel_map[(void *) lcublasLtLoggerSetCallback] = std::string("cublasLtLoggerSetCallback");
	}
	assert(lcublasLtLoggerSetCallback);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerSetCallback(callback);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerSetCallback);
	}
	return res;
}

cublasStatus_t cublasLtLoggerSetFile(FILE*  file)
{
	static cublasStatus_t (*lcublasLtLoggerSetFile) (FILE* );
	if (!lcublasLtLoggerSetFile) {
		lcublasLtLoggerSetFile = (cublasStatus_t (*) (FILE* )) dlsym(RTLD_NEXT, "cublasLtLoggerSetFile");
		tracer._kernel_map[(void *) lcublasLtLoggerSetFile] = std::string("cublasLtLoggerSetFile");
	}
	assert(lcublasLtLoggerSetFile);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerSetFile(file);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerSetFile);
	}
	return res;
}

cublasStatus_t cublasLtLoggerOpenFile(const char*  logFile)
{
	static cublasStatus_t (*lcublasLtLoggerOpenFile) (const char* );
	if (!lcublasLtLoggerOpenFile) {
		lcublasLtLoggerOpenFile = (cublasStatus_t (*) (const char* )) dlsym(RTLD_NEXT, "cublasLtLoggerOpenFile");
		tracer._kernel_map[(void *) lcublasLtLoggerOpenFile] = std::string("cublasLtLoggerOpenFile");
	}
	assert(lcublasLtLoggerOpenFile);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerOpenFile(logFile);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerOpenFile);
	}
	return res;
}

cublasStatus_t cublasLtLoggerSetLevel(int  level)
{
	static cublasStatus_t (*lcublasLtLoggerSetLevel) (int );
	if (!lcublasLtLoggerSetLevel) {
		lcublasLtLoggerSetLevel = (cublasStatus_t (*) (int )) dlsym(RTLD_NEXT, "cublasLtLoggerSetLevel");
		tracer._kernel_map[(void *) lcublasLtLoggerSetLevel] = std::string("cublasLtLoggerSetLevel");
	}
	assert(lcublasLtLoggerSetLevel);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerSetLevel(level);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerSetLevel);
	}
	return res;
}

cublasStatus_t cublasLtLoggerSetMask(int  mask)
{
	static cublasStatus_t (*lcublasLtLoggerSetMask) (int );
	if (!lcublasLtLoggerSetMask) {
		lcublasLtLoggerSetMask = (cublasStatus_t (*) (int )) dlsym(RTLD_NEXT, "cublasLtLoggerSetMask");
		tracer._kernel_map[(void *) lcublasLtLoggerSetMask] = std::string("cublasLtLoggerSetMask");
	}
	assert(lcublasLtLoggerSetMask);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerSetMask(mask);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerSetMask);
	}
	return res;
}

cublasStatus_t cublasLtLoggerForceDisable()
{
	static cublasStatus_t (*lcublasLtLoggerForceDisable) ();
	if (!lcublasLtLoggerForceDisable) {
		lcublasLtLoggerForceDisable = (cublasStatus_t (*) ()) dlsym(RTLD_NEXT, "cublasLtLoggerForceDisable");
		tracer._kernel_map[(void *) lcublasLtLoggerForceDisable] = std::string("cublasLtLoggerForceDisable");
	}
	assert(lcublasLtLoggerForceDisable);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	cublasStatus_t res = 
		lcublasLtLoggerForceDisable();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcublasLtLoggerForceDisable);
	}
	return res;
}

curandStatus_t curandCreateGenerator(curandGenerator_t * generator, curandRngType_t  rng_type)
{
	static curandStatus_t (*lcurandCreateGenerator) (curandGenerator_t *, curandRngType_t );
	if (!lcurandCreateGenerator) {
		lcurandCreateGenerator = (curandStatus_t (*) (curandGenerator_t *, curandRngType_t )) dlsym(RTLD_NEXT, "curandCreateGenerator");
		tracer._kernel_map[(void *) lcurandCreateGenerator] = std::string("curandCreateGenerator");
	}
	assert(lcurandCreateGenerator);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandCreateGenerator(generator, rng_type);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandCreateGenerator);
	}
	return res;
}

curandStatus_t curandCreateGeneratorHost(curandGenerator_t * generator, curandRngType_t  rng_type)
{
	static curandStatus_t (*lcurandCreateGeneratorHost) (curandGenerator_t *, curandRngType_t );
	if (!lcurandCreateGeneratorHost) {
		lcurandCreateGeneratorHost = (curandStatus_t (*) (curandGenerator_t *, curandRngType_t )) dlsym(RTLD_NEXT, "curandCreateGeneratorHost");
		tracer._kernel_map[(void *) lcurandCreateGeneratorHost] = std::string("curandCreateGeneratorHost");
	}
	assert(lcurandCreateGeneratorHost);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandCreateGeneratorHost(generator, rng_type);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandCreateGeneratorHost);
	}
	return res;
}

curandStatus_t curandDestroyGenerator(curandGenerator_t  generator)
{
	static curandStatus_t (*lcurandDestroyGenerator) (curandGenerator_t );
	if (!lcurandDestroyGenerator) {
		lcurandDestroyGenerator = (curandStatus_t (*) (curandGenerator_t )) dlsym(RTLD_NEXT, "curandDestroyGenerator");
		tracer._kernel_map[(void *) lcurandDestroyGenerator] = std::string("curandDestroyGenerator");
	}
	assert(lcurandDestroyGenerator);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandDestroyGenerator(generator);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandDestroyGenerator);
	}
	return res;
}

curandStatus_t curandGetVersion(int * version)
{
	static curandStatus_t (*lcurandGetVersion) (int *);
	if (!lcurandGetVersion) {
		lcurandGetVersion = (curandStatus_t (*) (int *)) dlsym(RTLD_NEXT, "curandGetVersion");
		tracer._kernel_map[(void *) lcurandGetVersion] = std::string("curandGetVersion");
	}
	assert(lcurandGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetVersion(version);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetVersion);
	}
	return res;
}

curandStatus_t curandGetProperty(libraryPropertyType  type, int * value)
{
	static curandStatus_t (*lcurandGetProperty) (libraryPropertyType , int *);
	if (!lcurandGetProperty) {
		lcurandGetProperty = (curandStatus_t (*) (libraryPropertyType , int *)) dlsym(RTLD_NEXT, "curandGetProperty");
		tracer._kernel_map[(void *) lcurandGetProperty] = std::string("curandGetProperty");
	}
	assert(lcurandGetProperty);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetProperty(type, value);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetProperty);
	}
	return res;
}

curandStatus_t curandSetStream(curandGenerator_t  generator, cudaStream_t  stream)
{
	static curandStatus_t (*lcurandSetStream) (curandGenerator_t , cudaStream_t );
	if (!lcurandSetStream) {
		lcurandSetStream = (curandStatus_t (*) (curandGenerator_t , cudaStream_t )) dlsym(RTLD_NEXT, "curandSetStream");
		tracer._kernel_map[(void *) lcurandSetStream] = std::string("curandSetStream");
	}
	assert(lcurandSetStream);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandSetStream(generator, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandSetStream);
	}
	return res;
}

curandStatus_t curandSetPseudoRandomGeneratorSeed(curandGenerator_t  generator, unsigned long long  seed)
{
	static curandStatus_t (*lcurandSetPseudoRandomGeneratorSeed) (curandGenerator_t , unsigned long long );
	if (!lcurandSetPseudoRandomGeneratorSeed) {
		lcurandSetPseudoRandomGeneratorSeed = (curandStatus_t (*) (curandGenerator_t , unsigned long long )) dlsym(RTLD_NEXT, "curandSetPseudoRandomGeneratorSeed");
		tracer._kernel_map[(void *) lcurandSetPseudoRandomGeneratorSeed] = std::string("curandSetPseudoRandomGeneratorSeed");
	}
	assert(lcurandSetPseudoRandomGeneratorSeed);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandSetPseudoRandomGeneratorSeed(generator, seed);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandSetPseudoRandomGeneratorSeed);
	}
	return res;
}

curandStatus_t curandSetGeneratorOffset(curandGenerator_t  generator, unsigned long long  offset)
{
	static curandStatus_t (*lcurandSetGeneratorOffset) (curandGenerator_t , unsigned long long );
	if (!lcurandSetGeneratorOffset) {
		lcurandSetGeneratorOffset = (curandStatus_t (*) (curandGenerator_t , unsigned long long )) dlsym(RTLD_NEXT, "curandSetGeneratorOffset");
		tracer._kernel_map[(void *) lcurandSetGeneratorOffset] = std::string("curandSetGeneratorOffset");
	}
	assert(lcurandSetGeneratorOffset);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandSetGeneratorOffset(generator, offset);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandSetGeneratorOffset);
	}
	return res;
}

curandStatus_t curandSetGeneratorOrdering(curandGenerator_t  generator, curandOrdering_t  order)
{
	static curandStatus_t (*lcurandSetGeneratorOrdering) (curandGenerator_t , curandOrdering_t );
	if (!lcurandSetGeneratorOrdering) {
		lcurandSetGeneratorOrdering = (curandStatus_t (*) (curandGenerator_t , curandOrdering_t )) dlsym(RTLD_NEXT, "curandSetGeneratorOrdering");
		tracer._kernel_map[(void *) lcurandSetGeneratorOrdering] = std::string("curandSetGeneratorOrdering");
	}
	assert(lcurandSetGeneratorOrdering);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandSetGeneratorOrdering(generator, order);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandSetGeneratorOrdering);
	}
	return res;
}

curandStatus_t curandSetQuasiRandomGeneratorDimensions(curandGenerator_t  generator, unsigned int  num_dimensions)
{
	static curandStatus_t (*lcurandSetQuasiRandomGeneratorDimensions) (curandGenerator_t , unsigned int );
	if (!lcurandSetQuasiRandomGeneratorDimensions) {
		lcurandSetQuasiRandomGeneratorDimensions = (curandStatus_t (*) (curandGenerator_t , unsigned int )) dlsym(RTLD_NEXT, "curandSetQuasiRandomGeneratorDimensions");
		tracer._kernel_map[(void *) lcurandSetQuasiRandomGeneratorDimensions] = std::string("curandSetQuasiRandomGeneratorDimensions");
	}
	assert(lcurandSetQuasiRandomGeneratorDimensions);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandSetQuasiRandomGeneratorDimensions(generator, num_dimensions);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandSetQuasiRandomGeneratorDimensions);
	}
	return res;
}

curandStatus_t curandGenerate(curandGenerator_t  generator, unsigned int * outputPtr, size_t  num)
{
	static curandStatus_t (*lcurandGenerate) (curandGenerator_t , unsigned int *, size_t );
	if (!lcurandGenerate) {
		lcurandGenerate = (curandStatus_t (*) (curandGenerator_t , unsigned int *, size_t )) dlsym(RTLD_NEXT, "curandGenerate");
		tracer._kernel_map[(void *) lcurandGenerate] = std::string("curandGenerate");
	}
	assert(lcurandGenerate);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerate(generator, outputPtr, num);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerate);
	}
	return res;
}

curandStatus_t curandGenerateLongLong(curandGenerator_t  generator, unsigned long long * outputPtr, size_t  num)
{
	static curandStatus_t (*lcurandGenerateLongLong) (curandGenerator_t , unsigned long long *, size_t );
	if (!lcurandGenerateLongLong) {
		lcurandGenerateLongLong = (curandStatus_t (*) (curandGenerator_t , unsigned long long *, size_t )) dlsym(RTLD_NEXT, "curandGenerateLongLong");
		tracer._kernel_map[(void *) lcurandGenerateLongLong] = std::string("curandGenerateLongLong");
	}
	assert(lcurandGenerateLongLong);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateLongLong(generator, outputPtr, num);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateLongLong);
	}
	return res;
}

curandStatus_t curandGenerateUniform(curandGenerator_t  generator, float * outputPtr, size_t  num)
{
	static curandStatus_t (*lcurandGenerateUniform) (curandGenerator_t , float *, size_t );
	if (!lcurandGenerateUniform) {
		lcurandGenerateUniform = (curandStatus_t (*) (curandGenerator_t , float *, size_t )) dlsym(RTLD_NEXT, "curandGenerateUniform");
		tracer._kernel_map[(void *) lcurandGenerateUniform] = std::string("curandGenerateUniform");
	}
	assert(lcurandGenerateUniform);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateUniform(generator, outputPtr, num);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateUniform);
	}
	return res;
}

curandStatus_t curandGenerateUniformDouble(curandGenerator_t  generator, double * outputPtr, size_t  num)
{
	static curandStatus_t (*lcurandGenerateUniformDouble) (curandGenerator_t , double *, size_t );
	if (!lcurandGenerateUniformDouble) {
		lcurandGenerateUniformDouble = (curandStatus_t (*) (curandGenerator_t , double *, size_t )) dlsym(RTLD_NEXT, "curandGenerateUniformDouble");
		tracer._kernel_map[(void *) lcurandGenerateUniformDouble] = std::string("curandGenerateUniformDouble");
	}
	assert(lcurandGenerateUniformDouble);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateUniformDouble(generator, outputPtr, num);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateUniformDouble);
	}
	return res;
}

curandStatus_t curandGenerateNormal(curandGenerator_t  generator, float * outputPtr, size_t  n, float  mean, float  stddev)
{
	static curandStatus_t (*lcurandGenerateNormal) (curandGenerator_t , float *, size_t , float , float );
	if (!lcurandGenerateNormal) {
		lcurandGenerateNormal = (curandStatus_t (*) (curandGenerator_t , float *, size_t , float , float )) dlsym(RTLD_NEXT, "curandGenerateNormal");
		tracer._kernel_map[(void *) lcurandGenerateNormal] = std::string("curandGenerateNormal");
	}
	assert(lcurandGenerateNormal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateNormal(generator, outputPtr, n, mean, stddev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateNormal);
	}
	return res;
}

curandStatus_t curandGenerateNormalDouble(curandGenerator_t  generator, double * outputPtr, size_t  n, double  mean, double  stddev)
{
	static curandStatus_t (*lcurandGenerateNormalDouble) (curandGenerator_t , double *, size_t , double , double );
	if (!lcurandGenerateNormalDouble) {
		lcurandGenerateNormalDouble = (curandStatus_t (*) (curandGenerator_t , double *, size_t , double , double )) dlsym(RTLD_NEXT, "curandGenerateNormalDouble");
		tracer._kernel_map[(void *) lcurandGenerateNormalDouble] = std::string("curandGenerateNormalDouble");
	}
	assert(lcurandGenerateNormalDouble);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateNormalDouble(generator, outputPtr, n, mean, stddev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateNormalDouble);
	}
	return res;
}

curandStatus_t curandGenerateLogNormal(curandGenerator_t  generator, float * outputPtr, size_t  n, float  mean, float  stddev)
{
	static curandStatus_t (*lcurandGenerateLogNormal) (curandGenerator_t , float *, size_t , float , float );
	if (!lcurandGenerateLogNormal) {
		lcurandGenerateLogNormal = (curandStatus_t (*) (curandGenerator_t , float *, size_t , float , float )) dlsym(RTLD_NEXT, "curandGenerateLogNormal");
		tracer._kernel_map[(void *) lcurandGenerateLogNormal] = std::string("curandGenerateLogNormal");
	}
	assert(lcurandGenerateLogNormal);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateLogNormal(generator, outputPtr, n, mean, stddev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateLogNormal);
	}
	return res;
}

curandStatus_t curandGenerateLogNormalDouble(curandGenerator_t  generator, double * outputPtr, size_t  n, double  mean, double  stddev)
{
	static curandStatus_t (*lcurandGenerateLogNormalDouble) (curandGenerator_t , double *, size_t , double , double );
	if (!lcurandGenerateLogNormalDouble) {
		lcurandGenerateLogNormalDouble = (curandStatus_t (*) (curandGenerator_t , double *, size_t , double , double )) dlsym(RTLD_NEXT, "curandGenerateLogNormalDouble");
		tracer._kernel_map[(void *) lcurandGenerateLogNormalDouble] = std::string("curandGenerateLogNormalDouble");
	}
	assert(lcurandGenerateLogNormalDouble);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateLogNormalDouble(generator, outputPtr, n, mean, stddev);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateLogNormalDouble);
	}
	return res;
}

curandStatus_t curandCreatePoissonDistribution(double  lambda, curandDiscreteDistribution_t * discrete_distribution)
{
	static curandStatus_t (*lcurandCreatePoissonDistribution) (double , curandDiscreteDistribution_t *);
	if (!lcurandCreatePoissonDistribution) {
		lcurandCreatePoissonDistribution = (curandStatus_t (*) (double , curandDiscreteDistribution_t *)) dlsym(RTLD_NEXT, "curandCreatePoissonDistribution");
		tracer._kernel_map[(void *) lcurandCreatePoissonDistribution] = std::string("curandCreatePoissonDistribution");
	}
	assert(lcurandCreatePoissonDistribution);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandCreatePoissonDistribution(lambda, discrete_distribution);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandCreatePoissonDistribution);
	}
	return res;
}

curandStatus_t curandDestroyDistribution(curandDiscreteDistribution_t  discrete_distribution)
{
	static curandStatus_t (*lcurandDestroyDistribution) (curandDiscreteDistribution_t );
	if (!lcurandDestroyDistribution) {
		lcurandDestroyDistribution = (curandStatus_t (*) (curandDiscreteDistribution_t )) dlsym(RTLD_NEXT, "curandDestroyDistribution");
		tracer._kernel_map[(void *) lcurandDestroyDistribution] = std::string("curandDestroyDistribution");
	}
	assert(lcurandDestroyDistribution);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandDestroyDistribution(discrete_distribution);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandDestroyDistribution);
	}
	return res;
}

curandStatus_t curandGeneratePoisson(curandGenerator_t  generator, unsigned int * outputPtr, size_t  n, double  lambda)
{
	static curandStatus_t (*lcurandGeneratePoisson) (curandGenerator_t , unsigned int *, size_t , double );
	if (!lcurandGeneratePoisson) {
		lcurandGeneratePoisson = (curandStatus_t (*) (curandGenerator_t , unsigned int *, size_t , double )) dlsym(RTLD_NEXT, "curandGeneratePoisson");
		tracer._kernel_map[(void *) lcurandGeneratePoisson] = std::string("curandGeneratePoisson");
	}
	assert(lcurandGeneratePoisson);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGeneratePoisson(generator, outputPtr, n, lambda);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGeneratePoisson);
	}
	return res;
}

curandStatus_t curandGeneratePoissonMethod(curandGenerator_t  generator, unsigned int * outputPtr, size_t  n, double  lambda, curandMethod_t  method)
{
	static curandStatus_t (*lcurandGeneratePoissonMethod) (curandGenerator_t , unsigned int *, size_t , double , curandMethod_t );
	if (!lcurandGeneratePoissonMethod) {
		lcurandGeneratePoissonMethod = (curandStatus_t (*) (curandGenerator_t , unsigned int *, size_t , double , curandMethod_t )) dlsym(RTLD_NEXT, "curandGeneratePoissonMethod");
		tracer._kernel_map[(void *) lcurandGeneratePoissonMethod] = std::string("curandGeneratePoissonMethod");
	}
	assert(lcurandGeneratePoissonMethod);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGeneratePoissonMethod(generator, outputPtr, n, lambda, method);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGeneratePoissonMethod);
	}
	return res;
}

curandStatus_t curandGenerateBinomial(curandGenerator_t  generator, unsigned int * outputPtr, size_t  num, unsigned int  n, double  p)
{
	static curandStatus_t (*lcurandGenerateBinomial) (curandGenerator_t , unsigned int *, size_t , unsigned int , double );
	if (!lcurandGenerateBinomial) {
		lcurandGenerateBinomial = (curandStatus_t (*) (curandGenerator_t , unsigned int *, size_t , unsigned int , double )) dlsym(RTLD_NEXT, "curandGenerateBinomial");
		tracer._kernel_map[(void *) lcurandGenerateBinomial] = std::string("curandGenerateBinomial");
	}
	assert(lcurandGenerateBinomial);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateBinomial(generator, outputPtr, num, n, p);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateBinomial);
	}
	return res;
}

curandStatus_t curandGenerateBinomialMethod(curandGenerator_t  generator, unsigned int * outputPtr, size_t  num, unsigned int  n, double  p, curandMethod_t  method)
{
	static curandStatus_t (*lcurandGenerateBinomialMethod) (curandGenerator_t , unsigned int *, size_t , unsigned int , double , curandMethod_t );
	if (!lcurandGenerateBinomialMethod) {
		lcurandGenerateBinomialMethod = (curandStatus_t (*) (curandGenerator_t , unsigned int *, size_t , unsigned int , double , curandMethod_t )) dlsym(RTLD_NEXT, "curandGenerateBinomialMethod");
		tracer._kernel_map[(void *) lcurandGenerateBinomialMethod] = std::string("curandGenerateBinomialMethod");
	}
	assert(lcurandGenerateBinomialMethod);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateBinomialMethod(generator, outputPtr, num, n, p, method);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateBinomialMethod);
	}
	return res;
}

curandStatus_t curandGenerateSeeds(curandGenerator_t  generator)
{
	static curandStatus_t (*lcurandGenerateSeeds) (curandGenerator_t );
	if (!lcurandGenerateSeeds) {
		lcurandGenerateSeeds = (curandStatus_t (*) (curandGenerator_t )) dlsym(RTLD_NEXT, "curandGenerateSeeds");
		tracer._kernel_map[(void *) lcurandGenerateSeeds] = std::string("curandGenerateSeeds");
	}
	assert(lcurandGenerateSeeds);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGenerateSeeds(generator);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGenerateSeeds);
	}
	return res;
}

curandStatus_t curandGetDirectionVectors32(curandDirectionVectors32_t * vectors[], curandDirectionVectorSet_t  set)
{
	static curandStatus_t (*lcurandGetDirectionVectors32) (curandDirectionVectors32_t *[], curandDirectionVectorSet_t );
	if (!lcurandGetDirectionVectors32) {
		lcurandGetDirectionVectors32 = (curandStatus_t (*) (curandDirectionVectors32_t *[], curandDirectionVectorSet_t )) dlsym(RTLD_NEXT, "curandGetDirectionVectors32");
		tracer._kernel_map[(void *) lcurandGetDirectionVectors32] = std::string("curandGetDirectionVectors32");
	}
	assert(lcurandGetDirectionVectors32);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetDirectionVectors32(vectors, set);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetDirectionVectors32);
	}
	return res;
}

curandStatus_t curandGetScrambleConstants32(unsigned int * *  constants)
{
	static curandStatus_t (*lcurandGetScrambleConstants32) (unsigned int * * );
	if (!lcurandGetScrambleConstants32) {
		lcurandGetScrambleConstants32 = (curandStatus_t (*) (unsigned int * * )) dlsym(RTLD_NEXT, "curandGetScrambleConstants32");
		tracer._kernel_map[(void *) lcurandGetScrambleConstants32] = std::string("curandGetScrambleConstants32");
	}
	assert(lcurandGetScrambleConstants32);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetScrambleConstants32(constants);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetScrambleConstants32);
	}
	return res;
}

curandStatus_t curandGetDirectionVectors64(curandDirectionVectors64_t * vectors[], curandDirectionVectorSet_t  set)
{
	static curandStatus_t (*lcurandGetDirectionVectors64) (curandDirectionVectors64_t *[], curandDirectionVectorSet_t );
	if (!lcurandGetDirectionVectors64) {
		lcurandGetDirectionVectors64 = (curandStatus_t (*) (curandDirectionVectors64_t *[], curandDirectionVectorSet_t )) dlsym(RTLD_NEXT, "curandGetDirectionVectors64");
		tracer._kernel_map[(void *) lcurandGetDirectionVectors64] = std::string("curandGetDirectionVectors64");
	}
	assert(lcurandGetDirectionVectors64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetDirectionVectors64(vectors, set);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetDirectionVectors64);
	}
	return res;
}

curandStatus_t curandGetScrambleConstants64(unsigned long long * *  constants)
{
	static curandStatus_t (*lcurandGetScrambleConstants64) (unsigned long long * * );
	if (!lcurandGetScrambleConstants64) {
		lcurandGetScrambleConstants64 = (curandStatus_t (*) (unsigned long long * * )) dlsym(RTLD_NEXT, "curandGetScrambleConstants64");
		tracer._kernel_map[(void *) lcurandGetScrambleConstants64] = std::string("curandGetScrambleConstants64");
	}
	assert(lcurandGetScrambleConstants64);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	curandStatus_t res = 
		lcurandGetScrambleConstants64(constants);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lcurandGetScrambleConstants64);
	}
	return res;
}

ncclResult_t ncclMemAlloc(void**  ptr, size_t  size)
{
	static ncclResult_t (*lncclMemAlloc) (void** , size_t );
	if (!lncclMemAlloc) {
		lncclMemAlloc = (ncclResult_t (*) (void** , size_t )) dlsym(RTLD_NEXT, "ncclMemAlloc");
		tracer._kernel_map[(void *) lncclMemAlloc] = std::string("ncclMemAlloc");
	}
	assert(lncclMemAlloc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclMemAlloc(ptr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclMemAlloc);
	}
	return res;
}

ncclResult_t pncclMemAlloc(void**  ptr, size_t  size)
{
	static ncclResult_t (*lpncclMemAlloc) (void** , size_t );
	if (!lpncclMemAlloc) {
		lpncclMemAlloc = (ncclResult_t (*) (void** , size_t )) dlsym(RTLD_NEXT, "pncclMemAlloc");
		tracer._kernel_map[(void *) lpncclMemAlloc] = std::string("pncclMemAlloc");
	}
	assert(lpncclMemAlloc);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclMemAlloc(ptr, size);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclMemAlloc);
	}
	return res;
}

ncclResult_t ncclMemFree(void * ptr)
{
	static ncclResult_t (*lncclMemFree) (void *);
	if (!lncclMemFree) {
		lncclMemFree = (ncclResult_t (*) (void *)) dlsym(RTLD_NEXT, "ncclMemFree");
		tracer._kernel_map[(void *) lncclMemFree] = std::string("ncclMemFree");
	}
	assert(lncclMemFree);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclMemFree(ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclMemFree);
	}
	return res;
}

ncclResult_t pncclMemFree(void * ptr)
{
	static ncclResult_t (*lpncclMemFree) (void *);
	if (!lpncclMemFree) {
		lpncclMemFree = (ncclResult_t (*) (void *)) dlsym(RTLD_NEXT, "pncclMemFree");
		tracer._kernel_map[(void *) lpncclMemFree] = std::string("pncclMemFree");
	}
	assert(lpncclMemFree);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclMemFree(ptr);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclMemFree);
	}
	return res;
}

ncclResult_t ncclGetVersion(int * version)
{
	static ncclResult_t (*lncclGetVersion) (int *);
	if (!lncclGetVersion) {
		lncclGetVersion = (ncclResult_t (*) (int *)) dlsym(RTLD_NEXT, "ncclGetVersion");
		tracer._kernel_map[(void *) lncclGetVersion] = std::string("ncclGetVersion");
	}
	assert(lncclGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclGetVersion(version);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGetVersion);
	}
	return res;
}

ncclResult_t pncclGetVersion(int * version)
{
	static ncclResult_t (*lpncclGetVersion) (int *);
	if (!lpncclGetVersion) {
		lpncclGetVersion = (ncclResult_t (*) (int *)) dlsym(RTLD_NEXT, "pncclGetVersion");
		tracer._kernel_map[(void *) lpncclGetVersion] = std::string("pncclGetVersion");
	}
	assert(lpncclGetVersion);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclGetVersion(version);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGetVersion);
	}
	return res;
}

ncclResult_t ncclGetUniqueId(ncclUniqueId*  uniqueId)
{
	static ncclResult_t (*lncclGetUniqueId) (ncclUniqueId* );
	if (!lncclGetUniqueId) {
		lncclGetUniqueId = (ncclResult_t (*) (ncclUniqueId* )) dlsym(RTLD_NEXT, "ncclGetUniqueId");
		tracer._kernel_map[(void *) lncclGetUniqueId] = std::string("ncclGetUniqueId");
	}
	assert(lncclGetUniqueId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclGetUniqueId(uniqueId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGetUniqueId);
	}
	return res;
}

ncclResult_t pncclGetUniqueId(ncclUniqueId*  uniqueId)
{
	static ncclResult_t (*lpncclGetUniqueId) (ncclUniqueId* );
	if (!lpncclGetUniqueId) {
		lpncclGetUniqueId = (ncclResult_t (*) (ncclUniqueId* )) dlsym(RTLD_NEXT, "pncclGetUniqueId");
		tracer._kernel_map[(void *) lpncclGetUniqueId] = std::string("pncclGetUniqueId");
	}
	assert(lpncclGetUniqueId);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclGetUniqueId(uniqueId);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGetUniqueId);
	}
	return res;
}

ncclResult_t ncclCommInitRankConfig(ncclComm_t*  comm, int  nranks, ncclUniqueId  commId, int  rank, ncclConfig_t*  config)
{
	static ncclResult_t (*lncclCommInitRankConfig) (ncclComm_t* , int , ncclUniqueId , int , ncclConfig_t* );
	if (!lncclCommInitRankConfig) {
		lncclCommInitRankConfig = (ncclResult_t (*) (ncclComm_t* , int , ncclUniqueId , int , ncclConfig_t* )) dlsym(RTLD_NEXT, "ncclCommInitRankConfig");
		tracer._kernel_map[(void *) lncclCommInitRankConfig] = std::string("ncclCommInitRankConfig");
	}
	assert(lncclCommInitRankConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommInitRankConfig(comm, nranks, commId, rank, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommInitRankConfig);
	}
	return res;
}

ncclResult_t pncclCommInitRankConfig(ncclComm_t*  comm, int  nranks, ncclUniqueId  commId, int  rank, ncclConfig_t*  config)
{
	static ncclResult_t (*lpncclCommInitRankConfig) (ncclComm_t* , int , ncclUniqueId , int , ncclConfig_t* );
	if (!lpncclCommInitRankConfig) {
		lpncclCommInitRankConfig = (ncclResult_t (*) (ncclComm_t* , int , ncclUniqueId , int , ncclConfig_t* )) dlsym(RTLD_NEXT, "pncclCommInitRankConfig");
		tracer._kernel_map[(void *) lpncclCommInitRankConfig] = std::string("pncclCommInitRankConfig");
	}
	assert(lpncclCommInitRankConfig);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommInitRankConfig(comm, nranks, commId, rank, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommInitRankConfig);
	}
	return res;
}

ncclResult_t ncclCommInitRank(ncclComm_t*  comm, int  nranks, ncclUniqueId  commId, int  rank)
{
	static ncclResult_t (*lncclCommInitRank) (ncclComm_t* , int , ncclUniqueId , int );
	if (!lncclCommInitRank) {
		lncclCommInitRank = (ncclResult_t (*) (ncclComm_t* , int , ncclUniqueId , int )) dlsym(RTLD_NEXT, "ncclCommInitRank");
		tracer._kernel_map[(void *) lncclCommInitRank] = std::string("ncclCommInitRank");
	}
	assert(lncclCommInitRank);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommInitRank(comm, nranks, commId, rank);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommInitRank);
	}
	return res;
}

ncclResult_t pncclCommInitRank(ncclComm_t*  comm, int  nranks, ncclUniqueId  commId, int  rank)
{
	static ncclResult_t (*lpncclCommInitRank) (ncclComm_t* , int , ncclUniqueId , int );
	if (!lpncclCommInitRank) {
		lpncclCommInitRank = (ncclResult_t (*) (ncclComm_t* , int , ncclUniqueId , int )) dlsym(RTLD_NEXT, "pncclCommInitRank");
		tracer._kernel_map[(void *) lpncclCommInitRank] = std::string("pncclCommInitRank");
	}
	assert(lpncclCommInitRank);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommInitRank(comm, nranks, commId, rank);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommInitRank);
	}
	return res;
}

ncclResult_t ncclCommInitAll(ncclComm_t*  comm, int  ndev, const int*  devlist)
{
	static ncclResult_t (*lncclCommInitAll) (ncclComm_t* , int , const int* );
	if (!lncclCommInitAll) {
		lncclCommInitAll = (ncclResult_t (*) (ncclComm_t* , int , const int* )) dlsym(RTLD_NEXT, "ncclCommInitAll");
		tracer._kernel_map[(void *) lncclCommInitAll] = std::string("ncclCommInitAll");
	}
	assert(lncclCommInitAll);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommInitAll(comm, ndev, devlist);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommInitAll);
	}
	return res;
}

ncclResult_t pncclCommInitAll(ncclComm_t*  comm, int  ndev, const int*  devlist)
{
	static ncclResult_t (*lpncclCommInitAll) (ncclComm_t* , int , const int* );
	if (!lpncclCommInitAll) {
		lpncclCommInitAll = (ncclResult_t (*) (ncclComm_t* , int , const int* )) dlsym(RTLD_NEXT, "pncclCommInitAll");
		tracer._kernel_map[(void *) lpncclCommInitAll] = std::string("pncclCommInitAll");
	}
	assert(lpncclCommInitAll);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommInitAll(comm, ndev, devlist);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommInitAll);
	}
	return res;
}

ncclResult_t ncclCommFinalize(ncclComm_t  comm)
{
	static ncclResult_t (*lncclCommFinalize) (ncclComm_t );
	if (!lncclCommFinalize) {
		lncclCommFinalize = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "ncclCommFinalize");
		tracer._kernel_map[(void *) lncclCommFinalize] = std::string("ncclCommFinalize");
	}
	assert(lncclCommFinalize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommFinalize(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommFinalize);
	}
	return res;
}

ncclResult_t pncclCommFinalize(ncclComm_t  comm)
{
	static ncclResult_t (*lpncclCommFinalize) (ncclComm_t );
	if (!lpncclCommFinalize) {
		lpncclCommFinalize = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "pncclCommFinalize");
		tracer._kernel_map[(void *) lpncclCommFinalize] = std::string("pncclCommFinalize");
	}
	assert(lpncclCommFinalize);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommFinalize(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommFinalize);
	}
	return res;
}

ncclResult_t ncclCommDestroy(ncclComm_t  comm)
{
	static ncclResult_t (*lncclCommDestroy) (ncclComm_t );
	if (!lncclCommDestroy) {
		lncclCommDestroy = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "ncclCommDestroy");
		tracer._kernel_map[(void *) lncclCommDestroy] = std::string("ncclCommDestroy");
	}
	assert(lncclCommDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommDestroy(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommDestroy);
	}
	return res;
}

ncclResult_t pncclCommDestroy(ncclComm_t  comm)
{
	static ncclResult_t (*lpncclCommDestroy) (ncclComm_t );
	if (!lpncclCommDestroy) {
		lpncclCommDestroy = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "pncclCommDestroy");
		tracer._kernel_map[(void *) lpncclCommDestroy] = std::string("pncclCommDestroy");
	}
	assert(lpncclCommDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommDestroy(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommDestroy);
	}
	return res;
}

ncclResult_t ncclCommAbort(ncclComm_t  comm)
{
	static ncclResult_t (*lncclCommAbort) (ncclComm_t );
	if (!lncclCommAbort) {
		lncclCommAbort = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "ncclCommAbort");
		tracer._kernel_map[(void *) lncclCommAbort] = std::string("ncclCommAbort");
	}
	assert(lncclCommAbort);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommAbort(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommAbort);
	}
	return res;
}

ncclResult_t pncclCommAbort(ncclComm_t  comm)
{
	static ncclResult_t (*lpncclCommAbort) (ncclComm_t );
	if (!lpncclCommAbort) {
		lpncclCommAbort = (ncclResult_t (*) (ncclComm_t )) dlsym(RTLD_NEXT, "pncclCommAbort");
		tracer._kernel_map[(void *) lpncclCommAbort] = std::string("pncclCommAbort");
	}
	assert(lpncclCommAbort);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommAbort(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommAbort);
	}
	return res;
}

ncclResult_t ncclCommSplit(ncclComm_t  comm, int  color, int  key, ncclComm_t * newcomm, ncclConfig_t*  config)
{
	static ncclResult_t (*lncclCommSplit) (ncclComm_t , int , int , ncclComm_t *, ncclConfig_t* );
	if (!lncclCommSplit) {
		lncclCommSplit = (ncclResult_t (*) (ncclComm_t , int , int , ncclComm_t *, ncclConfig_t* )) dlsym(RTLD_NEXT, "ncclCommSplit");
		tracer._kernel_map[(void *) lncclCommSplit] = std::string("ncclCommSplit");
	}
	assert(lncclCommSplit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommSplit(comm, color, key, newcomm, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommSplit);
	}
	return res;
}

ncclResult_t pncclCommSplit(ncclComm_t  comm, int  color, int  key, ncclComm_t * newcomm, ncclConfig_t*  config)
{
	static ncclResult_t (*lpncclCommSplit) (ncclComm_t , int , int , ncclComm_t *, ncclConfig_t* );
	if (!lpncclCommSplit) {
		lpncclCommSplit = (ncclResult_t (*) (ncclComm_t , int , int , ncclComm_t *, ncclConfig_t* )) dlsym(RTLD_NEXT, "pncclCommSplit");
		tracer._kernel_map[(void *) lpncclCommSplit] = std::string("pncclCommSplit");
	}
	assert(lpncclCommSplit);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommSplit(comm, color, key, newcomm, config);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommSplit);
	}
	return res;
}

const char* ncclGetErrorString(ncclResult_t  result)
{
	static const char* (*lncclGetErrorString) (ncclResult_t );
	if (!lncclGetErrorString) {
		lncclGetErrorString = (const char* (*) (ncclResult_t )) dlsym(RTLD_NEXT, "ncclGetErrorString");
		tracer._kernel_map[(void *) lncclGetErrorString] = std::string("ncclGetErrorString");
	}
	assert(lncclGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lncclGetErrorString(result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGetErrorString);
	}
	return res;
}

const char* pncclGetErrorString(ncclResult_t  result)
{
	static const char* (*lpncclGetErrorString) (ncclResult_t );
	if (!lpncclGetErrorString) {
		lpncclGetErrorString = (const char* (*) (ncclResult_t )) dlsym(RTLD_NEXT, "pncclGetErrorString");
		tracer._kernel_map[(void *) lpncclGetErrorString] = std::string("pncclGetErrorString");
	}
	assert(lpncclGetErrorString);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lpncclGetErrorString(result);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGetErrorString);
	}
	return res;
}

const char* ncclGetLastError(ncclComm_t  comm)
{
	static const char* (*lncclGetLastError) (ncclComm_t );
	if (!lncclGetLastError) {
		lncclGetLastError = (const char* (*) (ncclComm_t )) dlsym(RTLD_NEXT, "ncclGetLastError");
		tracer._kernel_map[(void *) lncclGetLastError] = std::string("ncclGetLastError");
	}
	assert(lncclGetLastError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lncclGetLastError(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGetLastError);
	}
	return res;
}

const char* pncclGetLastError(ncclComm_t  comm)
{
	static const char* (*lpncclGetLastError) (ncclComm_t );
	if (!lpncclGetLastError) {
		lpncclGetLastError = (const char* (*) (ncclComm_t )) dlsym(RTLD_NEXT, "pncclGetLastError");
		tracer._kernel_map[(void *) lpncclGetLastError] = std::string("pncclGetLastError");
	}
	assert(lpncclGetLastError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	const char* res = 
		lpncclGetLastError(comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGetLastError);
	}
	return res;
}

ncclResult_t ncclCommGetAsyncError(ncclComm_t  comm, ncclResult_t * asyncError)
{
	static ncclResult_t (*lncclCommGetAsyncError) (ncclComm_t , ncclResult_t *);
	if (!lncclCommGetAsyncError) {
		lncclCommGetAsyncError = (ncclResult_t (*) (ncclComm_t , ncclResult_t *)) dlsym(RTLD_NEXT, "ncclCommGetAsyncError");
		tracer._kernel_map[(void *) lncclCommGetAsyncError] = std::string("ncclCommGetAsyncError");
	}
	assert(lncclCommGetAsyncError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommGetAsyncError(comm, asyncError);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommGetAsyncError);
	}
	return res;
}

ncclResult_t pncclCommGetAsyncError(ncclComm_t  comm, ncclResult_t * asyncError)
{
	static ncclResult_t (*lpncclCommGetAsyncError) (ncclComm_t , ncclResult_t *);
	if (!lpncclCommGetAsyncError) {
		lpncclCommGetAsyncError = (ncclResult_t (*) (ncclComm_t , ncclResult_t *)) dlsym(RTLD_NEXT, "pncclCommGetAsyncError");
		tracer._kernel_map[(void *) lpncclCommGetAsyncError] = std::string("pncclCommGetAsyncError");
	}
	assert(lpncclCommGetAsyncError);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommGetAsyncError(comm, asyncError);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommGetAsyncError);
	}
	return res;
}

ncclResult_t ncclCommCount(const ncclComm_t  comm, int*  count)
{
	static ncclResult_t (*lncclCommCount) (const ncclComm_t , int* );
	if (!lncclCommCount) {
		lncclCommCount = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "ncclCommCount");
		tracer._kernel_map[(void *) lncclCommCount] = std::string("ncclCommCount");
	}
	assert(lncclCommCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommCount(comm, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommCount);
	}
	return res;
}

ncclResult_t pncclCommCount(const ncclComm_t  comm, int*  count)
{
	static ncclResult_t (*lpncclCommCount) (const ncclComm_t , int* );
	if (!lpncclCommCount) {
		lpncclCommCount = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "pncclCommCount");
		tracer._kernel_map[(void *) lpncclCommCount] = std::string("pncclCommCount");
	}
	assert(lpncclCommCount);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommCount(comm, count);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommCount);
	}
	return res;
}

ncclResult_t ncclCommCuDevice(const ncclComm_t  comm, int*  device)
{
	static ncclResult_t (*lncclCommCuDevice) (const ncclComm_t , int* );
	if (!lncclCommCuDevice) {
		lncclCommCuDevice = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "ncclCommCuDevice");
		tracer._kernel_map[(void *) lncclCommCuDevice] = std::string("ncclCommCuDevice");
	}
	assert(lncclCommCuDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommCuDevice(comm, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommCuDevice);
	}
	return res;
}

ncclResult_t pncclCommCuDevice(const ncclComm_t  comm, int*  device)
{
	static ncclResult_t (*lpncclCommCuDevice) (const ncclComm_t , int* );
	if (!lpncclCommCuDevice) {
		lpncclCommCuDevice = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "pncclCommCuDevice");
		tracer._kernel_map[(void *) lpncclCommCuDevice] = std::string("pncclCommCuDevice");
	}
	assert(lpncclCommCuDevice);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommCuDevice(comm, device);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommCuDevice);
	}
	return res;
}

ncclResult_t ncclCommUserRank(const ncclComm_t  comm, int*  rank)
{
	static ncclResult_t (*lncclCommUserRank) (const ncclComm_t , int* );
	if (!lncclCommUserRank) {
		lncclCommUserRank = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "ncclCommUserRank");
		tracer._kernel_map[(void *) lncclCommUserRank] = std::string("ncclCommUserRank");
	}
	assert(lncclCommUserRank);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommUserRank(comm, rank);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommUserRank);
	}
	return res;
}

ncclResult_t pncclCommUserRank(const ncclComm_t  comm, int*  rank)
{
	static ncclResult_t (*lpncclCommUserRank) (const ncclComm_t , int* );
	if (!lpncclCommUserRank) {
		lpncclCommUserRank = (ncclResult_t (*) (const ncclComm_t , int* )) dlsym(RTLD_NEXT, "pncclCommUserRank");
		tracer._kernel_map[(void *) lpncclCommUserRank] = std::string("pncclCommUserRank");
	}
	assert(lpncclCommUserRank);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommUserRank(comm, rank);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommUserRank);
	}
	return res;
}

ncclResult_t ncclRedOpCreatePreMulSum(ncclRedOp_t * op, void * scalar, ncclDataType_t  datatype, ncclScalarResidence_t  residence, ncclComm_t  comm)
{
	static ncclResult_t (*lncclRedOpCreatePreMulSum) (ncclRedOp_t *, void *, ncclDataType_t , ncclScalarResidence_t , ncclComm_t );
	if (!lncclRedOpCreatePreMulSum) {
		lncclRedOpCreatePreMulSum = (ncclResult_t (*) (ncclRedOp_t *, void *, ncclDataType_t , ncclScalarResidence_t , ncclComm_t )) dlsym(RTLD_NEXT, "ncclRedOpCreatePreMulSum");
		tracer._kernel_map[(void *) lncclRedOpCreatePreMulSum] = std::string("ncclRedOpCreatePreMulSum");
	}
	assert(lncclRedOpCreatePreMulSum);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclRedOpCreatePreMulSum(op, scalar, datatype, residence, comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclRedOpCreatePreMulSum);
	}
	return res;
}

ncclResult_t pncclRedOpCreatePreMulSum(ncclRedOp_t * op, void * scalar, ncclDataType_t  datatype, ncclScalarResidence_t  residence, ncclComm_t  comm)
{
	static ncclResult_t (*lpncclRedOpCreatePreMulSum) (ncclRedOp_t *, void *, ncclDataType_t , ncclScalarResidence_t , ncclComm_t );
	if (!lpncclRedOpCreatePreMulSum) {
		lpncclRedOpCreatePreMulSum = (ncclResult_t (*) (ncclRedOp_t *, void *, ncclDataType_t , ncclScalarResidence_t , ncclComm_t )) dlsym(RTLD_NEXT, "pncclRedOpCreatePreMulSum");
		tracer._kernel_map[(void *) lpncclRedOpCreatePreMulSum] = std::string("pncclRedOpCreatePreMulSum");
	}
	assert(lpncclRedOpCreatePreMulSum);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclRedOpCreatePreMulSum(op, scalar, datatype, residence, comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclRedOpCreatePreMulSum);
	}
	return res;
}

ncclResult_t ncclRedOpDestroy(ncclRedOp_t  op, ncclComm_t  comm)
{
	static ncclResult_t (*lncclRedOpDestroy) (ncclRedOp_t , ncclComm_t );
	if (!lncclRedOpDestroy) {
		lncclRedOpDestroy = (ncclResult_t (*) (ncclRedOp_t , ncclComm_t )) dlsym(RTLD_NEXT, "ncclRedOpDestroy");
		tracer._kernel_map[(void *) lncclRedOpDestroy] = std::string("ncclRedOpDestroy");
	}
	assert(lncclRedOpDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclRedOpDestroy(op, comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclRedOpDestroy);
	}
	return res;
}

ncclResult_t pncclRedOpDestroy(ncclRedOp_t  op, ncclComm_t  comm)
{
	static ncclResult_t (*lpncclRedOpDestroy) (ncclRedOp_t , ncclComm_t );
	if (!lpncclRedOpDestroy) {
		lpncclRedOpDestroy = (ncclResult_t (*) (ncclRedOp_t , ncclComm_t )) dlsym(RTLD_NEXT, "pncclRedOpDestroy");
		tracer._kernel_map[(void *) lpncclRedOpDestroy] = std::string("pncclRedOpDestroy");
	}
	assert(lpncclRedOpDestroy);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclRedOpDestroy(op, comm);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclRedOpDestroy);
	}
	return res;
}

ncclResult_t ncclReduce(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, ncclRedOp_t  op, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclReduce) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , int , ncclComm_t , cudaStream_t );
	if (!lncclReduce) {
		lncclReduce = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclReduce");
		tracer._kernel_map[(void *) lncclReduce] = std::string("ncclReduce");
	}
	assert(lncclReduce);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclReduce(sendbuff, recvbuff, count, datatype, op, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclReduce);
	}
	return res;
}

ncclResult_t pncclReduce(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, ncclRedOp_t  op, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclReduce) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , int , ncclComm_t , cudaStream_t );
	if (!lpncclReduce) {
		lpncclReduce = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclReduce");
		tracer._kernel_map[(void *) lpncclReduce] = std::string("pncclReduce");
	}
	assert(lpncclReduce);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclReduce(sendbuff, recvbuff, count, datatype, op, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclReduce);
	}
	return res;
}

ncclResult_t ncclBcast(void*  buff, size_t  count, ncclDataType_t  datatype, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclBcast) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lncclBcast) {
		lncclBcast = (ncclResult_t (*) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclBcast");
		tracer._kernel_map[(void *) lncclBcast] = std::string("ncclBcast");
	}
	assert(lncclBcast);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclBcast(buff, count, datatype, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclBcast);
	}
	return res;
}

ncclResult_t pncclBcast(void*  buff, size_t  count, ncclDataType_t  datatype, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclBcast) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lpncclBcast) {
		lpncclBcast = (ncclResult_t (*) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclBcast");
		tracer._kernel_map[(void *) lpncclBcast] = std::string("pncclBcast");
	}
	assert(lpncclBcast);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclBcast(buff, count, datatype, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclBcast);
	}
	return res;
}

ncclResult_t ncclBroadcast(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclBroadcast) (const void* , void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lncclBroadcast) {
		lncclBroadcast = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclBroadcast");
		tracer._kernel_map[(void *) lncclBroadcast] = std::string("ncclBroadcast");
	}
	assert(lncclBroadcast);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclBroadcast(sendbuff, recvbuff, count, datatype, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclBroadcast);
	}
	return res;
}

ncclResult_t pncclBroadcast(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, int  root, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclBroadcast) (const void* , void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lpncclBroadcast) {
		lpncclBroadcast = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclBroadcast");
		tracer._kernel_map[(void *) lpncclBroadcast] = std::string("pncclBroadcast");
	}
	assert(lpncclBroadcast);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclBroadcast(sendbuff, recvbuff, count, datatype, root, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclBroadcast);
	}
	return res;
}

ncclResult_t ncclAllReduce(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, ncclRedOp_t  op, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclAllReduce) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t );
	if (!lncclAllReduce) {
		lncclAllReduce = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclAllReduce");
		tracer._kernel_map[(void *) lncclAllReduce] = std::string("ncclAllReduce");
	}
	assert(lncclAllReduce);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclAllReduce(sendbuff, recvbuff, count, datatype, op, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclAllReduce);
	}
	return res;
}

ncclResult_t pncclAllReduce(const void*  sendbuff, void*  recvbuff, size_t  count, ncclDataType_t  datatype, ncclRedOp_t  op, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclAllReduce) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t );
	if (!lpncclAllReduce) {
		lpncclAllReduce = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclAllReduce");
		tracer._kernel_map[(void *) lpncclAllReduce] = std::string("pncclAllReduce");
	}
	assert(lpncclAllReduce);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclAllReduce(sendbuff, recvbuff, count, datatype, op, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclAllReduce);
	}
	return res;
}

ncclResult_t ncclReduceScatter(const void*  sendbuff, void*  recvbuff, size_t  recvcount, ncclDataType_t  datatype, ncclRedOp_t  op, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclReduceScatter) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t );
	if (!lncclReduceScatter) {
		lncclReduceScatter = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclReduceScatter");
		tracer._kernel_map[(void *) lncclReduceScatter] = std::string("ncclReduceScatter");
	}
	assert(lncclReduceScatter);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclReduceScatter(sendbuff, recvbuff, recvcount, datatype, op, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclReduceScatter);
	}
	return res;
}

ncclResult_t pncclReduceScatter(const void*  sendbuff, void*  recvbuff, size_t  recvcount, ncclDataType_t  datatype, ncclRedOp_t  op, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclReduceScatter) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t );
	if (!lpncclReduceScatter) {
		lpncclReduceScatter = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclRedOp_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclReduceScatter");
		tracer._kernel_map[(void *) lpncclReduceScatter] = std::string("pncclReduceScatter");
	}
	assert(lpncclReduceScatter);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclReduceScatter(sendbuff, recvbuff, recvcount, datatype, op, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclReduceScatter);
	}
	return res;
}

ncclResult_t ncclAllGather(const void*  sendbuff, void*  recvbuff, size_t  sendcount, ncclDataType_t  datatype, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclAllGather) (const void* , void* , size_t , ncclDataType_t , ncclComm_t , cudaStream_t );
	if (!lncclAllGather) {
		lncclAllGather = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclAllGather");
		tracer._kernel_map[(void *) lncclAllGather] = std::string("ncclAllGather");
	}
	assert(lncclAllGather);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclAllGather(sendbuff, recvbuff, sendcount, datatype, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclAllGather);
	}
	return res;
}

ncclResult_t pncclAllGather(const void*  sendbuff, void*  recvbuff, size_t  sendcount, ncclDataType_t  datatype, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclAllGather) (const void* , void* , size_t , ncclDataType_t , ncclComm_t , cudaStream_t );
	if (!lpncclAllGather) {
		lpncclAllGather = (ncclResult_t (*) (const void* , void* , size_t , ncclDataType_t , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclAllGather");
		tracer._kernel_map[(void *) lpncclAllGather] = std::string("pncclAllGather");
	}
	assert(lpncclAllGather);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclAllGather(sendbuff, recvbuff, sendcount, datatype, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclAllGather);
	}
	return res;
}

ncclResult_t ncclSend(const void*  sendbuff, size_t  count, ncclDataType_t  datatype, int  peer, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclSend) (const void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lncclSend) {
		lncclSend = (ncclResult_t (*) (const void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclSend");
		tracer._kernel_map[(void *) lncclSend] = std::string("ncclSend");
	}
	assert(lncclSend);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclSend(sendbuff, count, datatype, peer, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclSend);
	}
	return res;
}

ncclResult_t pncclSend(const void*  sendbuff, size_t  count, ncclDataType_t  datatype, int  peer, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclSend) (const void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lpncclSend) {
		lpncclSend = (ncclResult_t (*) (const void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclSend");
		tracer._kernel_map[(void *) lpncclSend] = std::string("pncclSend");
	}
	assert(lpncclSend);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclSend(sendbuff, count, datatype, peer, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclSend);
	}
	return res;
}

ncclResult_t pncclRecv(void*  recvbuff, size_t  count, ncclDataType_t  datatype, int  peer, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lpncclRecv) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lpncclRecv) {
		lpncclRecv = (ncclResult_t (*) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "pncclRecv");
		tracer._kernel_map[(void *) lpncclRecv] = std::string("pncclRecv");
	}
	assert(lpncclRecv);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclRecv(recvbuff, count, datatype, peer, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclRecv);
	}
	return res;
}

ncclResult_t ncclRecv(void*  recvbuff, size_t  count, ncclDataType_t  datatype, int  peer, ncclComm_t  comm, cudaStream_t  stream)
{
	static ncclResult_t (*lncclRecv) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t );
	if (!lncclRecv) {
		lncclRecv = (ncclResult_t (*) (void* , size_t , ncclDataType_t , int , ncclComm_t , cudaStream_t )) dlsym(RTLD_NEXT, "ncclRecv");
		tracer._kernel_map[(void *) lncclRecv] = std::string("ncclRecv");
	}
	assert(lncclRecv);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclRecv(recvbuff, count, datatype, peer, comm, stream);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclRecv);
	}
	return res;
}

ncclResult_t ncclGroupStart()
{
	static ncclResult_t (*lncclGroupStart) ();
	if (!lncclGroupStart) {
		lncclGroupStart = (ncclResult_t (*) ()) dlsym(RTLD_NEXT, "ncclGroupStart");
		tracer._kernel_map[(void *) lncclGroupStart] = std::string("ncclGroupStart");
	}
	assert(lncclGroupStart);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclGroupStart();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGroupStart);
	}
	return res;
}

ncclResult_t pncclGroupStart()
{
	static ncclResult_t (*lpncclGroupStart) ();
	if (!lpncclGroupStart) {
		lpncclGroupStart = (ncclResult_t (*) ()) dlsym(RTLD_NEXT, "pncclGroupStart");
		tracer._kernel_map[(void *) lpncclGroupStart] = std::string("pncclGroupStart");
	}
	assert(lpncclGroupStart);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclGroupStart();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGroupStart);
	}
	return res;
}

ncclResult_t ncclGroupEnd()
{
	static ncclResult_t (*lncclGroupEnd) ();
	if (!lncclGroupEnd) {
		lncclGroupEnd = (ncclResult_t (*) ()) dlsym(RTLD_NEXT, "ncclGroupEnd");
		tracer._kernel_map[(void *) lncclGroupEnd] = std::string("ncclGroupEnd");
	}
	assert(lncclGroupEnd);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclGroupEnd();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclGroupEnd);
	}
	return res;
}

ncclResult_t pncclGroupEnd()
{
	static ncclResult_t (*lpncclGroupEnd) ();
	if (!lpncclGroupEnd) {
		lpncclGroupEnd = (ncclResult_t (*) ()) dlsym(RTLD_NEXT, "pncclGroupEnd");
		tracer._kernel_map[(void *) lpncclGroupEnd] = std::string("pncclGroupEnd");
	}
	assert(lpncclGroupEnd);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclGroupEnd();

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclGroupEnd);
	}
	return res;
}

ncclResult_t ncclCommRegister(const ncclComm_t  comm, void*  buff, size_t  size, void**  handle)
{
	static ncclResult_t (*lncclCommRegister) (const ncclComm_t , void* , size_t , void** );
	if (!lncclCommRegister) {
		lncclCommRegister = (ncclResult_t (*) (const ncclComm_t , void* , size_t , void** )) dlsym(RTLD_NEXT, "ncclCommRegister");
		tracer._kernel_map[(void *) lncclCommRegister] = std::string("ncclCommRegister");
	}
	assert(lncclCommRegister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommRegister(comm, buff, size, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommRegister);
	}
	return res;
}

ncclResult_t pncclCommRegister(const ncclComm_t  comm, void*  buff, size_t  size, void**  handle)
{
	static ncclResult_t (*lpncclCommRegister) (const ncclComm_t , void* , size_t , void** );
	if (!lpncclCommRegister) {
		lpncclCommRegister = (ncclResult_t (*) (const ncclComm_t , void* , size_t , void** )) dlsym(RTLD_NEXT, "pncclCommRegister");
		tracer._kernel_map[(void *) lpncclCommRegister] = std::string("pncclCommRegister");
	}
	assert(lpncclCommRegister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommRegister(comm, buff, size, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommRegister);
	}
	return res;
}

ncclResult_t ncclCommDeregister(const ncclComm_t  comm, void*  handle)
{
	static ncclResult_t (*lncclCommDeregister) (const ncclComm_t , void* );
	if (!lncclCommDeregister) {
		lncclCommDeregister = (ncclResult_t (*) (const ncclComm_t , void* )) dlsym(RTLD_NEXT, "ncclCommDeregister");
		tracer._kernel_map[(void *) lncclCommDeregister] = std::string("ncclCommDeregister");
	}
	assert(lncclCommDeregister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lncclCommDeregister(comm, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lncclCommDeregister);
	}
	return res;
}

ncclResult_t pncclCommDeregister(const ncclComm_t  comm, void*  handle)
{
	static ncclResult_t (*lpncclCommDeregister) (const ncclComm_t , void* );
	if (!lpncclCommDeregister) {
		lpncclCommDeregister = (ncclResult_t (*) (const ncclComm_t , void* )) dlsym(RTLD_NEXT, "pncclCommDeregister");
		tracer._kernel_map[(void *) lpncclCommDeregister] = std::string("pncclCommDeregister");
	}
	assert(lpncclCommDeregister);

    float _time_ms = 0.0f;

    cudaEvent_t _start, _stop;
    if (tracer.profile_start) {
        cudaEventCreate(&_start);
        cudaEventCreate(&_stop);
        cudaDeviceSynchronize();

        cudaEventRecord(_start);
    }
	ncclResult_t res = 
		lpncclCommDeregister(comm, handle);

    if (tracer.profile_start) {
        cudaEventRecord(_stop);
        cudaEventSynchronize(_stop);
        cudaEventElapsedTime(&_time_ms, _start, _stop);

        tracer._kernel_time.push_back(_time_ms);
    }
	if (tracer.profile_start) {
		tracer._kernel_seq.push_back((void *)lpncclCommDeregister);
	}
	return res;
}


void __cudaRegisterFunction(void ** fatCubinHandle, const char * hostFun, char * deviceFun, const char * deviceName, int  thread_limit, uint3 * tid, uint3 * bid, dim3 * bDim, dim3 * gDim, int * wSize)
{
    static void (*l__cudaRegisterFunction) (void **, const char *, char *, const char *, int , uint3 *, uint3 *, dim3 *, dim3 *, int *);
    if (!l__cudaRegisterFunction) {
        l__cudaRegisterFunction = (void (*) (void **, const char *, char *, const char *, int , uint3 *, uint3 *, dim3 *, dim3 *, int *)) dlsym(RTLD_NEXT, "__cudaRegisterFunction");
    }
    assert(l__cudaRegisterFunction);

    // store kernal names
    std::string deviceFun_str(deviceFun);
    tracer._kernel_map[(const void *)hostFun] = demangleFunc(deviceFun_str);

    return l__cudaRegisterFunction(fatCubinHandle, hostFun, deviceFun, deviceName, thread_limit, tid, bid, bDim, gDim, wSize);
}
        



}

